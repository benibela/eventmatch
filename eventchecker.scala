import scala.io._

//reads the output generated by the heuristic (vector clocks and events)
class OutputReader{
    val allStdinLines=Source.fromInputStream(System.in).getLines.toList;  //read whole stdin
	val n = allStdinLines(0).trim().toInt;
	if (allStdinLines.length != (n+1)*n+1 && allStdinLines.length != (n+1)*n+2) 
		throw new Exception("wrong size"+allStdinLines.length.toString +" vs. "+(n+1)*n+1);
	val stdinLines=allStdinLines.drop(1);
	//val n = stdinLines.length;
	var logs = new Array[Log](n);
	for (i <- 0 until n) {
		val words = stdinLines((n+1)*i).split("[ \t]").filter(w => w.length>0 && w(0) > 13);
		logs(i) = new Log(n,words.length);
		for (j <- 0 until words.length) 
			if (words(j)(0) >= 'A' && words(j)(0) <= 'Z') logs(i).data(j) = words(j)(0)-'A'+1;
			else if (words(j)(0) >= 'a' && words(j)(0) <= 'z') logs(i).data(j) = -words(j)(0)+'a'-1;
			else throw new Exception ("Unknown word: "+words(j));
		for (j <- 0 until n) {
			val clocks = stdinLines((n+1)*i+j+1).split("[- \t]").filter(w => w.length>0 && w(0) > 13);
			for (k <- 0 until clocks.length/2){
				logs(i).clocksMin(k)(j) = clocks(2*k).toInt;
				logs(i).clocksMax(k)(j) = clocks(2*k+1).toInt;
			}
		}
	}
}

object EventChecker{
  def main(args: Array[String]) {
    val arrayLogs = new OutputReader().logs;
	val logs = new Logs(arrayLogs);
	logs.foreach(println);
	if (args.contains("--sender-min")){
	  //checks if S_l(q)_min <= S_l(r)_min for all q<r holds
		logs.foreach ({ log =>
		  for (r <- 0 until log.length) 
			if (log(r) < 0) {
			  //println("c"+log.clocksMax(logs.senderCache(-log(r))));
			  val Sr=logs.senderLog(-log(r));
			  val Si=log.clocksMax(r)(logs.senderCache(-log(r)));
			  for (q <- 0 until r) 
				if (log(q) < 0) {
				  val Sq=logs.senderLog(-log(q));
				  val Sj=log.clocksMax(q)(logs.senderCache(-log(q)));
				  for (l <- 0 until logs.length)
					assert(Sq.clocksMin(Sj)(l) <= Sr.clocksMin(Si)(l), log.id + ":"+q + "-" + r);
				}
			}
		});
	} else if (args.contains("--rec-clock-algo") || args.contains("--rec-clock-algo-last-sender")
		|| args.contains("--rec-clock-algo-first-last-sender")){
		val useLastSender = args.contains("--rec-clock-algo-last-sender"); //nur letzten sender für eine neue vektoruhr nehmen
		val useBorderSenderOnly = args.contains("--rec-clock-algo-first-last-sender"); //nur ersten/letztes nehmen
		//vektoruhrarray das mit den neuen uhren gefüllt wird
		var realClocks = new Array[Array[Array[Int]]](logs.length).indices.map {
			i => new Array[Array[Int]] (logs(i).length) map {
				ign => new Array[Int](logs.length)}
		};
		var curClock = 	new Array[Int](logs.length);
		//noch zu betrachtende ereignisse in jedem log
		var lastItems = new Array[Int](logs.length);//logs.indices.map ( l => logs(l).data.indices.findIndexOf ( i => logs(l)(i) < 0 ));
		//for (i <- 0 until logs.length) if (curItems(i) < 0) curItems(i) = logs(i).length;
		print("curitems:");
		//curItems.foreach(x=>print(x+" " ));
		println;
		//solange noch nicht-betrachtete empfangsereignisse existieren
		while (lastItems.zipWithIndex.exists(m => (m._1 until logs(m._2).length).exists(logs(m._2)(_)<0))) {
			//nächste empfangsereignisse
			val curItems = logs.indices map (l=> (lastItems(l) until logs(l).length).find(logs(l)(_)<0).getOrElse(logs(l).length)); 
			//nächste sendeereignisse
			val senderItems = logs.indices map (l=> (lastItems(l) until logs(l).length).find(logs(l)(_)>0).getOrElse(logs(l).length)); 
			//suche  Sender die den nächsten empfangsereignissen zugewiesen werden können, ohne
			//einen widerspruch zur  aktuellen vektoruhr zu bilden
			val  clockIndex = (0 until logs.length).map ( i=>
				if (curItems(i) >= logs(i).length) -1
				else {
					val curItemData = -logs(i)(curItems(i));
					val senderLogId = logs.senderCache(curItemData);
					if (useLastSender)logs(i).clocksMax(curItems(i))(senderLogId) //wähle minimum
					else if (useBorderSenderOnly) {
						//wähle minimum wenn möglich sonst maximm
						val minIndex=logs(i).clocksMin(curItems(i))(senderLogId);
						if (curClock zip logs(senderLogId).clocksMax(minIndex) forall (i=>i._1 <= i._2))
							minIndex
						else logs(i).clocksMax(curItems(i))(senderLogId);
					} else ((Math.max(curClock(senderLogId),senderItems(senderLogId)) until logs(senderLogId).length) find (j=>logs(senderLogId)(j)==curItemData)).get; //wähle frühestmögliches
				}
			)
			println(">"+lastItems.mkString(" ")+"  >  "+curItems.mkString(" ")+"  >  "+senderItems.mkString(" ")+" => "+clockIndex.mkString(" "));
			//Berechne mögliche Vektoruhren (maximum von aktueller uhr und minimum der intervalluhren für jedes 		log)
			var w = new Array[Array[Int]](logs.length).indices.map {i => 
				if (curItems(i) >= logs(i).length) null
				else {
					val curItemData = -logs(i)(curItems(i));
					val newClock = logs.senderLog(curItemData).clocksMin(clockIndex(i));
					(for (j <- 0 until logs.length) 
						yield Math.max(Math.max(curClock(j), newClock(j)), logs(i).clocksMin(curItems(i))(j))).toArray
				}
			}
			//wähle eine mögliche uhr
			val l=logs.indices.findIndexOf( l =>
			    curItems(l)<logs(l).length &&
				logs.indices.forall(i => 
				  curItems(i)>=logs(i).length ||
				  logs.indices.forall(j=>w(l)(j) <= logs(i).clocksMax(curItems(i))(j))
				)
			);
			if (l<0) {
				println("Couldn't find clock");
				println("cur:"+curItems.deepToString());
				println("w-s:");
				w.foreach{v => v.foreach{a => print (a+" ");}; println;}
				//println("sender_l_min:");
				//logs.foreach{log=>
				println("max:");
				for (i<-0 until logs.length) {
					if (curItems(i)>=logs(i).length) println("x");
					else logs(i).clocksMax(curItems(i)).foreach(a=>print(a + " "));
					println;
				}
				println("s_lmin:");
				for (i<-0 until logs.length) {
					if (curItems(i)>=logs(i).length) println("x");
					else logs.lastSenderMinClock(i,curItems(i)).foreach(a=>print(a + " "));
					println;
				}
				assert(l>=0, "Couldn't find clock");	
			}
			w(l).foreach(i=>print (i+" "));
			println(" for "+l+":"+curItems(l));
			//speichere uhr und  neue nächste ereignisse
			curClock = w(l) map (i=>i);
			realClocks(l)(curItems(l)) = curClock map (i=>i);
			
			lastItems=curClock;
			//assert(lastItems(l)<curItems(l)+1,"WTF??");			
			lastItems(l) = Math.max(lastItems(l),curItems(l)+1);
			val senderLogId = logs.senderCache(-logs(l)(curItems(l)));
			//assert(lastItems(senderLogId)<senderItems(senderLogId)+1,"WTF???");
			lastItems(senderLogId) = Math.max(lastItems(senderLogId)+1,senderItems(senderLogId)+1);
			//while (curItems(l) < logs(l).length && logs(l)(curItems(l))>0) curItems(l) += 1;
		}
		//überorüfe ob die ermittelten uhren gültig sind
		var newLogs = logs.logs map {log => log.clone()};
		for (l <- 0 until logs.length) 
			for (i<- 0 until logs(l).length)
				if (logs(l)(i) < 0) {
					newLogs(l).clocksMin(i) = realClocks(l)(i);// map (i=>i);
					newLogs(l).clocksMax(i) = realClocks(l)(i);// map (i=>i); 
				}
		newLogs.foreach(println);
		for (l <- 0 until logs.length) 
			for (i<- 0 until logs(l).length)
				if (logs(l)(i) < 0) {
					assert(logs(l).clocksMin(i) zip realClocks(l)(i) forall (t => t._1 <= t._2), "clock should be after receiver min" + l + ":"+i+" :"+realClocks(l)(i).mkString(" "));
					assert(realClocks(l)(i) zip logs(l).clocksMax(i) forall (t => t._1 <= t._2), "clock should be before receiver max"+ l + ":"+i);
					val slog = logs.senderLog(-logs(l)(i));
					var senderId = realClocks(l)(i)(slog.id);
					assert(slog(senderId)+logs(l)(i)==0, "sender receiver should have the same type")
					assert(slog.clocksMin(senderId) zip realClocks(l)(i) forall (t => t._1 <= t._2), "clock should be after sender min"+ l + ":"+i+" :"+logs.lastSenderMinClock(l,i).mkString(" "));
					assert(realClocks(l)(i) zip slog.clocksMax(senderId) forall (t => t._1 <= t._2), "clock should be before sender max"+ l + ":"+i);
					for (l2 <- 0 until logs.length) 
						for (i2<- 0 until logs(l2).length)
							if (logs(l2)(i2) < 0 && logs.senderCache(-logs(l2)(i2)) == slog.id &&
								senderId==realClocks(l2)(i2)(slog.id)) 
								assert(realClocks(l)(i) zip realClocks(l2)(i2) forall (t => t._1 == t._2), "equal receiver should have equal clock"+ l + ":"+i+" <-> "+ l2+":"+i2);
				}
		
	} else println("No check performed, use --sender-min (checks if S_l(q)_min <= S_l(r)_min for q<=r in the same log)\n or --rec-clock-algo or --rec-clock-algo-last-sender or --rec-clock-algo-first-last-sender to check if you can find a correct solution by like described in appendix n_L=2 (using all sender for minimum vector clock, last only, or first+last)");
  }
}