\newcommand{\OBDA}{O.B.d.A. }
\newcommand{\packetTypSet}{\mathcal{P}}
\newcommand{\mybreak}{\\\hspace*{0.5cm}}  

\chapter{Einführung}
In jedem Netzwerk oder verteilten System existieren gleichzeitig viele Prozesse in unterschiedlichen Knoten, die im wesentlichen voneinander unabhängig arbeiten. %, deren Prozesse als eine Folge von Ereignissen auftreten.\\
Einige dieser Prozesse kommunizieren jedoch untereinander, so dass der Ablauf der Prozesse in manchen Knoten von anderen Knoten geändert wird. Häufig muss man nun die globale Ereignisreihenfolge, also wann 
 welche Knoten andere beeinflusst haben könnten, ermitteln. %, beispielsweise wenn man in der Forschung bestimmte Hypothesen über das Verhalten von Netzwerken experimentell überprüfen möchte oder wenn man in der Industrie  auftretende Fehler untersuchten muss. Ein anderes Beispiel ist der LHC, bei dem aus den Aufnahmen, welche durch die einzelnen Detektoren entstanden und versenden wurden, berechnete werden muss, ob sie alle das gleiche oder unterschiedliche Teilchen gesehen haben. %und den berechnet  dem zeitlichen Ablauf \\%, wie welcher Knoten welchen anderen beeinflusst hat, sei 
%Es könnte auch passieren, dass jemand, während der Benutzung einer P2P-Chatsoftware (z.B.: Skype) ermordet wird, dann könnte man versuchen, aus den Ereignissen im Netzwerk den genauen Todeszeitpunkt zu ermitteln und die Zahl der Verdächtigen einzuschränken.
   
%In anderen Fällen ist die Bedeutung eines solchen Algorithmus jedoch enorm: Man stelle sich vor, dass im LHC ein neues Teilchen entdeckt wird, aber auf Grund eines Computerfehlers nicht sicher ist, ob der zeitliche Ablauf korrekt gespeichert wurde, und es sich nicht um mehrere hintereinander entstandene Teilchen handelt. Dann könnte man einen solchen Algorithmus verwenden, um den korrekten Zeitlichen Ablauf aus den Aufzeichnungen der einzelnen Detektoren wiederherzustellen.\\
%Ein anderer denkbarer Fall wäre, dass jemand gerade, als er ein Chatprogramm, welches seine Nachrichten ohne Zeitstempel versendet, benutzt, ermordet wird. Dann könnte man, falls diese Nachrichten aufgezeichnet wurden,  versuchen aus ihnen und anderen vorhandenen Logs den genauen Todeszeitpunkt zu ermitteln. 
%es um Fehler zu suchen, oder den globalen Zustand zu erfahren.\\
Eine einfache Lösung zur Bestimmung des vollständigen Ablaufs scheint es zu sein, in jedem Knoten eine Logdatei zu führen, in der alle empfangenen und gesendeten Nachrichten verzeichnet werden.
Doch man erkennt schnell, dass solche Logs alleine nicht ausreichen, um den globalen Ablauf nachvollziehen zu können. Denn es ist nicht trivial, die in Sende- und Empfangslog aufgezeichneten Nachrichten einander zuzuordnen, da viele der Nachrichten in einem LAN-Segment (wie zum Beispiel ARP-Requests \cite{rfcARPnew5227}) %oder andere Statusinformationen, 
nicht eindeutig sind. Außerdem können gesendete Nachrichten während der Übertragung verloren gehen, so dass sie nicht in jedem Log aufgezeichnet werden, wodurch für ein Empfangsereignis mehrere mögliche Sendeereignisse existieren können.

Eine vermeintlich einfache Lösung wäre es jedes Paket mit einer eindeutigen ID zu versehen, wie sie beispielsweise bei einem zuverlässigen Übertragungsprotokoll verwendet wird.
%Die übliche Lösung für dieses Problem besteht darin Zeitstempel mitzusenden, entweder basierend auf einer physikalischen Uhr oder in Form einer logischen Zeit nach oder .

Dieser Ansatz ist jedoch häufig nicht praktikabel, denn er erfordert, die kommunizierenden Prozesse umzuprogrammieren und eventuell alte Experimente zu wiederholen. Wünschenswert wäre ein Verfahren mit dem sich eine eindeutige Zuordnung zwischen Sende- und Empfangsereignissen nachträglich aus unvollständigen Aufzeichnungen berechnen ließe, ohne dass man weitere Informationen benötigt.  %die Übertragung der Zeitstempel erfordert nicht nur zusätzliche Bandbreite, was in extrem zeitkritischen Anwendungen problematisch werden kann, es wäre zudem auch nötig, alle früher durchgeführten Experimente, bei denen keinen Zeitstempel verwendet wurden, zu wiederholen. Außerdem ist die Synchronisation der entsprechenden Zeiten umständlich, da es bei physikalischen Uhren leicht passieren kann, dass  leichte Schwankungen des Taktgebers die Synchronisation zerstören. Bei einer logischen Zeit dagegen benötigt man zusätzliche Bestätigungsnachrichtungen für die von einem anderen Knoten empfangene Zeit, die weitere Bandbreite verbrauchen.

Im Rahmen dieser Arbeit wird zuerst dieses Problem der Zuordnungen formal spezifiziert und auf seine Komplexität untersucht. 
Danach werden zwei Algorithmen zu dessen Lösung vorgestellt, eine schnelle, jedoch unzuverlässige Heuristik, sowie ein perfekt arbeitendes Verfahren mit entsprechender Laufzeit.   %/werden nun ein/-ige Algorithmus/en untersucht, der/die in den bereits -- ohne Zeitstempel -- vorhandenen Logs nach Korrelationen sucht und aus diesen berechnet, welche Empfangs- und Sendeereignisse zur selben Nachricht gehören müssen oder können.


\chapter{Problemstellung}
\label{chap:problem}
Man benötigt zuerst eine formale Darstellung für die aufgezeichneten Logdateien, sowie für die zu ermittelnde Zuordnung zwischen den Ereignissen. 
Hierzu werden im wesentlichen die Definitionen aus \cite{WhoSaidThat} übernommen, wo das Problem zum ersten Mal vorgestellt wurde.

Die einzelnen Knoten werden von $0$ bis $n_L$ durchnummeriert\footnote{Die 0-basierte Nummerierung ist sehr gut geeignet um ein bestimmtes Log $L_0$ von den anderen zu unterscheiden. In einigen späteren Kapiteln über die Algorithmen ist dies jedoch nicht nötig, so dass dort die intuitivere, bei 1 beginnende Nummerierung verwendet wird, indem \OBDA $L_0 = \emptyset$ vorausgesetzt wird.} und das Log eines Knoten $i$ wird als Menge $L_i$ von Ereignissen dargestellt. 
Zur Vereinfachung der Notation werden alle Ereignisse in einer Menge $L = \bigcup L_i$ zusammengefasst und eine Funktion $N: L \rightarrow \mathbb{N}$ definiert, die jedem Ereignis  die Nummer der Logdatei  zuweist, in der das Ereignis gespeichert ist, also $e \mapsto l$ für $e \in L_l$.

Jedes Ereignis ist dabei entweder ein Sende- oder ein Empfangsereignis, je nachdem ob der Knoten damit das Senden oder den Empfang einer Nachricht in der Logdatei aufgezeichnet hat. Diese Zuordnung wird als Funktion $D: L \rightarrow \{\tilde s,\tilde r\}$ dargestellt, wobei $\tilde s$ für ">Senden"< und $\tilde r$ für ">Empfangen"< steht.	

Damit kann man die Menge aller Sendeereignisse $S = \{s \in L | D(s) = \tilde{s}\}$ und die Menge aller Empfangsereignisse $R = \{r\in L |D(r) = \tilde{r}\}$ definieren. Außerdem erweist es sich als eine nützliche Vereinfachung der Notation für jedes Log $ L_l $ die Menge aller enthaltenen Sendeereignisse als $S_l = S \cap L_l$ und die Menge aller enthaltenen Empfangsereignisse als $R_l = R \cap L_l$ zu bezeichnen.


Um die Ereignisse in den Logdateien vergleichen zu können, wird jedem Ereignis mittels einer Funktion $P: L \rightarrow \packetTypSet$ ein Pakettyp zugeordnet. Diese Pakettypen bilden die Menge $\packetTypSet$ und müssen so gewählt sein, dass Ereignissen, die identische Nachrichten betreffen, der gleiche Pakettyp zugeordnet werden kann und unterschiedliche Nachrichten unterschiedliche Pakettypen erhalten. Dies lässt sich in einer Implementierung beispielsweise durch einen guten Hash des gesamten Paketinhaltes inklusive Header erreichen.


In jedem  Log ist zudem implizit die Reihenfolge der Ereignisse gespeichert, was %bei \cite{WhoSaidThat} 
durch eine Ordnungsrelation $\prec_l$ für jedes Log $L_l$ dargestellt wird, so dass $e \prec_l f$ für $e, f \in L_l$ gilt, falls $e$ vor $f$ aufgezeichnet wird. Für Ereignisse, die nicht im Log $L_l$ sind, ist $\prec_l$ selbstverständlich undefiniert. Gilt zudem für zwei Ereignisse $e, f$ entweder $e = f$ oder $e \prec_l f$, so wird dies zur Vereinfachung als $e \preceq_l f$ geschrieben.


Es lohnt sich hier auch eine anschauliche Darstellung der Logs einzuführen, die in den späteren Kapiteln vereinzelt verwendet wird. Dabei stellt man die Sendeereignisse durch die Großbuchstaben A, B, C, $\ldots$ dar und die Empfangsereignisse durch die Kleinbuchstaben a, b, c, $\ldots$, wobei Ereignisse mit gleichen Buchstaben denselben Typ besitzen (also $P(a) = P(A)$ für Ereignisse a und A). Jedes Log wird nun als eine Reihe von solchen als Buchstaben kodierten Ereignissen dargestellt, die in der Reihenfolge ihrer Aufzeichnung notiert werden, und alle Logs werden dann untereinander geschrieben. 
%In dieser Arbeit werden die Ereignisse allerdings stattdessen mit einem eindeutigen Index $e_l$  für $e\in L_l$ versehen, so dass $e_l <  f_l$ gilt für alle $e,f \in L_l$ mit $e \prec_l f$. Dies erleichtert in Kapitel \ref{Heuristik} die Analyse des von \cite{WhoSaidThat} und \cite{AlexMarold} vorgeschlagenen Algorithmus zur Lösung des Problems.

%Für ein Ereignis $e \in L_i$ sei $e_i$ der Index des Ereignis in diesem Log.\\
%$e_i < f_i$ falls 



Eine Zuordnung wird dann gemäß \cite{WhoSaidThat} durch eine Abbildung $A: L \rightarrow S$ dargestellt, die jedem Empfangsereignis ein Sendeereignis und jedes Sendeereignis sich selbst zuordnet:
\begin{defi}
	\label{def:GA}
Eine Abbildung $A: L \rightarrow S$ wird als globale Zuordnung (GA) bezeichnet, wenn gilt:
\begin{enumerate}
\item $\forall s\in S: A(s)=s$\\
Jedes Sendeereignis ist sich selbst zugeordnet
\item$\forall e\in L: P(e) = P(A(e))$\\
Alle einander zugeordneten Ereignisse haben denselben Nachrichtentyp %betreffen dieselbe Nachricht
\item$\forall r\in R: N(r) \neq N(A(r))$\\
Kein Knoten empfängt seine eigenen Nachrichten
\end{enumerate}
\end{defi}

Mit dieser Definition alleine besitzt man aber noch keine Möglichkeit zu entscheiden, ob die durch die Zuordnung festgelegten Übertragungsvorgänge tatsächlich in einem Experiment aufgetreten sein könnten. % entspricht. von unmöglichen zu unterscheiden. 
Deswegen wird in \cite{WhoSaidThat} nun eine formale Darstellung für die globale, zeitliche Reihenfolge der Ereignisse eingeführt: 

Die globale Transmissionordnung (GTO), eine irreflexive, partielle Ordnungsrelation der Sendeereignisse $\prec \subset S \times S$.

Damit kann man nun eine Konsistenzbedingung einführen, welche garantiert, dass die durch die GA gegebene Zuordnung zusammen mit der durch die GTO gegebene Reihenfolge nicht den in den Logs aufgezeichneten Reihenfolgen widerspricht:

\begin{defi}
Ein Paar $(\prec, A)$ heißt konsistent, wenn gilt:
\[\forall n \in N: \forall e_1, e_2 \in L_n: (e_1 \prec_n e_2 \Rightarrow A(e_1) \prec A(e_2))\]
\end{defi}

Diese Definition ist deswegen   sinnvoll, weil %lässt sich leicht verstehen, wenn man sich daran erinnert, dass 
wir sämtliche Übertragungsverzögerungen ignorieren. Das heißt wir gehen davon aus, dass $e$ und das zugeordnete Sendeereignis $A(e)$ immer gleichzeitig geschehen, weshalb aus $e_1 \prec_n e_2$  eben $A(e_1) \prec A(e_2)$ folgen muss.

%Eine Zuordnung nennen wir nun konsistent, wenn es eine Reihenfolge gibt. Formal:\\

\begin{defi}
Eine GA $A$ heißt konsistent, wenn es eine GTO $\prec$ gibt, so dass $(\prec,A)$ konsistent ist.
\end{defi}

Diese Definition macht Sinn, wenn man bedenkt, dass die Logdateien dadurch entstanden sind, dass die aufgezeichneten Nachrichten in einer bestimmten (durch die GTO ermittelten) Reihenfolge gesendet wurden und einander (durch die GA) zugeordnete Ereignisse gleichzeitig von ihren jeweiligen Knoten zu den Logs hinzugefügt wurden.  %Zuordnung genau dann möglich ist, wenn es eine Reihenfolge von gesendeten Nachrichten gibt, die genau dieser Zuordnung entsprechen.

Man sieht auch, dass man zu einer gegebenen konsistenten GA $A$ in Linearzeit eine GTO $\prec$ finden kann, so dass das Paar $(\prec,A)$ konsistent ist, indem man einfach mittels topologischem Sortieren (\cite{TopSort}) in Linearzeit eine Ordnungsrelation bestimmt, welche die für jedes Log durch die Konsistenzbedingung gegebenen Ordnungsrelationen enthält.  

Damit ist die Formalisierung des Problems in seiner allgemeinsten Form abgeschlossen.
Im Folgenden werden aber auch einige wichtige Spezialfälle betrachtet, für die nun zusätzliche Einschränkungen erforderlich sind.

Bei realen Experimenten tritt häufig der Spezialfall auf,  dass Nachrichten eines bestimmten Typs nur von genau einem Knoten ausgesandt werden können, da üblicherweise jede gesendete Nachricht die eindeutige ID des Senders enthält. Wird beispielsweise Ethernet verwendet, ist diese Adresse die MAC-Adresse, die weltweit eindeutig sein sollte\footnote{Praktisch gibt es zwar Adresskollisionen, aber in einem Labornetzwerk lassen sie sich leicht beheben.}.

In \cite{WhoSaidThat} wird dieser Spezialfall durch folgende Einschränkung spezifiziert:
%Der wichtigste Spezialfall tritt auf, wenn, also dass gilt: für jeden Pakettyp $P(e)$ existiert ein $l$ mit $\{s \in S|P(s) = P(e)\} \subseteq L_l$\\
%Oder in der äquivalenten Formulierung von \cite{WhoSaidThat}: 
\[\forall s_1, s_2 \in S: (P(s_1) = P(s_2) \Rightarrow N(s_1) = N(s_2))\]
Damit wird die dritte Bedingung einer GA ($N(r)  \neq N(A(r))$ für alle $r\in R$) im Grunde überflüssig, da je nach Struktur der Logs entweder jede oder keine ">GA"<, welche die ersten beiden Bedingungen erfüllt, die dritte erfüllt. Formaler ausgedrückt: Eine beliebige Abbildung $A: L \rightarrow S$, welche die ersten beiden Bedingungen einer  GA erfüllt, ist in diesem Fall genau dann eine GA, wenn es keine $r \in R_i$, $s \in S_i$ gibt mit $P(r) = P(s)$ (denn aus $N(r) = N(A(r)) = i$ würde folgen $r \in R_i$ und $s=A(r) \in S_i$ mit $P(s) = P(r)$).
%$r \in R_i$, $s \in S_i$ und $P(r) = P(s)$ würde folgen $N(r) = i = N(s) = N(A(r))$, da $P(A(r)) = P(s)$)


Bei der theoretische Analyse erweist es sich als nützlich, die Menge der möglichen Lösungen durch eine zusätzliche Anforderung einzuschränken, nämlich durch die Bedingung,  dass jedem Sendeereignis maximal ein Empfangsereignis zugeordnet werden darf. In der Praxis könnte sich diese Situation beispielsweise bei reinen Punkt-zu-Punkt Verbindungen ergeben.

Hierzu definieren wir:
\begin{defi}
Eine GA $A$ heißt eindeutig, wenn jedes Sendeereignis nur ein einziges Mal empfangen wird, also wenn gilt: 
\[r_1, r_2 \in R: (A(r_1) = A(r_2) \Rightarrow r_1 = r_2)\]
\end{defi}

%Das Problem, zu ermitteln, ob eine konsistente und eindeutige GA zu einer gegebenen Eingabe existiert, wird später bei den Komplexitätsüberlegungen hilfreich sein.

Sind nun bestimmte Logdateien gegeben, gibt es verschiedene Fragestellungen über die möglichen Zuordnungen.
Die im folgenden behandelten Problemstellungen sind:
\begin{description}
%Für ein Ereignis $r \in R$, was ist die Menge der möglichen Sendeereignisse, also für welche $s$ existiert ein  konsistenter GA $A$ mit $A(r) = s$

\item[SRC: ] Kann eine konsistente GA $A$ gefunden werden?%Existiert eine konsistente GA

\item[uSRC:] Kann eine konsistente und eindeutige GA $A$ gefunden werden?

\item[pSRC:] Was ist für ein gegebene Ereignis $r \in R$ die Menge der möglichen Sendeereignisse $\{s \in S | \exists \text{konsistente GA }A: A(r) = s\}$?

\end{description}

Die drei Abkürzungen bedeuten jeweils ">Send-Receive-Correlation"<, ">Unique-Send-Receive-Correlation"< und ">Possible-Send-Receive-Correlations"<. Außerdem betrachten wir nur eine konkrete GA $A$ als Lösung für SRC und uSRC, nicht das bloße Erkennen der Existenz einer solchen.
%Zur besseren Lesbarkeit ist es sinnvoll, das Problem der erste Fragestellung ">Send-Receive-Correlation"< zu nennen und im folgenden mit SRC abzukürzen. Die beiden anderen Probleme werden dementsprechend als ">Unique-Send-Receive-Correlation"< (uSRC) und ">Possible-Send-Receive-Correlations"< (pSRC)\footnote{
Bei all diesen Problemen behandeln wir den Spezialfall, dass gleiche Pakete nur von demselben Sender stammen können. Für den allgemeinen Fall, dass jeder Knoten Pakete jeden Typs versenden kann, verwenden wir die Bezeichnung SRC*, uSRC* und pSRC*.

pSRC und pSRC* wurden erstmalig in \cite{WhoSaidThat} untersucht, allerdings wurden die Probleme dort noch als SRC bezeichnet,  während in dieser Arbeit die Bezeichnung SRC für den einfachsten Fall der Suche nach %Prüfung auf die Existenz 
einer konsistenten GA reserviert wurde.

Im nächsten Kapitel wird %nun 
für diese Fragen bewiesen, dass sie NP-vollständig sind. Anschließend wird eine schnelle Heuristik sowie ein langsamer, exakter Algorithmus zur Beantwortung der Fragen vorgestellt.


\chapter{Komplexität}
\label{chap:complexity}
%\section{Verwandtes Optimierungsproblem}
%Folgendes verwandtes Problem ist NP-vollständig:\\
%Gilt für alle Logs $L_i$ entweder $|L_i| = n$ und $L_i \subseteq S$ oder $L_i \subseteq R$, was ist die minimale Zahl von Sendern, bei denen es noch möglich ist, jedem Empfangsereignis ein Sendeereignis zuzuweisen?
%
%Die Eingabe ist wesentlich einfacher als im allgemeinen Fall des in dieser Arbeit behandelten Problems. Jedes Log enthält dieselbe Anzahl von Elementen und es gibt keine gemischten Sender- und Empfängerlogs, sondern jedes Log ist auf eine Sorte von Ereignissen beschränkt. \\
%Dafür handelt es sich um ein Optimierungsproblem, welche stets zu den kompliziertesten Problemen gehören.
%
%Die NP-Vollständigkeit davon lässt sich folgendermaßen  zeigen: Sei $M$ eine Matrix $M \in F_2^{m\times n}$ und $k \geq 1$.\\
%Es seien nun die Logs folgendermaßen definiert: Es gebe genau $m$ Sendelogs $L$ der Länge $n$ mit \[L_{ij} = \begin{cases}
%I_j & \text{für } M_{ij}=1\\
%O_j & \text{für } M_{ij}=0
%\end{cases}\]
%
%Setze das Empfängerlog \[L_{m+1,j} = \begin{cases}
%I_{j/k} & j  = 0 \mod k \\
%O_{\lceil j / k \rceil} & \text{sonst}
%\end{cases}\]
%%Setze die restlichen $k-1$ Logs $L_i$ mit $m+1 < i \leq m+k$ und $n(k-1)$-Elementen folgendermaßen: $L_{ij} = O_{\lceil j/(k-1) \rceil}$\\
%Für $k=3$ wäre das z.B.: $O_1, O_1, I_1, O_2, O_2, I_2, O_3, O_3, I_3, O_4, O_4, I_4 \ldots$
%
%%Desweiteren gebe es $k$ Empfängerlogs $L$ mit:
%%\[L_{ij} = \begin{cases}
%%I_j  & \text{für } i = 1\\
%%O_j  & \text{sonst}
%%\end{cases}\]
%
%$I_j, O_j$ mit $1 \leq j \leq n$ sind jeweils $n$ unterschiedliche Ereignistypen.
%
%Betrachten wir nun folgende Einschränkung des oben genannten Problems: Ist die Zahl der minimal benötigten Sendelogs exakt $k$ oder größer $k$?\\
%(kleiner $k$ ist offensichtlich niemals möglich)
%
%Leider ist die hier benutzte Definition einer gültigen Lösung eng mit dem Algorithmus zum Lösen eines Spezialfalles des allgemeinen Sende-Empfänger-Problems verknüpft, so dass sie nicht anwendbar ist, wenn sich gleichartige Sendeereignisse in unterschiedlichen Logs befinden sollten.\\
%Wir benutzen daher in diesem Abschnitt alternativ folgende intuitive Definition:\\
%Jedem Empfangsereignis muss ein Sendeereignis zugeordnet sein, keinem Sendeereignis dürfen in einem Log mehrere Empfangsereignisse zugeordnet sein, und gilt für zwei Empfangsereignisse $q,r$ in ihrem Log $q < r$, so muss auch für die Empfangsereignisse $S(q) < S(r)$ gelten.
%
%Angenommen man besitzt eine  Lösung des Sender-Empfänger-Problems die auf $k$ Sendelogs beschränkt ist. O.B.d.A. Seien dies die Logs $L_1 \ldots L_k$.\\
%Offensichtlich gibt es dann für jedes $j$ mit $1 \leq j \leq n$ ein Log $i$ mit $L_{ij} = I_j$, da jedes $I_j$-Ereignis einmal empfangen wurde, und somit auch gesendet werden sein muss.\\
%Desweiteren wird jedes $O_j$-Ereignis von jedem Sender genau einmal gesendet. Das heißt, das von jedem Sender der Empfänger maximal ein $O_j$-Ereignis empfangen haben kann. Da offensichtlich $k-1$ solche Ereignisse empfangen wurde, gibt es $k-1$-Sender, also $k-1$ paarweise unterschiedliche $i$ mit $L_{ij} = O_j$.\\
%Da es genau $k$-Sender in der gültigen Lösung gibt, heißt, dass das für jedes $j$ gilt $|\{i | L_{ij} = I_j\}| = 1$ und $|\{i | L_{ij} = O_j\}| = k-1$.\\
%Nach der Definition der Sender gilt $|\{i | M_{ij} = 1\}| = 1$ und $|\{i | M_{ij} = 0\}| = k-1$, für $1 \leq i \leq k$ (es sei nochmals an die O.B.d.A-Annahme erinnert).\\
%Daraus folgt, dass es eine Auswahl von $k$-Zeilen gibt, so dass in jeder Spalte genau eine $1$ vorhanden ist.
%
%Jetzt betrachten wir die Umkehrung:
%
%Angenommen es existiert eine Auswahl von $k$ Zeilen, so dass in jeder Spalte genau eine $1$ existiert. O.B.d.A. Seien dies wieder die Zeilen $i$ mit $1 \leq i \leq k$.\\
%Daraus folgt entsprechend $|\{i | M_{ij} = 1\}| = 1$ und $|\{i | M_{ij} = 0\}| = k-1$ und entgegen gesetzt zur obigen Richtung dann $|\{i | L_{ij} = I_j\}| = 1$ und $|\{i | L_{ij} = O_j\}| = k-1$.\\
%Für alle $j$ gibt es also $k-1$ Sendeereignisse vom Typ $O_j$ und ein Sendeereignis vom Typ $I_j$. Dies ist genau die Anzahl der Sendeereignisse, somit kann man jedem Empfangsereignis eineindeutig ein Sendeereignis zuordnen.\\
%Damit sind die ersten beiden intuitiven Bedingungen für eine sinnvolle Lösung erfüllt.\\
%Offenbar gilt für alle $i < j$, dass $T_i < U_j$ für $T,U \in \{O, I\}$ ist, und zwar in allen Logs. Also ist es trivial eine globale Anordnung zu finden, bei der auch die dritte Bedingung erfüllt ist.\\
%Also existiert eine sinnvolle Lösung für diese Form des Sender-Empfänger-Problems.
%
%
%Daraus folgt, dass das Lösen des oben genannten, zum Sende-Empfänger-Problem ähnlichen Problems, äquivalent zum Lösen des Mengenüberdeckungsproblems ist.\\
%Aber dies ist bekanntlich NP-vollständig \cite{CoverKnuths}, und somit ist es das hier skizzierte Problem ebenfalls NP-vollständig.
%
%

%\section{Beliebige Sender (SRC*)}
%In diesem Abschnitt wird das Problem in seiner allgemeinsten Form betrachtet, bei dem jeder Knoten Nachrichten von jedem Typ versenden kann.
%Ein bisher unveröffentlichter Beweis von Prof. Wanke zeigt, dass sich 3-SET auf dieses Problem reduzieren lässt:
%
\section{Eindeutige Empfänger und keine Senderambivalenz (uSRC)}
\label{section:uniqueReceiver}
\newcommand{\LTA}{\blacktriangleleft}
\newcommand{\LTB}{\blacktriangle}
\newcommand{\LTC}{\blacktriangleright}



In diesem Abschnitt wird das  %die im vorherigen Abschnitt gemäß dem Beweis von Prof. Wanke dargestellte Reduktion von das  
als 3-Exactcover (X3C) bezeichnete Problem, eine exakte Mengenüberdeckung zu ermitteln, auf das Finden einer konsistenten und eindeutigen GA reduziert. % so abgeändert, dass sie auch in dem Spezialfall funktioniert, dass %nur identische Sender 
%Pakete gleichen Typs nur von einem einzigen Sender versandt werden dürfen. \cite{Wanke}
%
%Computers and intractability: a guide to the theory of NP-completeness?
%by Michael R. Garey, David S. Johnson
X3C ist als NP-vollständig bekannt und lautet folgendermaßen \cite{X3C}:

Sei eine Menge $M = \{1, \ldots, m_T\}$ mit $m_T =3q$ und $q\in \mathbb{N}$  sowie eine Familie von Untermengen $\{M_i\}_{1\leq i\leq n_L} $  mit $M_i \subseteq M$   und $|M_j| = 3$ gegeben\\
Existieren $\{T_i\} \subseteq \{M_i\}$, so dass $T_i\cap T_j = \emptyset$ für $i\neq j$ und $\bigcup_i T_i = %\bigcup_j M_j = 
M$?

Um dieses X3C-Problem nun auf uSRC zu reduzieren, müssen für gegebene Mengen $M_j$ Logs $L_j$ so konstruiert werden, dass jede zu ihnen konsistente und eindeutige GA zu einer Lösung von X3C umgewandelt werden kann. 
Die Konstruktion der Logs für uSRC erfolgt dabei ähnlich  zu der in \cite{Wanke} beschriebenen Reduktion von X3C auf SRC*. Der einzige Unterschied ist dabei, dass hier Empfangs- und Sendeereignisse im Vergleich zu denen in \cite{Wanke} vertauscht sind  und eben uSRC anstatt von SRC* betrachtet wird. 
%Prinzipiell werden dazu einfach , wodurch nur noch ein Log  Sendeereignisse enthält. %Außerdem wird an die gesuchte GA die Anforderung gestellt, dass sie eindeutig sein muss. Danach muss nur noch bewiesen werden, dass die Reduktion tatsächlich weiterhin funktioniert.


%Zuerst müssen $n_L+1$ Logs $L_0, \ldots, L_{n_L}$ definiert werden:

Bevor wir die Logs konstruieren können, müssen wir die Menge der möglichen Ereignistypen definieren:  Es sei $\packetTypSet = M \cup \{X\} \subset \mathbb{N}$, wobei $X$  einen Ereignistyp bezeichnet, der nach der üblichen Ordnung über $\mathbb{N}$ größer ist als alle anderen in $M$ (z.B.: $X=m_T+1$).

Zudem benötigen wir eine Funktion $C: M \rightarrow \mathbb{N}$, die für jedes Element aus $M$ angibt,  in wie vielen Mengen  $M_i$ es enthalten ist, also $C(k) = |\{M_j | k \in M_j\}|$.


%Wir nehmen $M \cup \{X\}$ als Menge der Ereignistypen, so dass $P(e) \in M \cup \{X\}$ für alle Ereignisse $e$ gilt.

Damit können nun $n_L$ Empfangslogs $L_1, \ldots, L_{n_L}$ folgendermaßen definiert werden: Für jede Menge $M_i$ des X3C-Problems mit $M_i = \{\alpha,\beta,\gamma\}$ und $\alpha < \beta < \gamma$ sei nun \[L_i = \{a,b,c,x\}\] ein Log mit vier Empfangsereignissen für die gilt $P(a) = \alpha$, $P(b) = \beta$, $P(c) = \gamma$, $P(x) = X$ und $a \prec_i b \prec_i c \prec_i x$.
%Dazu führen wir für jedes $S_j$ ein Log $L_j$ mit vier Empfangsereignissen ein, die folgenden Typ haben: $P(L_j) = (a, b, c, X)$, wobei $a,b,c \in S_j$ mit $a < b < c$ die Elemente von $S$ darstellen.


Als nächstes wird das Senderlog $L_0$ definiert, welches für jedes der in den 
%Wie man sieht, repräsentiert $L_0$ also eine Sendeknoten, der für jedes der von den 
anderen $n_L$ Logs %$L_1, \ldots, L_{n_L}$ 
aufgezeichnete Empfangsereignis genau ein passendes Sendeereignis besitzt.
Dieses Log $L_0$ besteht aus vier Teilen, die durch die Symbole $\LTA$, $\LTB$ und $\LTC$ voneinander getrennt werden:

\[L_0 = (L_{0,\text{Teil 1}},\LTA,L_{0,\text{Teil 2}},\LTB,L_{0,\text{Teil 3}},\LTC,L_{0,\text{Teil 4}})\]

 Der erste Teil vor $\LTA$ enthält von jedem Typ aus $M$ genau ein Sendeereignis und entspricht der Menge, die von der X3C-Lösung überdeckt werden soll. Schreibt man diesen Teil als Tupel von Ereignistypen in einer festen Reihenfolge, so ergibt sich:
 \[P(L_{0, \text{Teil 1}}) = (1, 2, 3, \ldots, m_T)\] 

Da jede Menge $M_i$ genau drei Elemente enthält und die Mengen einer Lösung untereinander disjunkt sein müssen, kennt man die Zahl der an einer Lösung beteiligten Mengen: $\frac{m_T}{3}$. % ($m_T$ muss ein Vielfaches von 3 sein, da es sonst keine Lösung gäbe) 
Im zweiten Teil, zwischen $\LTA$ und $\LTB$, kann also für jede dieser Mengen ein $X$ gesendet werden, um zu garantieren, dass in jedem Log jeweils allen Ereignissen nur Sendeereignisse vor oder nur nach $\LTB$ zugewiesen werden:
 \[P(L_{0, \text{Teil 2}}) = (X, X, \ldots, X) \text{ mit } |L_{0, \text{Teil 2}}| = \frac{m_T}{3}\] 
 
Der dritte Teil, zwischen $\LTB$ und $ \LTC $, enthält dann einfach genügend Sendeereignisse von jedem Typ, dass für jedes Empfangsereignis mit einem Typ aus $M$ 
tatsächlich ein Sendeereignis existiert:
\newcommand{\repeatedinlog}[1]{\underbrace{#1, #1, \ldots, #1}\limits_{C(#1)-1\text{-mal}}}
 \[P(L_{0, \text{Teil 3}}) = (\repeatedinlog{1},\quad \repeatedinlog{2}, \quad\repeatedinlog{3},\quad\ldots \quad\repeatedinlog{m_T})\] 
 
Der vierte Teil, nach $\LTC$, besteht  aus den noch fehlenden Sendeereignisse vom Typ $X$:
 \[P(L_{0, \text{Teil 4}}) = (X, X, \ldots, X) \text{ mit } |L_{0, \text{Teil 2}}| = n_L - \frac{m_T}{3}\] 
 %Die Sendeereignisse $\LTA$, $\LTB$, $\LTC$ dienen nur zur Vereinfachung der Notation, da man dadurch Bereiche im Log angeben kann, beispielsweise alle ">Ereignisse zwischen $\LTA$ und $\LTB$.\\
%Da für diese Ereignisse keine Empfangsereignisse mit passendem Typ existieren, kann man sie einfach ignorieren und jede Lösung zu $L_0$ ist auch eine zu $L'_0 = L_0 \setminus \{\LTA, \LTB, \LTC\}$

Alles zusammen ergibt:

\newcommand{\repeatedlog}[2]{ $ #1 $ & $ #1 $ & $ \ldots $ &  $#1$ \\[-0.6cm] \vspace{0.1cm}&\multicolumn{4}{c}{$\underbrace{\hspace*{5cm} }\limits_{#2\text{-mal}}$}}
\begin{tabular}{rcccccc}
$P(L_0) = ($ & $1,$ &$2,$ &$\ldots,$ &$m_T-1,$ &$m_T, $	\\
&&&&&&$\LTA$\\
&\repeatedlog{X}{\frac{m_T}{3}}\\
&&&&&&$\LTB$\\&\repeatedlog{1}{C(1)-1}\\
&\repeatedlog{2}{C(2)-1}\\
&\multicolumn{5}{c}{$\vdots$}\\
&\repeatedlog{m_T-1}{C(m_T-1)-1}\\
&\repeatedlog{m_T}{C(m_T)-1}\\
&&&&&&$\LTC$\\
&\repeatedlog{X}{n_L-\frac{m_T}{3}}\\
\end{tabular}

%Sei $L'_i = \{ r \in L_i | P(r) \neq X \}$

%Wir verlangen nun, dass bei einer Lösung des Problems, jeder gesendete Nachricht genau einmal empfangen werden kann. Jede Zuordnung lässt sich also durch ein Tupel $(s, r)$ von einem Sendeereignis $s$ und einem Empfangsereignis $r$ darstellen.\\
%Dann kann man abermals zeigen, dass sich 3-SET auf dieses Problem reduzieren lässt.

%Ersetzt man nämlich in der vorherigen 3-SET-Reduktion von Prof. Wanke alle Sende- durch Empfangsereignisse und umgekehrt, so gilt noch immer, dass eine gültige Lösung genau dann existiert, wenn eine Lösung für das 3-SET-Problem existiert:

%\[r_1, r_2 \in R: (A(r_1) = A(r_2) \Rightarrow r_1 = r_2)\]

Nach dieser Definition erkennt man leicht, dass jede konsistente Lösung dieselbe GTO $\prec$ haben muss. Offensichtlich ist $S = L_0$ und bei  jeder konsistenten Lösung gilt für alle $e_1, e_2 \in L_0$ mit $e_1 \prec_0 e_2$, dass $A(e_1) \prec A(e_2)$ ist, also $e_1 \prec e_2$, da $e_1, e_2 \in L_0 = S$ sind. Da $\prec \subseteq S \times S$ ist, ist $\prec$ dadurch vollständig definiert und es gilt $\prec = \prec_0$.

Nun ist zu zeigen, dass das Finden einer zu diesen Logs konsistenten und eindeutigen GA  äquivalent zum Lösen der gegebenen Instanz von X3C ist.
\begin{lem}
	\label{lem:match=>3set}
		Existiert eine Lösung für uSRC, so existiert eine Lösung für X3C. %eindeutige, konsistente GA $A$, so existiert eine Lösung des 3-Exactcoverproblems
\end{lem}
\begin{proof}
	Dies folgt im wesentlichen daraus, dass es durch die Konstruktion von $L_0$ kein Log geben kann, dessen Ereignissen sowohl Sendeereignisse vor $\LTB$ als auch nach $\LTB$ zugeordnet sind. %TODO: wir benutzen diese um zwiscehen lösung und nichtlsunge zu eunterscheiden...
	
	Da zudem durch die geforderte Eindeutigkeit und die  beschränkte Zahl der Sendeereignisse jedes Sendeereignis tatsächlich empfangen werden muss, gibt es eine Menge von Logs, die nur Ereignisse vor $\LTB$ empfangen und die zugleich auch für sämtliche Sendeereignisse vor $\LTB$ ein entsprechendes Empfangsereignis besitzen. Das heißt also, dass es eine Bijektion zwischen ihren Empfangs- und den Sendeereignissen vor $\LTB$ gibt. Damit bilden die Mengen $M_i$, auf denen die entsprechenden Logs basieren, eine Lösung für X3C.
	
	Die mathematischen Details finden sich im Anhang unter \ref{proof:match=>3set}.
\end{proof}
Um die Äquivalenz der Probleme zu zeigen, muss das obige Lemma nun auch noch in der Gegenrichtung formuliert werden. Desweiteren werden einige Details der gesuchten GA spezifiziert, die in späteren Lemmas benötigt werden:

\begin{lem}
	\label{lem:match<=3set}
	Existiert eine Lösung für X3C, so existiert eine Lösung für uSRC.% 3-Exactcoverproblems, so existiert eine eindeutige und konsistente GA $A$
	
	Zudem gibt es zwei Indexmengen $I$ und $J$ mit $I \cap J = \emptyset$ und $I \cup J = \{1, \ldots, n_L\}$, so dass für alle $r \in R_i =  L_i$ mit $i\in I$ gilt $A(r) \prec \LTB$ und für alle $r \in R_j = L_j$ mit $j \in J$ gilt $\LTB \prec A(r)$.
	
	%Weiterhin gilt $A(q) \prec A(r)$ für $q \in L_i, r \in L_{i'}$ mit $P(q) = P(r)$ und $i,i' \in I$ und $i < i'$, sowie $A(q) \prec A(r)$ für $q \in L_j, r \in L_{j'}$ mit $P(q) = P(r)$ und $j,j' \in J$ und $j < j'$. 
	Außerdem sind die Ereignisse innerhalb dieser Mengen von Logs nach Typ und jeweiliger Lognummer sortiert, das heißt, ist $k,k' \in I$ mit $k < k'$ oder $k,k' \in J$ mit $k < k'$, so gilt für alle $q \in L_k, r \in L_{k'}$ mit $P(q) = P(r)$, dass $A(q) \prec A(r)$ ist.
\end{lem}
\begin{proof}
	Dieser Beweis erfolgt im Grunde umgekehrt zum vorherigen Beweis. Da die Mengen der Lösung des Coverproblems von jedem Typ genau ein Element enthalten, kann man jedem Empfangsereignis aus den ihnen zugeordneten Logs eindeutig ein Sendeereignis vor $\LTB$ zuweisen. Allen restlichen Empfangsereignissen kann man dann Sendeereignisse aus $L_0$ nach $\LTB$ zuordnen. 
	
	Wieder finden sich die Details im Anhang \ref{proof:match<=3set}.
\end{proof}

Damit ist gezeigt, dass sich X3C auf das Problem des Findens einer eindeutigen, konsistenten GA und GTO reduzieren lässt und da X3C bekanntlich NP-vollständig ist \cite{X3C}, muss auch unser Problem zumindest NP-schwer sein.

Da sich auch in Polynomialzeit überprüfen lässt, ob eine GA $A$ konsistent und eindeutig ist, indem man mit topologischem Sortieren (\cite{TopSort}) eine dazugehörige GTO berechnet und die entsprechenden im Kapitel \ref{chap:problem} angegebenen Bedingungen überprüft, liegt uSRC in NP (\cite{Cook}). 

Damit ist gezeigt, dass uSRC NP-vollständig ist.


\section{Keine Senderambivalenz (SRC)}
\label{section:uniqueSender}
Im vorherigen Abschnitt wurde bewiesen, dass das Problem, eine sowohl konsistente wie auch eindeutige GA zu finden, NP-vollständig ist. %, selbst wenn man sich auf den Spezialfall beschränkt, dass sich jeder Ereignistyp eindeutig einem Sendeknoten zuordnen lässt.
Nun stellt sich natürlich die Frage, ob das Finden einer GA, welche nur konsistent und nicht eindeutig zu sein braucht, nicht doch in Polynomialzeit möglich ist. 

In diesem Abschnitt wird  nun uSRC (in der Eingabe beschränkt auf die Logs, welche im obigen Beweis bei der Reduktion von X3C auf uSRC entstehen) wiederum auf SRC reduziert. Dazu werden die Logs so modifiziert, dass jede zu ihnen konsistente GA auch eine eindeutige sein muss. Dadurch gibt es für diese Eingabe keinen Unterschied zwischen einem Algorithmus, der nur eine konsistente GA sucht, und einem Algorithmus, der eine konsistente und zudem eindeutige GA sucht.%wird %das Finden einer konsistenten GA äquivalent zum Finden einer konsistenten und eindeutigen GA.


Wir betrachten dazu folgendes Konstrukt:

\begin{tabular}{cccc}
A&b&$\square$&A\\
B&a&$\boxdot$&B\\
\end{tabular}

$\square$ und $\boxdot$ stehen dabei für eine beliebige Folge von Ereignissen, welche weder A noch B enthalten

Es existieren nun genau zwei Möglichkeiten dem empfangenen a ein Sendeereignis zuzuordnen:

\begin{tabular}{ccccc}
 &A&b        &$\square$&A \\
 &$\updownarrow$\\
B&a&$\boxdot$&B        &  \\
\end{tabular}
\hspace{1cm}\vline\hspace{1cm}
\begin{tabular}{cccccc}
A&b&$\square$&A\\
 & &         &$\updownarrow$\\
  & &  B      &a&$\boxdot$&B\\
\end{tabular}

Damit bleibt für das freie b jeweils  nur exakt eine Möglichkeit der Zuordnung übrig:

\begin{tabular}{cccccc}
	&A &         &b        &$\square$&A \\
	&  $\updownarrow$ & &$\updownarrow $\\
	B&a&$\boxdot$&B        &  \\
\end{tabular}
\hspace{1cm}\vline\hspace{1cm}
\begin{tabular}{cccccc}
	A& b&$\square$&A\\
	 &   $\updownarrow $      & &$\updownarrow$\\
	 &  B &     &a&$\boxdot$&B\\
\end{tabular}

Das bedeutet, dass $\square$ und $\boxdot$ niemals gleichzeitig geschehen können.

Sind $\square$ und $\boxdot$ einzelne Ereignisse gilt somit  $A(\square) \neq A(\boxdot)$.

Um dieses Konstrukt anwenden zu können, sei noch einmal an die Definition der Logs im vorherigen Beweis erinnert: %Dieses Konstrukt lässt sich nun dazu benutzen, um zu zeigen, dass sich das Finden einer konsistenten, eindeutigen Lösung auf das Finden einer konsistenten Lösung reduzieren lässt.%Problem, die Existenz einer konsistenten, eindeutigen Lösung zu erkennen, auf das einer Erkennen der Existenz einer konsistenten Lösung reduzieren lässt.

Im vorherigen Abschnitt wurden die Logs $L_i$ folgendermaßen definiert: Für jede Menge $M_i$ des X3C-Problems mit $M_i=\{\alpha,\beta,\gamma\}$ und $\alpha < \beta < \gamma$ sei $L_i = \{a,b,c,x\}$ ein Log mit vier Empfangsereignissen für die gilt $P(a) = \alpha$, $P(b) = \beta$, $P(c) = \gamma$, $P(x) = X$ und $a \prec_i b \prec_i c \prec_i x$.

Damit jede konsistente GA auch eine eindeutige GA ist, %, die Ereignissen aus unterschiedlichen Logs dieselben Sendeereignisse zuweisen, 
umgeben wir nun jedes Paar von Empfangsereignissen desselben Typs in unterschiedlichen Logs mit dem zuvor veranschaulichten Konstrukt. Dabei müssen die Sendeereignisse jeweils am Anfang und Ende des Logs zusätzlich wiederholt werden, damit die Anwendung des Konstrukt um ein Paar von Ereignissen keine Zuordnungen zu anderen Ereignissen %innerhalb dieser Logs 
ausschließt. Zur besseren Lesbarkeit, führen wir diese Umformung schrittweise durch und beginnen mit Typ $\alpha$: %Jedes dieser Empfangsereignisse sei nun mit dem zuvor definierten Konstrukt umgeben, was zu dieser neuen Definition des Logs führt:
\[^{-3}L'_i = (\textbf{A}^1_{i\_}, \textbf{A}^2_{i\_}, \textbf{a}_{\_i}, a, \textbf{A}^3_{i\_}, b, c, x, \textbf{A}^4_{i\_})\]


Dabei steht $\textbf{A}^m_{i\_}$ für eine  Menge  von Sendeereignissen $\textbf{A}^m_{i\_} =  \{A^m_{ij} | i \neq j \wedge \exists a\in R_j: P(a) = \alpha\}$, die für jedes Log $L_j$, welches ein Empfangsereignis vom Typ $\alpha$ enthält, ein passendes Sendeereignis $A^m_{ij}$ besitzt. Diese Ereignisse seien im Log $L'_i$ aufsteigend sortiert gespeichert, also $A^m_{ij} \prec_i A^m_{ik} \Leftrightarrow j < k$.\\
Entsprechend bezeichnet $\textbf{a}_{\_i} = \{a_{ji} | i \neq j \wedge \exists a \in R_j: P(a) = \alpha\}$ eine Menge von Empfangsereignissen. Auch hier seien diese Ereignisse in $L'_i$ aufsteigend sortiert, also $a_{ji} \prec_i a_{ki} \Leftrightarrow j < k$.\\
Für alle $m$ sei $P(A^m_{ij}) = P(a_{ij})$ und $P(A^m_{ij}) \neq P(a_{kl})$ für $i \neq k$ oder $j \neq l$ (Intuitiv bestimmt der erste Index also das sendende Log und der zweite Index das empfangende Log).\\
Der Index $m$ zählt die Sendeereignisse durch und die zusätzlichen Ereignisse $A^1_{ij}$ und $A^4_{ij}$, welche im oben vorgestellten Konstrukt noch nicht enthalten waren, benötigt man wie schon erwähnt, damit sich die Konstrukte um unterschiedliche Ereignisse %der unterschiedlichen Logs 
nicht gegenseitig blockieren.
%Dabei sei $P(A^m_{ij}) = P(a_{kl}) \Leftrightarrow i = k \wedge j = l$ für alle $m$. (intuitiv bestimmt der erste Index also das sendende Log und der zweite Index das empfangende Log.)\\

Fügt man mit entsprechend definierten Mengen $\text{B}^m_{i\_}$ und $\text{b}_{\_i}$ das Konstrukt als nächstes um das Ereignis $b$, so ergibt sich:
\[^{-2}L'_i = (\textbf{A}^1_{i\_}, \textbf{B}^1_{i\_}, \textbf{A}^2_{i\_}, \textbf{a}_{\_i}, a, \textbf{A}^3_{i\_}, \textbf{B}^2_{i\_}, \textbf{b}_{\_i}, b, \textbf{B}^3_{i\_},c, x, \textbf{A}^4_{i\_}, \textbf{B}^4_{i\_})\]

Dies wiederholt man dann mit Ereignis $c$:
\[^{-1}L'_i = (\textbf{A}^1_{i\_}, \textbf{B}^1_{i\_}, \textbf{C}^1_{i\_}, \textbf{A}^2_{i\_}, \textbf{a}_{\_i}, a, \textbf{A}^3_{i\_}, \textbf{B}^2_{i\_}, \textbf{b}_{\_i}, b, \textbf{B}^3_{i\_}, \textbf{C}^2_{i\_}, \textbf{c}_{\_i},c, \textbf{C}^3_{i\_}, x, \textbf{A}^4_{i\_}, \textbf{B}^4_{i\_}, \textbf{C}^4_{i\_}) \]

Und schließlich mit Ereignis $x$:

$L'_i = (\textbf{A}^1_{i\_}, \textbf{B}^1_{i\_}, \textbf{C}^1_{i\_}, \textbf{X}^1_{i\_}, \textbf{A}^2_{i\_}, \textbf{a}_{\_i}, a, \textbf{A}^3_{i\_}, \textbf{B}^2_{i\_}, \textbf{b}_{\_i}, b, \textbf{B}^3_{i\_},$\\[0.4cm]
$\hspace*{6.5cm} \textbf{C}^2_{i\_}, \textbf{c}_{\_i},c, \textbf{C}^3_{i\_}, \textbf{X}^2_{i\_}, \textbf{x}_{\_i}, x, \textbf{X}^3_{\_i}, \textbf{A}^4_{i\_}, \textbf{B}^4_{i\_}, \textbf{C}^4_{i\_}, \textbf{X}^4_{i\_}) $

Für die nachfolgenden Beweise wird zudem eine Funktion $B$ benötigt, die jedem Ereignis einen Basistyp zuweist, mit $B(A^m_{ij}) = B(a_{ij}) = B(a) = \alpha$ für alle $i,j,m$.

Das Sendelog $L'_0 = L_0$ bleibe unverändert.

Jedes Ereignis der $4n_L$ Empfangsereignisse von $L$ wird dabei von maximal $5n_L$ Ereignismengen umgeben, die jeweils maximal $n_L$ Ereignisse enthalten und bei denen sich für jedes potentiell enthaltene Ereignis in konstanter Zeit (durch einem Lookup in der vierelementigen Menge $L_i$) bestimmen lässt, ob es tatsächlich zur Menge gehört. Damit lässt sich die gesamte Konstruktion trivial in $O(n_L^3)$ erzeugen, also in Polynomialzeit.

%Für Log i:
%$\bigodot E_{i,j} e_{j,i}   e    C E_{i,j} $\\
%j hat gleichen Typ
%$E_(i,j) \prec_i e_{j,i} \prec_i E_{i,j'} \prec_i e_{j', i}$ für $j < $


\begin{lem}
\label{lem:konsistent=eindeutig,eindeutig}
Jede konsistente Lösung von L' ist eindeutig.
\end{lem}
\begin{proof}
Dies folgt aus der genauen Untersuchung des oben angegebenen Konstrukts, welche sich im Anhang \ref{proof:konsisten=eindeutig,eindeutig} findet.
\end{proof}

Damit ist gezeigt, dass unser Ziel erreicht ist und das Finden einer eindeutigen, konsistenten und einer nur konsistenten GA für diese Logs äquivalent ist.

Allerdings ist noch nicht gesichert, dass die so modifizierten Logs weiterhin äquivalent zur gegebenen Instanz von X3C sind, was nun gezeigt wird:

\begin{lem}
\label{lem:konsistent=eindeutig,L'=>L!}
Ist $A$ eine zu $L'$ konsistente GA, so ist $A$ eingeschränkt auf $L$ eine konsistente GA zu $L$.
\end{lem}
\begin{proof}
Dies folgt im Grunde sofort dadurch, dass $L \subset L'$ ist.

Eine genauere Ausführung findet man im Anhang unter \ref{proof:konsistent=eindeutig,L'=>L!}.
\end{proof}

\begin{lem}
		\label{lem:konsistent=eindeutig,L=>L'!}
	Existiert eine eindeutige, konsistente Lösung zu $L$, so gibt es eine Lösung für $L'$.

\end{lem}
\begin{proof}
Sei $A, \prec$ eine solche Lösung zu $L$.

Wie im Lemma \ref{lem:match<=3set} werden die Logs wieder durch zwei Indexmenge $I$ und $J$ mit $I \cap J = \emptyset$ und $I \cup J = \{1, \ldots, n_L\}$ aufgeteilt, so dass für alle $r \in L_i$ mit $i\in I$ gilt $A(r) \prec \LTB$ und für alle $r \in L_j$ mit $j \in J$ gilt $\LTB \prec A(r)$.

Aus diesen Indexmengen entstehen jeweils zwei Familien von Logs: $L_I = \{L_i | i\in I\}$ und $L_J = \{L_j | j \in J\}$.

Außerdem gilt  $A(q) \prec A(r)$ für $K \in \{I, J\}$ und $k, k' \in K$ mit $k < k'$ und $q \in L_k, r \in L_{k'}$ mit $P(q) = P(r)$.
%$A(q) \prec A(r)$ für $q \in L_j, r \in L_{j'}$ mit $P(q) = P(r)$ und $j,j' \in J$ und $j < j'$. (dies ist möglich, da in jedem Log alle Empfangsereignisse unterschiedlichen Typen habe und alle Sendeereignisse vom selben Typ , welche nur für $I$ oder $J$ relevant sind, in einem Block direkt hinter einander auftreten)

%Außerdem sei wieder $x^i \in L_i$ mit $P(x^i) = X$ gegeben, sodass $\LTA \prec A(x^i) \prec \LTB$ für $i \in I$ gilt und $\LTC \prec A(x^j)$ für $j \in J$ gilt.

Nun wird eine neue GA $A'$ konstruiert, indem man für jedes Empfangsereignis aus $L$ die Zuordnung von $A$ übernimmt und für jedes neu hinzugekommene Empfangsereignis aus $L'\setminus L$ eines der vier möglichen neuen Sendeereignisse wählt. Intuitiv betrachtet geschehen alle Empfangsereignisse der Logs  $L_I$ vor denen von $L_J$, also nimmt man für die Empfangsereignisse von $L_I$ das frühestmögliche Sendeereignis in $L_J$ und umgekehrt für die Empfangsereignisse in $L_J$ das spätest mögliche in $L_I$. Innerhalb von $L_I$ und $L_J$ sind die Ereignisse nach ihren Typen und der Indexnummer des Logs sortiert, so dass man entsprechend dieser Sortierung jeweils das erste und letzte mögliche Sendeereignis (also das zweite und vorletzte im Sendelog, da das erste und letzte ja bereits zugeordnet sind) wählt.  \\
Konkret bedeutet das:

Für alle $s \in S'$ sei \[A'(s) = s\]
Für alle $e \in L$ sei \[A'(e) = A(e)\]
Für $i\in I$ und $e_{ki} \in L'\setminus L$ sei \[A'(e_{ki}) = \begin{cases}
  E^3_{ki}  & \text{falls } k < i \wedge k \in I\\
  E^1_{ki} & \text{falls } k\in J \vee (k > i \wedge k \in I )\\
 \end{cases} \] 
 Dabei bezeichnet $E^m_{ki} \in S_k$   ein Sendeereignis mit $P(E^m_{ki}) = P(e_{ki})$ an der entsprechenden, durch $m$ bestimmten Position im Log.
 
Für $j\in J$ sei \[A'(e_{kj}) = \begin{cases}
E^4_{kj} & \text{falls } k \in I\\
E^3_{kj} & \text{falls } k < j \wedge k \in J\\
E^2_{kj} & \text{falls } k > j \wedge k \in J
\end{cases}\]  

Es ist nun leicht zu sehen, dass $A'$ eine GA ist. Zu beweisen, dass $A'$ auch konsistent ist, ist etwas komplizierter und lässt sich zeigen, indem man eine Reihenfolge der Empfangsereignisse festlegt, bei denen die Ereignisse aus $L_I$ vor denen von $L_J$ geschehen und die restlichen Ereignisse nach ihrem Typ und der Nummer des sie enthaltenden Logs sortiert sind.

Die Details hierzu findet man im Anhang \ref{proof:konsistent=eindeutig,L=>L'!}.

Da die oben angegeben GA $A'$ also konsistent ist, stellt sie die gewünschte Lösung für die Logs $L'$ dar.
\end{proof}

%Im vorherigen Abschnitt wurde gezeigt, dass sich das Finden einer Lösung für X3C auf das Finden einer konsistenten, eindeutigen Lösung für die Logs $L$ reduzieren lässt.
Damit haben wir nun gesehen, dass sich aus den Logs $L$ des Beweis des vorherigen Abschnitts in Polynomialzeit  eine Menge von neuen Logs $L'$ konstruieren lässt, so dass das Finden einer beliebigen konsistenten Lösung für diese $L'$ äquivalent zum Finden einer eindeutigen Lösung für die Logs $L$ und damit zum Finden einer Lösung des X3C-Problems ist.
Damit wurde letzeres, NP-vollständige Problem auf das Finden einer konsistenten Lösung reduziert.

Da sich jede konsistente Lösung auch offenkundig in Polynomialzeit als konsistent verifizieren lässt, ist das Finden einer konsistenten Lösung in NP, und nach dem obigen Beweis sogar NP-vollständig.


%Z.z: Es gibt eine Lösung von L' wenn es eine Lösung von L gibt

%Offensichtlich existiert nur eine endliche Zahl von konsistenten GAs, da es sich bei einer GA um eine Funktion handelt, die jedem Element einer endlichen Menge ein Element einer anderen endlichen Menge zu ordnet.
%
%Induktion über die Zahl der möglichen, konsistenten GAs:
%
%Induktionsanfang: Es existiert keine konsistente GA:\\
%Erkennt ein Algorithmus, dass es keine konsistente GA gibt, so beweist er auch, dass keine konsistente, eindeutige GA existiert.
%
%Fall 1: Es existiert keine konsistente GA\\
%=> keine konsistente, eindeutige\\
%Fall 2: Es existiert keine konsistente, nicht eindeutige GA\\
%=> gefundene ist eindeutig\\
%Fall 3: Es existiert eine konsistente, nicht eindeutige GA $A$\\
%Es gibt somit $q \in L_i$, $r \in L_j$ mit $e_1\neq e_2$, $i\neq j$ und $A(e_1) = A(e_2)$\\
%($i\neq j$ folgt da für $a \prec_i b$ mit $a, b \in L_i$ gilt, $A(a) \prec A(b)$ und somit $A(a) \neq A(b)$)\\
%Wir definieren nun: \\
%\[L'_i(k) = \begin{cases}
%L_i(k) & falls k < q_i\\
%(A, s) & falls k = q_i\\
%(b, e) & falls k = q_i+1\\
%q_k & falls k = q_i+2\\
%(A, s) & falls k = q_i+3\\
%L_i(k-3) & falls k > q_i+3
%\end{cases}\]
%
%\[L'_j(k) = \begin{cases}
%L_j(k) & falls k < r_j\\
%(B, s) & falls k = r_j\\
%(a, e) & falls k = r_j+1\\
%q_k & falls k = r_j+2\\
%(B, s) & falls k = r_j+3\\
%L_j(k-3) & falls k > r_j+3
%\end{cases}\]
%
%Z.z: Jede konsistente, eindeutige Lösung von $L'$ ergibt eine konsistente, eindeutige Lösung von $L$
%
%Z.z: Jede konsistente, eindeutige Lösung von $L$ ergibt eine konsistente, eindeutige Lösung von $L'$
%
%Z.z: Es gibt weniger konsistente Lösungen von $L'$, als von $L$
%
%
%Z.z: Es handelt sich um eine Polynomialzeitreduktion\\
%Argumentation: Man macht dies für jedes Paar von Empfangsereignissen nur ein einziges Mal .\\
%Es gibt nur $n^2$ Paare von Empfangsereignissen von unterschiedlichen Typ (und die hinzugefügten gibt es nur einmal pro Typ)
%

% A bxA    A bxA
%BaxB        B axB
%  X X        X X 

%x  x   x  x
%x   x x   x
%XX XX XX XX



\section{Möglicher Sender im Fall ohne Senderambivalenz (pSRC)}
In den obigen Abschnitten wurden nur die neuen Probleme SRC und uSRC betrachtet, so dass die Untersuchung von pSRC noch aussteht. Es liegt jedoch nahe, dass es ebenfalls NP-vollständig ist.

%Dazu wird gezeigt, wie man, wenn man einen schnellen Algorithmus für pSRC % (also für das Finden der candidate sets aller möglichen Sendeereignisse) 
Um dies zu zeigen, wird nun ein Verfahren beschrieben, mit dem sich  in Polynomialzeit eine konsistente GA finden lässt, sofern man über einen schnellen Algorithmus für pSRC verfügt. Dabei nimmt der pSRC-Algorithmus die Rolle eines Orakels ein, welches zu jedem Empfangsereignis  eine Menge der möglichen Sendeereignisse berechnet.

Es lassen sich mit diesem Orakel drei Fälle unterscheiden: 

\begin{enumcases}
	\item Es gibt ein Empfangsereignis, für das kein mögliches Sendeereignis existiert.
	
	Dann existiert offensichtlich keine konsistente GA.
	\item Für jedes Empfangsereignis gibt es nur genau ein mögliches Sendeereignis.
	
Das heißt, für jedes Empfangsereignis $r$ existiert genau ein $s$, so dass es eine konsistente GA $A$ mit $A(r) = s$ gibt und dass es für $s' \neq s$ keine konsistente GA mit $A(r) = s'$ geben kann. Ist $A$ nun eine konsistente GA, so folgt, dass $A(r) = s$ für alle $r \in R$ und dem einzigen nach dem Orakel für $r$ möglichen Sendeereignis $s$. Da nun für jedes Empfangsereignis ein Sendeereignis gegeben ist, ist $A$ durch diese Zuordnung eindeutig bestimmt und man kann in Linearzeit (die für das Erkennen des Falles nötig ist) eine konsistente GA finden.

	\item Es gibt ein Empfangsereignis $r$, dem sich mehrere Sendeereignisse zuordnen lassen.
	
	Sei $s$ eines dieses Sendeereignisse. Dann gibt es eine konsistente GA $A$ mit $ A(r)=s $. Man kann nun in den Logs das Ereignis $ s $ durch drei Sendeereignisse $ X s Y $ ersetzten (bzw. es mit zwei umgeben) und zugleich $ r $ durch drei Empfangsereignisse $ x r y $ ersetzten. Dabei sei $P(X) = P(x)$, $P(Y)=P(y)$ und $P(X) \neq P(e) \neq P(Y)$ für alle anderen Ereignisse $e$. Damit gibt es jeweils nur genau ein mögliches Sendeereignis und es gilt $A(x) =X$ und $ A(y)=Y $ für jede GA. Aus den Konsistenzbedingungen $A(x) \prec A(r) \prec A(y)$ und $ X\prec s \prec Y $  mit $s' \prec X$ oder $Y \prec s'$ für alle $s' \neq s$ im selben Log wie $s$ folgt, dass es in den modifizierten Logs keine GA $A$ mit $A(r) \neq s$ geben kann. Damit hat man offensichtlich in Polynomialzeit die Zahl der Empfangsereignisse ohne eindeutige Zuordnung um mindestens eins reduziert. 
	
	Wiederholt man dies, bis für die modifizierten Logs Fall 1 oder Fall 2 eintritt (was maximal eine Wiederholung für jedes Empfangsereignis erfordert), so erhält man schließlich eine konsistente GA.  %Daraus folgt, dass es zwei konsistente GAs $A_1$ und $ A_2 $mit $A(
\end{enumcases}

Somit ist es möglich SRC in Polynomialzeit auf pSRC zu reduzieren.

Umgekehrt kann man überprüfen, ob eine Zuordnung zwischen einem Empfangs- $r$ und Sendeereignis $S$ möglich ist, indem man eine konsistente GA sucht, die diese Zuordnung enthält. Dazu ersetzt man einfach wie oben $S$ durch $XSY$ und $r$ durch $xry$, so dass es keine konsistente GA ohne diese Zuordnung gibt, und ruft dann einen  %kann man einen beliebigen, 
SRC-lösenden Algorithmus  als Orakel auf. %benutzen, nachdem man die beiden zu überprüfenden Ereignissen wie oben mit  Trick ein Sende- und Empfangsereignis mit zwei 
Da es nur $n^2$ mögliche Zuordnungen gibt, kann man also auch pSRC in Polynomialzeit auf SRC reduzieren. 

Da SRC wie im vorherigen Abschnitt gezeigt NP-vollständig ist, muss also auch pSRC NP-vollständig sein.



%Es ist aber leicht zu sehen, dass dieses Problem ebenfalls NP vollständig ist, wozu wir zuerst die Logs vereinfachen: Wir betrachten in diesem Kapitel bekanntlich den Spezialfall, dass gleiche Pakete nur von demselben Sender stammen, also $\exists l: \{s\in S| P(s) = t\} \subseteq L_l$ für alle $t$. Genauso können wir verlangen, dass gleiche Pakete nur von demselben Empfängerknoten empfangen werden dürfen, also $\exists l: \{r\in R| P(r) = t\} \subseteq L_l$ für alle $t$.



%Dazu bildet man neue Logs $L'$, indem man jedes Sendeereignis $S$ durch $2n_L$-Sendeereignisse $S_1 S_2 \ldots S_{2n_L}$ ersetzt und jedes Empfangsereignis $r \in R_i$ mit $P(r)=P(s)$ durch zwei Ereignisse $r_i r_{2{n_L}-i+1}$, wobei $P(S_j) = P(r_k) \Leftrightarrow j=k$ gelten solle. Damit kann offensichtlich jedes neue Sendeereignis nur von genau einem Knoten empfangen werden. %Da in keinem Log ein einzelnes Sendeereignis mehrmals empfangen werden darf, ist damit das SRC*-Problem auf uSRC* reduziert.\footnote{Inwiefern sich diese Verdopplung der Zahl der Empfangsereignisse und die ">Ver$n_L$fachung"< der Sendeereignisse auf die Laufzeit auswirkt, müsste genauer untersucht werden. Das einfache Ersetzten von $n$ durch $n_Ln$ in der O-Notation würde die Laufzeit mit dem Faktor $n_L^{n_L}$ multiplizieren, was schlechter ist als eine Modifikation von Solvable$_{L/R}$}

%Das man aus einem für die Logs $L$ konsistenten Paar einer GA $A$ und einer GTO $\prec$  eine neue GA $A'$ mit einer neuen GTO $\prec'$ erzeugten kann, ist trivial zu sehen. Dazu fügt man zur GTO für jedes zerlegte Sendeereignis $S$ die Ordnungsreihenfolge $S_1 \prec S_2 \prec \ldots \prec S_{2n_L}$ mit ihrer transitiven Hülle hinzu. Nimmt man dann für die zerlegten Empfangsereignisse das passende Sendeereignis, 

%Diese Konstruktion sorgt neben wie die Konstruktion des vorherigen Abschnitts dafür, dass jede konsistente GA auch eindeutig ist. Dabei handelt es sich aber nur um eine formale Eindeutigkeit, da jedes Sendeereignis in mehrere Ereignisse zerlegt wird, können mehrere Logs gleichzeitig Einzelereignisse weiterhin empfangen, die vom selben zerlegten Sendeereignis stammen.  


%wenn ein Ereigniss A zum candidate set vom Ereignis a gehört, heißt es ja, dass es eine gültige Lösung
%mit dieser Zuordnung gibt.
%Wenn dann jeder Ereignistyp von nur einem Log empfangen werden kann (OBdA nach der früheren Mail), dann
%kann man einfach A und a durch Ereignisse eines Typs ersetzen, der sonst nicht vorkommt und erhält Logs, bei
%denen die Zahl der nicht trivial/eindeutig zuordnungsbaren Empfangsereinigsse um eins verringert wurde und zu denen
%es noch immer eine gültige Lösung geben muss, in derselben Laufzeit, die der Algorithmus fürs Finden der candidate sets hat.
%Wiederholt man das jetzt n-mal (für jedes nicht eindeutig zuordbare Empfangsereignis), erhält man Logs bei denen jedes
%Empfangsereignis nur ein mögliches Sendeereignis hat und erhält somit eine gültige Lösung in O(n*F(n)), wenn F die Laufzeit
%des anderen Algorithmus ist. 

\chapter{Intervallbasierte Zuordnung und Heuristik}
\label{Heuristik}
In \cite{WhoSaidThat} wurde als Polynomialzeit-Algorithmus für das optimale Lösen von pSRC eine Heuristik vorgestellt, die für jedes Empfangsereignis ein Intervall von möglichen Sendeereignissen ermittelt, welche dem Ereignis zugeordnet werden können.

Nach den vorherigen Überlegungen ist aber klar, dass ein solches Verfahren diese Erwartungen nicht erfüllen kann (es sei denn, es gälte $P = NP$).

%Bevor wir die Heuristik selbst betrachten, wird gezeigt, dass schon die Annahme, d
In diesem Kapitel wird nun zuerst -- unabhängig vom eigentlichen Algorithmus -- bewiesen, dass schon die Annahme, dass jedem Empfangsereignis ein geschlossenes Intervall von Sendeereignissen zugewiesen werden kann, nicht erfüllt ist; dann wird gezeigt, dass die von der Heuristik gefundenen Intervalle im Allgemeinen nicht einmal minimal sind,  und  schließlich einige Spezialfälle vorgestellt, in denen sie es doch sind.

%Diese Arbeit zeigt nun zwei wesentliche Probleme mit einer intervallbasierten Heuristik auf:
%\begin{itemize}
%\item Die Annahme, dass die für ein Empfangsereignis in Frage kommenden Sendeereignisse ein Intervall und keine beliebige, ">löchrige"< Menge bilden, ist nicht erfüllt.
%\item Das von dem in \cite{WhoSaidThat} beschriebenen Algorithmus gefundene Intervall ist in vielen Fällen nicht minimal (obgleich diese Fälle in der Praxis scheinbar selten vorkommen.)
%\end{itemize}
%
%%Im folgenden werden die obigen Behauptungen bewiesen und einige Spezialfälle untersucht, in denen das Ergebnis der Heuristik trotzdem brauchbar ist.
%
%Wir zeigen nun die erste der obigen Behauptungen, welche allgemein für alle auf Intervallen basierenden Algorithmen gilt:
\section{Mangelhaftigkeit einer Intervallzuordnung}\label{sec:intervalproblem}
\begin{lem}
Die möglichen Sendeereignisse bilden nicht immer ein geschlossenes Intervall.
\end{lem}
\begin{proof}
	
	
	Dies wird mit einem Widerspruchsbeweis gezeigt, bei dem wir folgende Eingabe betrachten: %Dies erkennt man leicht an folgender Eingabe:
	
\begin{tabular}{cccccc}
	B & c & a & B &   & \\
	C & A & C & b & C & A
\end{tabular} 

Damit sind diese beiden Zuordnungen möglich:

\begin{figure}[h]
	\begin{minipage}{5cm}
		\begin{tabular}{cccccccc}
			B & c & a & & B \\
			& $\uparrow$ & $\uparrow$ && $\downarrow$ \\
			& C & A & C & b & C & A
		\end{tabular} 
	\end{minipage}
	\hspace{1cm}\vline\hspace{1cm}
	\begin{minipage}{5cm}
		\begin{tabular}{cccccccc}
			&   &   & B & c & a & B \\
			&   &   & $\downarrow$ & $\uparrow$ & $\uparrow$ & \\
			C & A & C & b & C & A
		\end{tabular} 
	\end{minipage}
\end{figure}

Das empfangene $c$ kann also sowohl dem ersten wie auch dem letzten gesendeten $C$ zugeordnet werden.
Also muss das Intervall der für $c$ möglichen Sendeereignisse %, welches nur durch sein Minimum und Maximum  charakterisiert ist, 
sämtliche $C$s enthalten. 
Würden die möglichen Sendeereignisse nun ein geschlossenes Intervall bilden, so gäbe  %Das heißt, dass 
es auch mit dem mittleren $c$ eine gültige Zuordnung. Aber es ist trivial zu zeigen, dass es eben keine solche Zuordnung gibt, %keine gültige Zuordnung  ergibt, 
indem man versucht ein Sendeereignis für das übrig gebliebene $a$ oder $b$ zu finden: %.%Versucht man dann aber ein Sendeereignis für das übrig gebliebene $a$ oder $b$ zu finden, erhält man:
\begin{figure}[h]
	\begin{minipage}[h]{6cm}
		\begin{tabular}{ccccccc}
			& B & c &  a  & B \\
			&   & $\uparrow$ &  ???? & $\downarrow$\\
			C & A & C &     & b & C & A
		\end{tabular} 
	\end{minipage}
	\hspace{1cm}\vline\hspace{1cm}
	\begin{minipage}[h]{6cm}
		\begin{tabular}{cccccccc}
			& B & c &   &   & a  & B \\
			&   & $\uparrow$ &  ???? && $\uparrow$ & \\
			C & A & C & b & C & A
		\end{tabular} 
	\end{minipage}
\end{figure}

Offensichtlich ist es nicht möglich, diesen beiden Empfangsereignissen gleichzeitig ein Sendeereignis zuzuordnen. Also ist das mittlere $C$ kein gültiges Sendeereignis für das empfangene $c$.
Jeder auf Intervallen basierende Algorithmus liefert also immer einige falsche Zuordnungen

	
\end{proof}


\section{Probleme der Heuristik}

Nach dem vorherigen Abschnitt wissen wir, dass der in \cite{WhoSaidThat} vorgestellte und dann in \cite{Marold} realisierte Algorithmus nicht garantieren kann, dass die von ihm gefundenen Sendeereignisse tatsächlich eine mögliche Zuordnung darstellen.
Trotzdem könnte es sein, dass das Verfahren in dem Sinne optimal wäre, dass der Algorithmus die bestmöglichen (also kleinsten) Intervalle findet, die noch alle möglichen Sendeereignisse umfassen. % es keine besseren Intervalle (also Intervalle, die weniger Sendeereignisse umfassen) gibt, als die vom Algorithmus gefundenen Intervalle.

Leider ist dies nicht der Fall, was durch ein einfaches Gegenbeispiel gezeigt werden kann. Aber um dieses Gegenbeispiel zu verstehen, muss man die Funktionsweise der Heuristik kennen, weswegen sie zuvor beschrieben wird. % dass es sich tatsächlich um ein Gegenbeispiel handelt, muss man zuerst den Algorithmus kennen. 
Dabei beginnen wir mit der verwendeten Datenstruktur, die exemplarisch an Hand der Ausgabe  erklärt wird, welche entsteht, wenn die Heuristik auf die Logs des vorherigen Abschnitts angewandt wird. %als Eingabe die Logs des vorherigen Abschnitts verwendet werden. %, wenn man sie auf die Logs des vorherigen Abschnitts anwendet, um an Hand dieser Ausgabe die verwendete  Datenstruktur
\footnote{Diese sind  nicht geeignet, um den Ablauf des Algorithmus zu beschreiben, da er bei dieser Eingabe sofort terminiert.}: %wir nun die von verwendete Datenstruktur, an Hand der Ausgabe: %indem wir das, an Hand der Logs aus dem vorherigen Abschnitt, zunächst einmal die verwendete Datenstruktur erläutert:
%Auch wenn die Funktionsweise der Heuristik noch nicht beschrieben wurde, kann man sich ihre Ausgabe, nach einem Aufruf mit den beiden Logs im obigen Beweis ansehen. Die Form der Visualisierung wurde leicht abgewandelt von \cite{Marold} übernommen:
%Man kann sich auch schon die Ausgabe der Heuristik ansehen,  auch wenn man ihre Funktionsweise noch nicht kennt:

%zu den Logs in obigen 
\setlength{\unitlength}{0.9pt}
\begin{picture}(460,144)(30,258)
	\definecolor{R153G107B107}{rgb}{0.6,0.41960785,0.41960785}
	\definecolor{R107G153B107}{rgb}{0.41960785,0.6,0.41960785}
	\definecolor{R107G107B153}{rgb}{0.41960785,0.41960785,0.6}
	\definecolor{R0G0B128}{rgb}{0.0,0.0,0.5019608}
	\definecolor{R0G0B179}{rgb}{0.0,0.0,0.7019608}
	\definecolor{R128G0B0}{rgb}{0.5019608,0.0,0.0}
	\definecolor{R179G0B0}{rgb}{0.7019608,0.0,0.0}
	\definecolor{R0G128B0}{rgb}{0.0,0.5019608,0.0}
	\definecolor{R0G179B0}{rgb}{0.0,0.7019608,0.0}
	\put(60,294){\color{R153G107B107}\linethickness{1.0pt}\vector(80,70){80}}
	\put(140,364){\color{R153G107B107}\linethickness{1.0pt}\vector(240,-70){240}}
	\put(140,294){\color{R107G153B107}\linethickness{1.0pt}\vector(80,70){80}}
	\put(220,364){\color{R107G153B107}\linethickness{1.0pt}\vector(240,-70){240}}
	\put(60,364){\color{R107G107B153}\linethickness{1.0pt}\vector(240,-70){240}}
	\put(300,294){\color{R107G107B153}\linethickness{1.0pt}\vector(0,70){70}}
	\put(50,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  B}}
	\put(37,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(37,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(67,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(67,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(60,385){\color{R0G0B179}\linethickness{2.0pt}\line(0,-18){18}}
	\put(30,388){\color{R0G0B179}\linethickness{2.0pt}\line(0,-24){24}}
	\put(30,388){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(30,364){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(90,388){\color{R0G0B179}\linethickness{2.0pt}\line(0,-24){24}}
	\put(90,388){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(90,364){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(130,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  c}}
	\put(117,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(117,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(147,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(147,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  4}}
	\put(140,385){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(110,388){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(110,388){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(110,364){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(170,388){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(170,388){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(170,364){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(210,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  a}}
	\put(197,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
	\put(197,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(227,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
	\put(227,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  5}}
	\put(220,385){\color{R0G179B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(190,388){\color{R0G179B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(190,388){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(190,364){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(250,388){\color{R0G179B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(250,388){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(250,364){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(290,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  B}}
	\put(277,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(277,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(307,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(307,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  5}}
	\put(300,385){\color{R0G0B179}\linethickness{2.0pt}\line(0,-18){18}}
	\put(270,388){\color{R0G0B179}\linethickness{2.0pt}\line(0,-24){24}}
	\put(270,388){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(270,364){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(330,388){\color{R0G0B179}\linethickness{2.0pt}\line(0,-24){24}}
	\put(330,388){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(330,364){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(50,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  C}}
	\put(37,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(37,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(67,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(67,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(60,279){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(30,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(30,282){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(30,258){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(90,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(90,282){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(90,258){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(130,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  A}}
	\put(117,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(117,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(147,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
	\put(147,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(140,279){\color{R0G179B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(110,282){\color{R0G179B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(110,282){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(110,258){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(170,282){\color{R0G179B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(170,282){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(170,258){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(210,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  C}}
	\put(197,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(197,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
	\put(227,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(227,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
	\put(220,279){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(190,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(190,282){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(190,258){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(250,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(250,282){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(250,258){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(290,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  b}}
	\put(277,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
	\put(277,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(307,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(307,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(300,279){\color{R0G0B179}\linethickness{2.0pt}\line(0,-18){18}}
	\put(270,282){\color{R0G0B179}\linethickness{2.0pt}\line(0,-24){24}}
	\put(270,282){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(270,258){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(330,282){\color{R0G0B179}\linethickness{2.0pt}\line(0,-24){24}}
	\put(330,282){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(330,258){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(370,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  C}}
	\put(357,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
	\put(357,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  4}}
	\put(387,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(387,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  4}}
	\put(380,279){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(350,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(350,282){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(350,258){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(410,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(410,282){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(410,258){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(450,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  A}}
	\put(437,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
	\put(437,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  5}}
	\put(467,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  3}}
	\put(467,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  5}}
	\put(460,279){\color{R0G179B0}\linethickness{2.0pt}\line(0,-18){18}}
	\put(430,282){\color{R0G179B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(430,282){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(430,258){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(490,282){\color{R0G179B0}\linethickness{2.0pt}\line(0,-24){24}}
	\put(490,282){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(490,258){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
\end{picture}

%Wie man leicht sieht, findet die Heuristik unausweichlich die vollen Intervalle.\footnote{
%Eine weitere interessante Beobachtung, die hier nicht weiter vertieft werden soll, ist:

%Gibt es zwei Logs kann ein Empfangsereignis $x$ einem Sendeereignis $X$ in einem solchen Intervall nie zugeordnet werden, wenn die jeweils nächsten Empfangsereignisse, die in ihrem lokalen Log nach $x$ oder $X$ empfangen wurden, kein mögliches Sendeereignis zwischen ihnen und $x$ oder $X$ besitzen.
%}

%Das obige Bild eignet sich zudem gut, um die von der Heuristik verwendete Datenstruktur zu erklären. \footnote{allerdings nicht den eigentlichen Algorithmus, da dieser bei der obigen Eingabe sofort terminiert}

An diesem Bild kann man auf zwei Weisen die von der Heuristik gefundenen Intervalle ablesen:
%Für jedes Empfangsereignis soll bestimmt werden, welches das frühestmögliche und welches das spätestmögliche zugeordnete Sendeereignis sein kann. Die gefundenen Zuordnungen sind im obigen Bild auf zwei Weisen dargestellt.  
Die eine, visuelle Darstellung erfolgt in Form von Pfeilen, von denen sich bei jedem Empfangsereignis genau zwei treffen. Der erste Pfeil führt vom frühestmöglichen Sendeereignis zum Empfangsereignis und der zweite Pfeil führt vom Empfangsereignis zum spätestmöglichen Sendeereignis.

Diese intuitive Pfeildarstellung ist leicht verständlich, kann aber nur schlecht als interne Darstellung im Rechner verwendet werden, weshalb %aber natürlich nicht direkt in Form von Pfeilen gespeichert werden kann, 
 \cite{Marold} dazu Intervallvektoruhren einführt (siehe die formale Definition des Algorithmus im Anhang \ref{heuristic:code}). Diese Intervallvektoruhren basieren auf Matterns Vektoruhren \cite{Vektoruhren}, die angeben, welche Ereignisse gleichzeitig geschehen können. Dies kann man leicht an Hand des obigen Bildes verstehen, wo die Intervallvektoruhren als Matrix unter den Ereignistypen dargestellt sind. Diese Matrix enthält zwei Zeilen, eine Zeile für jedes Log. Bei jedem Ereignis enthält die linke Spalte für jedes Log die Nummer\footnote{Die Ereignisse seien in jedem Log mit Index 0 beginnend nummeriert.} des frühesten Ereignisses im Log dieser Zeile, welches gleichzeitig mit dem Ereignis, dem die Matrix zugeordnet ist, aufgetreten sein kann. Die rechte Spalte gibt analog die Nummer des spätestmöglichen Ereignisses an.

Betrachtet man die Matrizen im Bild genauer, erkennt man, dass in der ersten Reihe von Ereignissen, der Matrixeintrag in der linken Spalte und ersten Zeile identisch zum Eintrag in der rechten Spalte ist. Dasselbe gilt für die zweite Zeile der Matrizen der zweiten Reihe. Die Erklärung hierfür ist simpel: Diese Matrixzeile gibt jeweils an, welche Ereignisse in diesem Log gleichzeitig zu diesem Ereignis passiert sein können, und das kann, da die Ereignisse in einem Log eine feste Reihenfolge besitzen, offensichtlich nur das Ereignis selbst sein. In dieser Zeile steht somit die eindeutige ID des Ereignisses bezüglich des eigenen Logs.

Die Pfeildarstellung lässt sich dabei trivial aus der Matrix auslesen: Bei jedem Empfangsereignis steht in der Zeile, welche nicht die eindeutige ID enthält, in der linken Spalte die ID des frühestmöglichen Sendeereignisses und in der rechten Spalte die ID des spätestmöglichen Sendeereignisses. Damit kann man im Sendelog (welches in dem von der Heuristik behandelten Spezialfall pSRC durch den Typ des Ereignisses eindeutig festgelegt ist) die entsprechenden Sendeereignisse finden und mit dem Empfangsereignis über die beiden Pfeile verbinden.

Die Matrizen der Sendeereignisse geben entsprechend ein Intervall der möglichen Empfangsereignisse an. Im Bild sieht man viele Sendeereignisse, bei denen diese Intervalle sich genau bis zum ersten und letzten Ereignis erstrecken. Dies liegt einfach daran, dass diese Sendeereignisse möglicherweise nicht empfangen werden und daher vor oder nach allen Ereignissen im Empfangslog aufgetreten sein könnten (man könnte hier für die Matrixeinträge ebenso gut $-\infty $ und $+\infty$ nehmen).

Sowohl in der Pfeil- wie auch in der Vektoruhrdarstellung kann man nun ein Kriterium dafür definieren, ob eine solche Zuordnung des frühesten oder spätesten Sendeereignisses möglich ist. Bei der  von \cite{WhoSaidThat} verwendeten Pfeildarstellung basiert es auf der Beobachtung, dass die Ereignisse innerhalb eines Logs in einer strikten Reihenfolge angeordnet sind und es damit innerhalb des Logs keine Ereignisse geben kann, die gleichzeitig geschehen können. Damit stellt die Reihenfolge im Log offenbar eine ">kleiner"<-Relation dar, während die eingezeichneten Pfeile eine ">kleiner-gleich"<-Relation darstellen. Es darf also keine Pfeile geben, deren Ende sich ausgehend von ihrem Anfang durch einen anderen Pfeil erreichen lässt, der später in ihrem Log beginnt. Außerdem darf es keinen Pfad von einem Pfeilanfang zu einem Pfeilende (oder sogar zu einem Ereignis vor dem Pfeilende) geben, der sich entlang der Pfeile und der Ereignisse in einem Log erstreckt. %Das heißt, dass es jeder Pfeil ungültig ist, dessen Ende man ausgehend von seinem Anfang dadurch erreichen werden kann, dass man anderen Pfeilen und . (zur genaueren Erklärung sei auf das Paper  \cite{WhoSaidThat} verwiesen)

In der inhaltlich äquivalenten Intervalldarstellung von \cite{Marold} lautet die Bedingung, dass in jeder Komponente das Minimum eines Empfangsereignisses größer-gleich dem Minimum des ersten Sendeereignisses sein muss und das Maximum kleiner-gleich dem des letztmöglichen Sendeereignisses. Außerdem muss das Maximum des frühestmöglich Sendeereignisses in jeder Komponente kleiner-gleich sein, als das des Empfangsereignisses, während das Minimum des spätestmöglichen Sendeereignisses  größer-gleich dem des Empfangsereignisses sein muss. 
Außerdem muss in dieser Darstellung in einer zweiten Bedingung verlangt werden, dass die Werte einer Matrix immer kleiner-gleich den Werten der Matrix des nächsten Ereignisses dieses Logs sind.

Die Heuristik entfernt nun einfach sämtliche solchermaßen unmöglichen Zuordnungen, bis keine unmöglichen Zuordnungen mehr existieren. In der Pfeildarstellung entspricht dieses Entfernen dem Verschieben der Pfeilenden zum nächsten Ereignis vom selben Typ. In der Intervallvektoruhrdarstellung setzt man einfach die Matrixwerte auf das gewünschte Maximum/Minimum (so dass die Intervalle jeweils kleiner werden). Das Wiederherstellen der ersten Bedingung heißt ">Kreuztausch"<, dass der zweiten ">Wischen"<.

Leider funktioniert dieses Verfahren nicht, wie nun hier gezeigt wird:
\begin{lem}
	Die von der Heuristik gefundenen Intervalle sind nicht minimal.
\end{lem}
\begin{proof}
Dazu sehen wir uns einfach folgende Eingabe an:

\begin{tabular}{cccccc}
	A & b & c & A\\
	B & a & B & c & B\\
	C & a & b & C
\end{tabular} 

Dazu gibt es mindestens eine gültige Lösung, also handelt es sich tatsächlich um eine mögliche Eingabe:\\
\begin{tabular}{cccccc}
	& A & b & c & A\\
	& $\updownarrow$ & $\updownarrow$ & $\updownarrow$\\
	B & a & B & c & B\\
	& $\updownarrow$ & $\updownarrow$ & $\updownarrow$\\
	C & a & b & C
\end{tabular} 


%Dann werden folgende Intervallvektoruhren berechnet: 
Dann liefert die Heuristik folgende Ausgabe: (man kann sich davon überzeugen, dass dies in der Tat die Ausgabe des Algorithmus ist, indem man feststellt, dass die angegebenen Intervallvektoruhren weder durch Kreuztausche noch durch Wischen verändert werden. Siehe auch die formale Definition des Algorithmus im Anhang \ref{heuristic:code})
%\begin{verbatim}
%A       b       c       A
%0-0     1-1     2-2     3-3
%0-1     0-4     0-4     1-4
%0-1     0-3     0-3     1-3
%B       a       B       c       B
%0-1     0-3     0-3     0-3     1-3
%0-0     1-1     2-2     3-3     4-4
%0-2     0-3     0-3     0-3     2-3
%C       a       b       C
%0-2     0-3     0-3     2-3
%0-3     0-4     0-4     3-4
%0-0     1-1     2-2     3-3
%\end{verbatim}

\setlength{\unitlength}{1pt}
\begin{picture}(380,206)(30,196)
	\definecolor{R107G107B153}{rgb}{0.41960785,0.41960785,0.6}
	\definecolor{R153G107B107}{rgb}{0.6,0.41960785,0.41960785}
	\definecolor{R107G153B107}{rgb}{0.41960785,0.6,0.41960785}
	\definecolor{R0G128B0}{rgb}{0.0,0.5019608,0.0}
	\definecolor{R0G179B0}{rgb}{0.0,0.7019608,0.0}
	\definecolor{R0G0B128}{rgb}{0.0,0.0,0.5019608}
	\definecolor{R0G0B179}{rgb}{0.0,0.0,0.7019608}
	\definecolor{R128G0B0}{rgb}{0.5019608,0.0,0.0}
	\definecolor{R179G0B0}{rgb}{0.7019608,0.0,0.0}
	\put(60,322){\color{R107G107B153}\linethickness{1.0pt}\vector(80,30){80}}
	\put(140,352){\color{R107G107B153}\linethickness{1.0pt}\vector(240,-30){240}}
	\put(60,244){\color{R153G107B107}\linethickness{1.0pt}\vector(160,108){160}}
	\put(220,352){\color{R153G107B107}\linethickness{1.0pt}\vector(80,-108){80}}
	\put(60,352){\color{R107G153B107}\linethickness{1.0pt}\vector(80,-30){80}}
	\put(140,322){\color{R107G153B107}\linethickness{1.0pt}\vector(160,30){160}}
	\put(60,244){\color{R153G107B107}\linethickness{1.0pt}\vector(240,30){240}}
	\put(300,274){\color{R153G107B107}\linethickness{1.0pt}\vector(0,-30){30}}
	\put(60,352){\color{R107G153B107}\linethickness{1.0pt}\vector(80,-108){80}}
	\put(140,244){\color{R107G153B107}\linethickness{1.0pt}\vector(160,108){160}}
	\put(60,274){\color{R107G107B153}\linethickness{1.0pt}\vector(160,-30){160}}
	\put(220,244){\color{R107G107B153}\linethickness{1.0pt}\vector(160,30){160}}
	\put(50,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  A}}
	\put(37,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(37,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(37,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(67,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(67,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(67,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(60,385){\color{R0G179B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(30,388){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(30,388){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(30,352){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(90,388){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(90,388){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(90,352){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(130,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  b}}
	\put(117,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(117,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(117,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(147,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(147,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(147,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(140,385){\color{R0G0B179}\linethickness{2.0pt}\line(0,-30){30}}
	\put(110,388){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(110,388){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(110,352){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(170,388){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(170,388){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(170,352){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(210,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  c}}
	\put(197,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(197,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(197,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(227,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(227,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(227,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(220,385){\color{R179G0B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(190,388){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(190,388){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(190,352){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(250,388){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(250,388){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(250,352){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(290,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  A}}
	\put(277,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(277,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(277,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(307,379){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(307,367){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(307,355){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(300,385){\color{R0G179B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(270,388){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(270,388){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(270,352){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(330,388){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(330,388){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(330,352){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(50,310){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  B}}
	\put(37,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(37,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(37,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(67,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(67,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(67,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(60,307){\color{R0G0B179}\linethickness{2.0pt}\line(0,-30){30}}
	\put(30,310){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(30,310){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(30,274){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(90,310){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(90,310){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(90,274){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(130,310){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  a}}
	\put(117,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(117,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(117,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(147,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(147,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(147,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(140,307){\color{R0G179B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(110,310){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(110,310){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(110,274){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(170,310){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(170,310){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(170,274){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(210,310){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  B}}
	\put(197,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(197,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(197,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(227,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(227,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(227,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(220,307){\color{R0G0B179}\linethickness{2.0pt}\line(0,-30){30}}
	\put(190,310){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(190,310){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(190,274){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(250,310){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(250,310){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(250,274){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(290,310){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  c}}
	\put(277,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(277,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(277,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(307,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(307,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(307,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(300,307){\color{R179G0B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(270,310){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(270,310){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(270,274){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(330,310){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(330,310){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(330,274){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(370,310){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  B}}
	\put(357,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(357,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(357,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(387,301){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(387,289){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(387,277){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(380,307){\color{R0G0B179}\linethickness{2.0pt}\line(0,-30){30}}
	\put(350,310){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(350,310){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(350,274){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(410,310){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(410,310){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(410,274){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(50,232){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  C}}
	\put(37,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(37,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(37,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(67,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(67,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(67,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(60,229){\color{R179G0B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(30,232){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(30,232){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(30,196){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(90,232){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(90,232){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(90,196){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(130,232){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  a}}
	\put(117,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(117,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(117,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(147,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(147,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(147,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  1}}
	\put(140,229){\color{R0G179B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(110,232){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(110,232){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(110,196){\color{R0G179B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(170,232){\color{R0G179B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(170,232){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(170,196){\color{R0G179B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(210,232){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  b}}
	\put(197,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(197,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  0}}
	\put(197,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(227,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(227,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(227,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(220,229){\color{R0G0B179}\linethickness{2.0pt}\line(0,-30){30}}
	\put(190,232){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(190,232){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(190,196){\color{R0G0B179}\linethickness{2.0pt}\line(5,0){5}}
	\put(250,232){\color{R0G0B179}\linethickness{2.0pt}\line(0,-36){36}}
	\put(250,232){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(250,196){\color{R0G0B179}\linethickness{2.0pt}\line(-5,0){5}}
	\put(290,232){\makebox(20,20)[b]{\fontseries{b}\fontsize{12.0}{14}\selectfont  C}}
	\put(277,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  2}}
	\put(277,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(277,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(307,223){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(307,211){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  4}}
	\put(307,199){\makebox(20,20)[br]{\fontsize{10.0}{12}\selectfont  3}}
	\put(300,229){\color{R179G0B0}\linethickness{2.0pt}\line(0,-30){30}}
	\put(270,232){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(270,232){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(270,196){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
	\put(330,232){\color{R179G0B0}\linethickness{2.0pt}\line(0,-36){36}}
	\put(330,232){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\put(330,196){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
\end{picture}

Wie man sieht wird das erste B als mögliches Sendeereignis für das b im dritten Log gefunden.
	
Um zu überprüfen, ob dies korrekt ist, nehmen wir nun  diese Zuordnung als gegeben an. Dann gibt es zwei Möglichkeiten, entweder (Fall 1:) ist das empfangene b im ersten Log ebenfalls diesem Sendeereignis zugeordnet, oder (Fall 2:) einem der anderen gesendeten Bs: (Das erste A muss in diesem Fall offensichtlich vor dem ersten B gesendet werden, sonst gibt es keine gültige Zuordnung für das empfangene a im dritten Log)
%Offensichtlich gibt es für das erste a im zweiten Log, genau zwei mögliche Sender von As im ersten Log.\\
%Also gibt es für diese Ereignisse nur diese beiden Zuordnungsmöglichkeiten:

%LATEX Anmerkung: scalebox funktioniert so (auch wenn es in der dvi nicht angezeigt wird)
\newcommand{\updownarrowlarge}{\multirow{3}{*}{\scalebox{1}[3]{$\updownarrow$}}}
{
\begin{figure}[h]
	\begin{minipage}{5cm}
		\vspace{0.5cm}
		\center{Fall 1}
		\vspace{0.5cm}
		
		\begin{tabular}{cc|c|ccccc}
			& A & b & c & A\\
			& \updownarrowlarge & $\updownarrow$\\
			& & B & a & B & c & B\\
			& & $\updownarrow$\\  
			C & a & b & C
		\end{tabular}\\
		\vspace{0.5cm}
	\end{minipage}
	\hspace{1cm}\vline\hspace{1cm}
	\begin{minipage}{7cm}
		\vspace{0.5cm}
		\center{Fall 2}
		
		\vspace{0.5cm}
		\begin{tabular}{cc|c|cccccc}
			& A &   & b & c & A &\\
			& \updownarrowlarge & \\
			&   & B & a & B & c & B\\
			& & $\updownarrow$\\  
			C & a & b & C
		\end{tabular}\\
		\vspace{0.5cm}
	\end{minipage}
\end{figure}
}
In der rechten Hälfte gibt es  genau ein gesendetes A und ein gesendetes C, also gibt es nur genau eine mögliche Zuordnung für das im ersten Log empfangene c und das im zweiten Log empfangene a:

\begin{figure}[h]
	\begin{minipage}{6.5cm}
		\vspace{0.5cm}
		\center{Fall 1}
		
		\vspace{0.5cm}
		\begin{tabular}{cc|c|ccccc}
			& A & b & c & A\\
			& \updownarrowlarge & $\updownarrow$ & \updownarrowlarge & $\updownarrow$\\
			&   & B &   & a & B & c & B\\
			& & $\updownarrow$\\  
			C & a & b & C
		\end{tabular}\\
		\vspace{0.5cm}
	\end{minipage}
	\hspace{0.5cm}\vline\hspace{0.5cm}
	\begin{minipage}{7cm}
		\vspace{0.5cm}
		\center{Fall 2}
		
		\vspace{0.5cm}
		\begin{tabular}{cc|c|cccccc}
			& A &   & b & c & A &\\
			& \updownarrowlarge &  && \updownarrowlarge & $\updownarrow$\\
			&   & B &   &   & a & B & c & B\\
			& & $\updownarrow$\\  
			C & a & b &   & C
		\end{tabular}\\
		\vspace{0.5cm}
	\end{minipage}
\end{figure}

Offensichtlich ist es nun nicht mehr möglich, dem in Log 2 empfangenen c ein Sendeereignis zuzuordnen.

%\begin{figure}[h]
%\begin{minipage}{5cm}
%\vspace{0.5cm}
%\begin{tabular}{c|cc|ccccc}
%  & A & b & c & A\\
%  &   & B & a & B & c & B\\
%C & a & b & C
%\end{tabular}\\
%\vspace{0.5cm}
%\end{minipage}
%\hspace{1cm}\vline\hspace{1cm}
%\begin{minipage}{7cm}
%\vspace{0.5cm}
%\begin{tabular}{ccc|cc|cccc}
%A & b & c & A &\\
%  &   &   &   & B & a & B & c & B\\
%  &   & C & a & b & C
%\end{tabular}\\
%\vspace{0.5cm}
%\end{minipage}
%\end{figure}
%
%Offensichtlich ist es im zweiten Fall nicht möglich ein gültiges Sendeereignis für das b im linken Bereich zu finden.\\
%Im ersten Fall, sind die Zuordnungen in den ersten beiden Bereichen intuitiv gültig, doch im rechten Bereich, muss man das empfangenen a, dem einzigen A-Sendeereignis zuordnen:\\
%\begin{tabular}{c|cc|ccccc}
%  & A & b & c & A\\
%  &   & B &   & a & B & c & B\\
%C & a & b & C
%\end{tabular}
%
%Damit wird es aber unmöglich sowohl dem empfangenen c in Log 1 wie auch dem in Log 2 ein gesendetes C zuzuweisen.
%

Also liefert der Algorithmus für das b ein frühestmögliche Sendeereignis, welches nicht zu einer gültigen Lösung führt.
Somit ist das gefundene Intervall nicht minimal.\footnote{Allerdings basiert dieses Gegenbeispiel auf der Annahme, dass Sende- und Empfangsereignis exakt zum gleichen Zeitpunkt aufgetreten sind. Gäbe es eine -- von \cite{WhoSaidThat} jedoch explizit ausgeschlossene -- Empfangsverzögerung wäre die obige Zuordnung gültig.}

%\begin{lem}
%Ist $v \in I^{n_L}$ ein Vektor, $L'_i = \{e \in L_i | e_i > v_i\}$ und $L'=\bigcup_j L'_j$,  so dass gilt $S_f(r) \in L'$ für jedes $r \in R \cap L'$, gegeben, so gibt es für jedes $r \in R \cap L'$ es eine gültige Lösung $(V,e)$ für $L'_i$ mit $V(r) = V(S_f)$
%\end{lem}
%\begin{proof}
%Induktion über $|R \cap L'|$:\\
%Für $|R \cap L'|=0$ ist dies offensichtlich wahr.\\
%Zu zeigen: $|R \cap L'| \rightarrow |R \cap L'	|+1$\\
%Gesucht ist $s \in S \cap L'$, so dass es eine Menge $Q = \{q\in R|S_f(q) = q \} \neq \emptyset$ gibt und für jedes Log $L_i$ gilt: Ist $r \in R \cap L_i \setminus Q$, so gibt es kein $e \in Q \cup {s}$ mit $e \geq r$ und ist $t \in \{s|\exists r\in R: s=S_f(r)\} \cap L_i \setminus Q$, so gibt es kein $e \in Q \cup {s}$ mit $e \geq t$.\\
%Anders formuliert: Setzt man $v'_i = \begin{cases}
%q_i & \text{falls es ein }q\in L_i \cap (Q \cup \{s\})\text{ gibt }\\
%v_i & \text{sonst}
%\end{cases}$\\
%, so muss für $L''_i = \{e \in L'_i | e_i > v'_i\}$ und $L''=\bigcup_j L''_j$ gelten, dass $S_f(r) \in L''$ ist, für jedes $r \in R \cap L''$
%
%Offensichtlich gibt es mindestens ein Log $L_i$, so dass ein $r$ mit $S_f(r) \in L'_i$ gibt und $S_f(r) \leq q$ für alle $q \in L'_i$.\\
%Wäre dies nämlich nicht der Fall gäbe es für jedes $S_f(r)$ (mindestens eins existiert) in jedem Log $L'_i$ ein Ereignis $q \in  L'_i$, so dass $q \leq S_f(r),q \neq S_f(r)$.\\
%Für $S_f(q)$ gibt es wiederum ein $p \leq S_f(q)$, und somit existiert eine Folge $q_i \in L'$ mit $S_f(q_1) \geq q_2 \geq S_f(q_2) \geq q_3 \geq S_f(q_3), \ldots$, die alle paarweise verschieden sind. Daraus folgt aber,  $|L'| = \infty$, was offensichtlich nicht der Fall ist.
%
%Sei $T = \{S_f(r) \in L_i |\forall i, \forall r \in L' \text{ so dass gilt } \nexists q \in L_i \cap R \text{ mit } q \leq S_f(r) \text{ und } \nexists q \text{ mit } L_i \ni S_f(q) \leq S_f(r) \wedge S_f(q) \neq S_f(r) \} \neq \emptyset$\\
%
%\end{proof}
%

\end{proof}
%In \cite{WhoSaidThat} wird nun ein Kriterium gegeben, durch das man Erkennen kann, ob eine solche Existiert ein Pfeil 

\section{Korrekt gelöste Spezialfälle}
In diesem Abschnitt werden drei Spezialfälle genannt, in denen das Ergebnis der Heuristik trotz der in den vorherigen Abschnitten aufgezeigten Probleme korrekt ist.

Prinzipiell muss dafür gezeigt werden, dass es für jede (oder einige) der durch die Intervalle bestimmten möglichen Zuordnungen eine gültige Lösung (in etwa eine konsistente GA und GTO) gibt, die diese Zuordnung enthält. Aus Platzgründen ist dieser Abschnitt aber relativ kurz gehalten und man findet die weiteren Details im Anhang.

\begin{lem}
	\label{lem:n_R=1,pre}
	Die Heuristik funktioniert fehlerfrei, wenn es nur ein einziges Log gibt, welches Empfangsereignisse enthält.
\end{lem}
\begin{proof}
	Es ist klar, dass keinen zwei Empfangsereignissen innerhalb eines Logs dieselben Sendeereignisse zugewiesen werden (sonst gäbe es zwei Pfeile zu bzw. von diesem Sendeereignis und somit zwei Pfade).
%	Hierfür wird zuerst gezeigt, dass keine zwei Empfangsereignissen innerhalb desselben Logs dieselben das frühest- und spätestmögliche Sender
	
	Damit lässt sich nun zeigen, dass  eine gültige Lösung entsteht, wenn man jedem Empfangsereignis das nach der Heuristik früheste Sendeereignis zuweist. Dasselbe gilt äquivalent für das spätestmögliche Sendeereignis. 
	
	Daraus folgt wiederum, dass jede Zuordnung innerhalb des gefundenen Intervalls tatsächlich möglich ist. Dazu nimmt man einfach eine Zuordnung als gegeben an und weist jedem früheren Empfangsereignis (innerhalb des einzigen Empfangslogs) das frühestmögliche und jedem späteren Empfangsereignis das spätestmögliche Sendeereignis zu, wodurch man eine gültige Lösung enthält.
	
	Siehe Anhang \ref{heuristic:nr=1} für Details.
\end{proof}


\begin{lem}
	Die Heuristik funktioniert fehlerfrei, wenn es nur ein einziges Log gibt, welches Sendeereignisse enthält.
\end{lem}
\begin{proof}
	Dies kann man relativ direkt aus dem vorherigen Lemma \ref{lem:n_R=1,pre} folgern, indem man zeigt, dass sich die Ereignisse in den unterschiedlichen Logs nicht gegenseitig beeinflussen. Das heißt, dass der Algorithmus genau dieselben Zuordnungen findet, unabhängig davon, ob man ihn auf alle Logs gemeinsam anwendet, oder einzeln für jedes Empfangslog zusammen mit dem Sendelog. %Jedes empfangene Log muss offensichtlich eine (sortierte) Teilmenge des Sendelogs sein. 
	
	Gibt es aber nur ein Empfangslog und ein Sendelog, so wurde im vorherigen Lemma gezeigt, dass jedes Sendeereignis innerhalb des Intervalls zu einer gültigen Zuordnung führt, und infolgedessen gilt dies auch für die gesamten Logs.
	
	Siehe Anhang \ref{heuristic:ns=1} für Details.
\end{proof}

\begin{lem}
	Die von der Heuristik gefundenen Intervalle sind minimal, wenn es insgesamt nur zwei Logs gibt.
\end{lem}
\begin{proof}
	In diesem Fall muss man eine andere Beweisstrategie wählen, als in den vorherigen Lemmas, da sich leider keine gültige Lösung ergibt,  wenn man für alle Ereignisse das frühestmögliche Sendeereignis wählt. Dies zeigt folgendes Trivialbeispiel:
%	Man könnte vermuten, dass man eine gültige Lösung erhält, wenn man einfach für jedes Ereignis die nach dem Algorithmus minimal oder maximal mögliche Vektoruhr wählt. Dies ist jedoch nicht möglich, da man auf diese Weise keine gültige globale Anordnung erhält, wie 
%	%Es ist nicht möglich, eine eindeutige globale Anordnung zu erhalten, indem man für jede Vektoruhr  die  maximale oder minimale Grenze wählt.\\
%	folgendes Gegenbeispiel zeigt:
%	\begin{verbatim}
%	2
%	RqFR
%	QGrQ
%	\end{verbatim}
%	
%	Für diese Eingabe werden die folgende Intervallvektoruhren berechnet:
	%\begin{verbatim}
	%R       q       F       R
	%0-0     1-1     2-2     3-3
	%0-2     0-3     0-3     2-3
	%Q       G       r       Q
	%0-1     0-3     0-3     1-3
	%0-0     1-1     2-2     3-3
	%\end{verbatim}
	
	\setlength{\unitlength}{1pt}
	\begin{picture}(220,144)(30,258)
		\definecolor{R153G107B107}{rgb}{0.6,0.41960785,0.41960785}
		\definecolor{R107G153B153}{rgb}{0.41960785,0.6,0.6}
		\definecolor{R0G128B128}{rgb}{0.0,0.5019608,0.5019608}
		\definecolor{R0G179B179}{rgb}{0.0,0.7019608,0.7019608}
		\definecolor{R128G0B0}{rgb}{0.5019608,0.0,0.0}
		\definecolor{R179G0B0}{rgb}{0.7019608,0.0,0.0}
		\put(60,294){\color{R153G107B107}\linethickness{1.0pt}\vector(80,70){80}}
		\put(140,364){\color{R153G107B107}\linethickness{1.0pt}\vector(80,-70){80}}
		\put(60,364){\color{R107G153B153}\linethickness{1.0pt}\vector(80,-70){80}}
		\put(140,294){\color{R107G153B153}\linethickness{1.0pt}\vector(80,70){80}}
		\put(50,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  A}}
		\put(37,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(37,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(67,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(67,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(60,385){\color{R0G179B179}\linethickness{2.0pt}\line(0,-18){18}}
		\put(30,388){\color{R0G179B179}\linethickness{2.0pt}\line(0,-24){24}}
		\put(30,388){\color{R0G179B179}\linethickness{2.0pt}\line(5,0){5}}
		\put(30,364){\color{R0G179B179}\linethickness{2.0pt}\line(5,0){5}}
		\put(90,388){\color{R0G179B179}\linethickness{2.0pt}\line(0,-24){24}}
		\put(90,388){\color{R0G179B179}\linethickness{2.0pt}\line(-5,0){5}}
		\put(90,364){\color{R0G179B179}\linethickness{2.0pt}\line(-5,0){5}}
		\put(130,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  b}}
		\put(117,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(117,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(147,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(147,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(140,385){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
		\put(110,388){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
		\put(110,388){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
		\put(110,364){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
		\put(170,388){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
		\put(170,388){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
		\put(170,364){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
		\put(210,388){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  A}}
		\put(197,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(197,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(227,379){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(227,367){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(220,385){\color{R0G179B179}\linethickness{2.0pt}\line(0,-18){18}}
		\put(190,388){\color{R0G179B179}\linethickness{2.0pt}\line(0,-24){24}}
		\put(190,388){\color{R0G179B179}\linethickness{2.0pt}\line(5,0){5}}
		\put(190,364){\color{R0G179B179}\linethickness{2.0pt}\line(5,0){5}}
		\put(250,388){\color{R0G179B179}\linethickness{2.0pt}\line(0,-24){24}}
		\put(250,388){\color{R0G179B179}\linethickness{2.0pt}\line(-5,0){5}}
		\put(250,364){\color{R0G179B179}\linethickness{2.0pt}\line(-5,0){5}}
		\put(50,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  B}}
		\put(37,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(37,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(67,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(67,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(60,279){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
		\put(30,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
		\put(30,282){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
		\put(30,258){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
		\put(90,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
		\put(90,282){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
		\put(90,258){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
		\put(130,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  a}}
		\put(117,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  0}}
		\put(117,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(147,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(147,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(140,279){\color{R0G179B179}\linethickness{2.0pt}\line(0,-18){18}}
		\put(110,282){\color{R0G179B179}\linethickness{2.0pt}\line(0,-24){24}}
		\put(110,282){\color{R0G179B179}\linethickness{2.0pt}\line(5,0){5}}
		\put(110,258){\color{R0G179B179}\linethickness{2.0pt}\line(5,0){5}}
		\put(170,282){\color{R0G179B179}\linethickness{2.0pt}\line(0,-24){24}}
		\put(170,282){\color{R0G179B179}\linethickness{2.0pt}\line(-5,0){5}}
		\put(170,258){\color{R0G179B179}\linethickness{2.0pt}\line(-5,0){5}}
		\put(210,282){\makebox(20,20)[b]{\fontseries{b}\fontsize{12}{14}\selectfont  B}}
		\put(197,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  1}}
		\put(197,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(227,273){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(227,261){\makebox(20,20)[br]{\fontsize{10}{12}\selectfont  2}}
		\put(220,279){\color{R179G0B0}\linethickness{2.0pt}\line(0,-18){18}}
		\put(190,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
		\put(190,282){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
		\put(190,258){\color{R179G0B0}\linethickness{2.0pt}\line(5,0){5}}
		\put(250,282){\color{R179G0B0}\linethickness{2.0pt}\line(0,-24){24}}
		\put(250,282){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
		\put(250,258){\color{R179G0B0}\linethickness{2.0pt}\line(-5,0){5}}
	\end{picture}
	
	%Weder zwischen $(1,0)$ und $(0,2)$ noch zwischen $(1,3)$ und $(3,2)$ existiert eine Reihenfolge, also ergibt sowohl das die Wahl des Minimum wie auch die des Maximum keine gültige globale Reihenfolge.
	
	Stattdessen benutzt man %daher in diesem Beweis 
	die Tatsache, dass jede Zuordnung zweier Ereignisse in diesem Spezialfall die Logs in genau zwei Hälften teilt. Eine linke Hälfte, in der sich alle früheren Ereignisse befinden, und in eine rechte Hälfte in der sich alle späteren befinden (früher und später bezieht sich dabei auf die lokale Reihenfolge in jedem Log).
	
	Dann lässt sich zeigen, dass, wenn man einem Empfangsereignis entweder das im gefundenen Intervall früheste  oder späteste Sendeereignis zuweist, in jeder Hälfte einem Ereignis wiederum entweder das früheste  oder späteste Sendeereignis zugewiesen werden kann, und zwar so, dass eine der dadurch entstehenden Hälften (geschnitten mit der Hälfte in der man die Zuordnung durchgeführt hat) kein Empfangsereignis enthält.	Veranschaulicht heißt dies: (B sei ein nach der Heuristik frühest- oder spätestmögliche Sendeereignis, $\square$ bezeichnet irgendein Ereignis)
	
	\begin{tabular}{ccccccccccc}
	$\ldots$ &	$\square$ & $\square$ & $\square$ & B & $\square$ & $\square$ & $\square$ & $\ldots$ \\
		  &      &        &        &         & $\updownarrow $\\
	$\ldots$ & $\square$ & $\square$ & $\square$ & b& $\square$ & $\square$ & $\square$ & $\ldots$ 
	\end{tabular}

	Die obrige, als Text schwer verständliche Aussage bedeutet nun im Prinzip, dass es Ereignisse $a, A, c, C$ gibt, so dass die Sendeereignisse $A$ und $C$ frühest- oder spätestmögliche Sendeereignisse sind und kein $\boxdot$ ein Empfangsereignis ist: (das Bild ist dabei vereinfacht, es könnte auch sein, dass die Sende- und Empfangsereignisse im jeweils anderen Log liegen, so dass sich \emph{nicht} alle Sendeereignisse im selben Log befinden)
	
	\begin{tabular}{cccccccccccccccc}
		$\ldots$ &	$\square$ & A & $\boxdot$ &$\ldots$ & $\boxdot$  & B  & $\boxdot$ & $\ldots$ & $\boxdot$ & C & $\square$ & $\ldots$ \\
		&      &   $\updownarrow$      &   &      &         & $\updownarrow $ &&&&$\updownarrow$ \\
		$\ldots$ & $\square$ & a & $\boxdot$ & $\ldots$ & $\boxdot$ & b& $\boxdot$ & $\ldots$ & $\boxdot$& c& $\square$ & $\ldots$ 
	\end{tabular}
			
	Damit kann man nun in der rechten und linken Hälfte rekursiv neue Ereignisse einander zuordnen, wodurch eine gültige Lösung entsteht. (Man könnte auf die Idee kommen, dieses Beweisverfahren vereinfachen zu wollen, indem man links mit einem ersten Ereignis beginnt und dann induktiv neue Zuordnungen hinzufügt. Dies funktioniert jedoch nicht, da man dann nicht für jedes Empfangsereignis beide Sendeereignisse der Intervallgrenzen für möglich erklärt.)
			
	
	%Das bedeutet, dass wenn man erst einmal einem beliebigen Empfangsereignis ein Sendeereignis seiner Intervallgrenzen zuordnet, in jeder Hälfte einem anderen Empfangsereignis ebenfalls ein Sendeereignis zuordnen kann und dadurch die Ausgangsgangssituation erhält.
	
	Siehe Anhang \ref{heuristic:nl=2} für Details.
\end{proof}

Ein weiterer denkbarer Spezialfall ist es, dass es eine beliebige Anzahl von reinen Senderlogs und Empfängerlogs gibt; oder dass es mehrere Sender und Empfängerlogs, sowie maximal ein oder zwei gemischte Logs gibt.  Diese Fälle werden aber in dieser Arbeit nicht weiter untersucht. %vertieft.
%TODO: gute fälle?
%Weitere Einschränkungen deren Untersuchung sich lohnen könnte, aber in dieser Arbeit nicht mehr betrachtet werden, sind: mehrere Logs, von denen keines sowohl sendet wie auch empfängt. Nur ein 

%Weitere Einschränkungen der Loganzahl sind offensichtlich nicht nötig, da die Heuristik wie das Gegenbeispiel im vorherigen Abschnitt zeigt bereits bei 3 Logs nicht mehr funktioniert.

\chapter{Alternativer Algorithmus}
\label{chap:alternativalgo}
\section{Spezialfall: \texorpdfstring{$n_L=2$}{Genau zwei Logs}}
%
%Sei $L_1(i)$ das $i$-te Element im Log 1 und $L_2(i)$ das im Log 2.
%
%\begin{tabular}{rlll}
%RSolvable & \multicolumn{3}{l}{$(f_1, f_2)$} \\
% & =& \multicolumn{2}{l}{$(\nexists i > f_1 \text{ mit } L_1(i) \in R \wedge \nexists i > f_2 \text{ mit } L_1(i) \in R) $}\\
% &  & $\vee ( \exists i > f_1, j > f_2 $ so dass  & $P(L_1(i)) = P(L_2(j))$ \\
% &  &   & $\wedge D(L_1(i)) \neq D(L_2(j))$\\
% &  &   & $\wedge$ RSolvable$(i,j)$\\
% &  &   & $\wedge \nexists k \text{ mit } f_1 < k < i \text{ und } L_1(k) \in R$\\
% &  &   & $\wedge \nexists k \text{ mit } f_2 < k < j \text{ und } L_2(k) \in R$\\
% \end{tabular}
%
In diesem Kapitel wird ein Algorithmus entworfen, der uSRC* exakt löst, ohne dafür sämtliche Kombinationen von möglichen Zuordnungen auszuprobieren. Auf Grund der NP-Vollständigkeit hat er aber weiterhin exponentielle Laufzeit, allerdings nicht bezüglich der Zahl der Ereignisse, sondern bezüglich der Zahl der Logs. Zur besseren Verständlichkeit beginnen wir dabei mit dem Spezialfall, dass nur genau 2 Logs existieren\footnote{In diesem Fall gilt zudem uSRC* = SRC* , da kein Sender seine eigenen Nachrichten empfangen darf.}  (wir gehen in diesem Kapitel  davon aus, dass $L_0 = \emptyset$ ist, da $n_L=2$ als eine intuitivere Darstellung für zwei Logs erscheint, als etwa $n_L=1$).

Als nächstes wird ein neues Kriterium für die Existenz einer Lösung für uSRC* formuliert (welches in ähnlicher Form in \cite{Vektoruhren} als sogenannter \emph{Schnitt} benutzt wird):

\sloppy
Da keinen zwei Empfangsereignissen dieselben Sendeereignisse zugewiesen werden dürfen, kann man, wenn es eine eindeutige und konsistente GA gibt, alle Empfangsereignisse als $r_1, r_2, \ldots, r_{n_R}$ durchnummerieren, so dass  %gilt: durchnummerieren kann, mit $A(r_1) \prec A(r_2) \prec \ldots A(r_{n_R})$. Aus der Konsistenz folgt zudem, dass 
für $k \in \{1,2\}$ und alle $r_i,r_j \in R_k$ mit $i< j$ gilt $r_i \prec_k r_j$ und $A(r_i) \prec_{3-k} A(r_j)$ 

Umgekehrt folgt aus der Existenz einer solchen Nummerierung, dass eine eindeutige und konsistente GA existiert (vergleiche das ähnliches Lemma \ref{lem:GROtoGTO} im Anhang).

Das bedeutet, dass eine Instanz von uSRC* genau dann lösbar ist, wenn es ein erstes Empfangsereignis $r_1 \in R_l$ mit einer Zuordnung $A(r_1)$ gibt, so dass die Logs eingeschränkt auf $L'=\{e \in L | r_1 \prec_l e \vee A(r_1) \prec_{3-l} e\}$ lösbar sind (da es genau dann dort weitere $r_2, \ldots, r_{n_R}$ gibt)\footnote{Dies ähnelt dem Vorgehen im Beweis \ref{n_L=2,solution} des Spezialfalls $n_L=2$ bei der Heuristik.}.  

Damit kann man zwei beliebige Ereignisse $e_1 \in L_1$ und $e_2 \in L_2$ herausgreifen und untersuchen unter welchen Bedingungen es eine Lösung für ihre rechte Hälfte gibt: Der erste, triviale Fall ist, dass es in der rechten Hälfte keine Empfangsereignisse gibt und sie damit offensichtlich lösbar ist. Der zweite Fall ist, dass man ein frühestes Empfangsereignis\footnote{Also ein $r_2$, wenn man eines der Ereignisse $e_1, e_2$ als $r_1$ bezeichnet.} finden kann, dem ein Sendeereignis so zugeordnet werden kann, dass keine Empfangsereignisse zwischen diesen beiden Ereignissen und $e_1, e_2$ liegen. Bezeichnet man diese beiden neuen, einander zugeordneten Ereignisse als $e'_1$ und $e'_2$, so lässt sich die rechte Hälfte von $e_1$ und $e_2$ offenbar genau dann lösen, wenn sich die rechte Hälfte von $e'_1$ und $e'_2$ lösen lässt, da man deren (Zwischen-)Lösung um $e'_1$ und $e'_2$ erweitern kann, um eine Lösung für die rechte Hälfte von $e_1$ und $e_2$ zu erhalten. % Bedingung dafür angeben, ob es eine Lösung für die Ereignisse rechts von ihnen gibt: Entweder gibt es in der rechten Hälfte keine Empfangsereignisse und , oder aber <Es muss zwei weitere Ereignisse $e'_1 \in L_1$ und $e'_2 \in L_2$ geben, von denen eines dem anderen zugeordnet werden kann, keine die Hälfte rechts von diesen beiden wiederum lösbar ist. 
Formal ergibt sich dafür die folgende rekursive Definition einer Funktion, die angibt, ob die rechte Hälfte lösbar ist:

\begin{tabular}{rlll}
	Solvable$_{R}$ & \multicolumn{3}{l}{$(e_1, e_2)$} \\
	& =& \multicolumn{2}{l}{$(\nexists r \in R_1 \text{ mit } e_1 \prec_1 r \wedge \nexists r \in R_2 \text{ mit } e_2 \prec_2 r) $}\\
	&  & $\vee ( \exists e'_1 \in L_1, e'_2 \in L_2$, so dass gilt: &$e_1 \prec_1 e'_1$ und $e_2 \prec_2 e'_2$\\
    &  &   & $\wedge P(e'_1) = P(e'_2)$ \\
	&  &   & $\wedge D(e'_1) \neq D(e'_2)$\\
	&  &   & $\wedge \nexists r \in R_1 \text{ mit } e_1 \prec_1 r \prec_1 e'_1$\\
	&  &   & $\wedge \nexists r \in R_2 \text{ mit } e_2 \prec_2 r \prec_2 e'_2$\\
	&  &   & $\wedge \text{Solvable}_R$ $(e'_1,e'_2))$\\
	\end{tabular}

Entsprechend kann man auch eine analoge Bedingung für die Existenz einer Lösung in der linken Hälfte angeben:

\begin{tabular}{rlll}
	Solvable$_{L}$ & \multicolumn{3}{l}{$(e_1, e_2)$} \\
	& =& \multicolumn{2}{l}{$(\nexists r \in R_1 \text{ mit } r \prec_1 e_1 \wedge \nexists r \in R_2 \text{ mit } r \prec_2 e_2) $}\\
	&  & $\vee ( \exists e'_1 \in L_1, e'_2 \in L_2$, so dass gilt: &$e'_1 \prec_1 e_1$ und $e'_2 \prec_2 e_2$\\
	&  &   & $\wedge P(e'_1) = P(e'_2)$ \\
	&  &   & $\wedge D(e'_1) \neq D(e'_2)$\\
	&  &   & $\wedge \nexists r \in R_1 \text{ mit } e'_1 \prec_1 r \prec_1 e_1$\\
	&  &   & $\wedge \nexists r \in R_2 \text{ mit } e'_2 \prec_2 r \prec_2 e_2$\\
	&  &   & $\wedge \text{Solvable}_L$ $(e'_1,e'_2))$\\
\end{tabular}
%Die Definition von Solvable$_{L}$ erfolgt entsprechend, mit $<$ anstatt von $>$

Dann ist $s_2 \in S_2$ offensichtlich genau dann ein gültiges Sendeereignis für $r_1 \in R_1$, wenn gilt $P(r_1) = P(s_2)$, Solvable$_L(r_1,s_2)$ und Solvable$_R (r_1,s_2)$.

Der Trick ist nun, dass sich Solvable$_{L/R}$ in Polynomialzeit berechnen lässt, da $e_1$ eines der Ereignisse aus $L_1$ und $e_2$ eines der Ereignisse aus $L_2$ sein muss. Damit gibt es offenbar nur maximal $O(n^2)$ mögliche Werte für die Parameter von Solvable$_{L/R}$, also braucht man maximal $O(n^2)$ Aufrufe, da man das Ergebnis entsprechend cachen kann ($n = |L|$ sei die Zahl der Ereignisse).

Die neuen Ereignisse $e'_1$ und $e'_2$ lassen sich mittels Hashing in konstanter Zeit finden, da man vor Berechnung von Solvable$_{L/R}$ für jedes Log in linearer Zeit für jede Position das jeweils nächste Empfangsereignis  und das nächste Sendeereignisse von jedem Typ speichern kann. Damit hat dieser Algorithmus maximal eine Laufzeit von $O(n^2)$ zusammen mit einem Speicherverbrauch von $O(n^2)$.

%Übrigens funktioniert er auch dann, wenn jeder Sender sämtliche Arten von Empfangsereignissen senden kann.

%asymptotisch (vermutlich kann er auch für den allgemeinen Fall erweitert werden, nur scheint sich dann die nicht so praktikable Laufzeit von  $O(n^{2*n_L-1})$ mit Speicherverbrauch $O(n^{n_L})$ zu ergeben, wobei die Rechenzeit vielleicht zu $O(n^{n_L+1})$ verbessert werden könnte)

Statt durch Caching kann man die Mehrfachberechnung von Werten auch mittels dynamischer Programmierung -- also durch ein iteratives statt rekursives Vorgehen  -- verhindern. Zur Demonstrierung dieses Vorgehens wenden wir den alternativen Algorithmus auf die Logs des Gegenbeispiel aus Abschnitt \ref{sec:intervalproblem} an, welches von keinem auf Intervallen basierenden Algorithmus gelöst werden könnte und folgendermaßen lautete:

\begin{tabular}{cccccc}
	B & c & a & B &   & \\
	C & A & C & b & C & A
\end{tabular} 


Für ein iteratives Vorgehen muss man für alle möglichen Eingabewerten von Solvable$_R$ (also für alle Paare von Ereignissen) das resultierende Ergebnis speichern können. Dazu wird eine Matrix benötigt, die in % Speichert man für jede Kombination, 
% Die dazu benötigte Matrix von Ergebniswerten wird für eine Beispiel in   %Dies ergibt 
folgender Grafik dargestellt wird (dabei sind alle Trennlinien nach Sendeereignissen ausgelassen): % worden)
%BcaB
%CACbCA

\begin{tabular}{c||cccc|cc}
&C	&A 	& C	& b	& C	& A \\ \hline
\hline B & 	&  	&  	& ?	&  	&  \\ 
 c &?	&  	&?	&  	& ?	&  \\ 
\hline a & 	&? 	&  	&  	&  	& ? \\ 
\hline B & 	&  	&  	& ?	&  	&  \\ 
 
\end{tabular} 

Dabei sind nur die ein ? enthaltenen Felder relevant, da es offensichtlich eine gültige Lösung nur dann geben kann, wenn einem Empfangsereignis ein Sendeereignis von demselben Typ zugeordnet wird.

In der Definition von Solvable$_{R}$ werden zwei Fälle unterschieden, der erste, triviale Fall ist, dass es rechts von den als Parameter übergebenen Ereignissen keine Empfangsereignisse gibt. Alle Einträge, bei denen dieser Fall auftritt, lassen sich in der Matrix leicht mit * als möglich markieren:

\begin{tabular}{c||cccc|cc}
	   &C	&A 	& C	& b	& C	& A \\ \hline
	\hline B & 	&  	&  	& ?	&  	&  \\ 
	c &?	&  	&?	&  	& ?	&  \\ 
	\hline a & 	&? 	&  	&  	& 	& * \\ 
	\hline B & 	&  	&  	& *	&  	&  \\ 
	 
\end{tabular} 

Im zweiten Fall wird in jedem Log das nächste Empfangsereignis gesucht und überprüft, ob es dafür ein mögliches Sendeereignis innerhalb der betrachteten Hälfte gibt. Umgekehrt formuliert heißt dies, dass die Information innerhalb jeder Zeile und Spalte nach links bzw. oben bis zum nächsten, durch eine Trennlinie dargestellten Empfangsereignis propagiert wird (weil dazwischen liegende Sendeereignisse keine Zuordnung zerstören können). In jeder mit ? markierten Zelle, die bekanntlich für eine potentielle Zuordnung zwischen zwei Ereignissen steht, wird zudem der Wert aus der nach rechts unten diagonal benachbarten Zelle übernommen, da diese Zelle für die rechte Hälfte -- ohne diese beiden Ereignisse -- die Lösbarkeit angibt.   %die angibt, ob es eine Lösung für die Ereignisse in der rechten Hälfte der Logs gibt
Dieser Informationsfluss lässt sich folgendermaßen mittels Pfeile darstellen:

\setlength{\unitlength}{1cm}
%\newsavebox{\tabluarrowbox}
%\savebox{\tabluarrowbox}{\vspace*{-0.5cm}\hspace*{-0.5cm}$\nwarrow$}
%\newcommand{\tabluarrow}{\usebox{\tabluarrowbox}}
%\newsavebox{\luarrowbox}
%\savebox{\luarrowbox}{\vspace*{-0.5cm}\hspace*{-0.5cm}$\nwarrow$}
%\newcommand{\tablarrow}{\hspace*{-0.5cm}$\longleftarrow$}
%\newcommand{\textlonguparrow}{\scalebox{1}[2]{$\uparrow$}}
%\newsavebox{\tabuarrowbox}
%\savebox{\tabuarrowbox}{\vspace*{1cm}$\uparrow$}
\newcommand{\tabtemp}{\phantom{x}}
\newcommand{\tabuarrow}[1][\tabtemp]{\begin{picture}(0,0)\put(0.15,0.25){\vector(0,1){0.5}}\end{picture}#1}
\newcommand{\tablarrow}[1][\tabtemp]{\begin{picture}(0,0)\put(0,0.15){\vector(-1,0){0.5}}\end{picture}#1}
\newcommand{\tabluarrow}[1][\tabtemp]{\tablarrow[]\tabuarrow[#1]}
\newcommand{\tabnwarrow}[1][\tabtemp]{\begin{picture}(0,0)\put(0,0.25){\vector(-1,1){0.5}}\end{picture}#1}
\begin{tabular}{c||cccc|cc}
	    &C	&A 	& C	& b	& C	& A \\ \hline
	\hline B & 	&\tablarrow  	& \tablarrow 	&\tablarrow[?]	&  	&  \\ 
	  c &\tabuarrow[?]	&  \tabluarrow	&\tabluarrow[?]	&  	&\tabuarrow[]\tabnwarrow[?]	&  \\ 
	\hline a & 	&\tabnwarrow[]\tablarrow[?] 	&  	& 	\tabnwarrow&  &\tablarrow[]\tabnwarrow[*] \\ 
	\hline B & 	&\tablarrow   &\tabnwarrow[]\tablarrow  &\tablarrow[*]	&  	&  \\ 
\end{tabular} 

Jede Zuordnung ist genau dann bezüglich ihrer rechten Hälfte möglich, wenn es eine beliebige Zuordnung rechts (bzw. im Bild auch unterhalb) von ihr gibt, die zu  lösbaren Logs führt. Das heißt, jede Zuordnung ist genau dann möglich, wenn (mindestens) ein Pfad von einer anderen möglichen Zuordnung zu ihr existiert\footnote{Hierbei unterscheidet sich das oben beschriebene, iterative Vorgehen geringfügig von der rekursiven Variante, bei der nur die Pfade eine Rolle spielen, die im iterativen Vorgehen mit einem diagonalen Pfeil enden. Man sieht aber leicht, dass dies im Ergebnis keinen Unterschied bewirkt, da es zu jedem Pfad, der nicht mit einem diagonalen Pfeil endet, ein analoger Pfad mit Diagonalpfeilende existieren muss, der (stückweise) parallel verläuft.}. Markiert man die dadurch möglichen Zuordnungen mit + und die unmöglichen mit 0, so ergibt sich: % durch einen diagonale% in einem Log es einen Pfad von einer bereits möglichen Zuordnung dorthin gibt, woraus folgt:

\begin{tabular}{c||cccc|cc}
	&C	&A 	& C	& b	& C	& A \\ \hline
	\hline B & 	&\tablarrow  	& \tablarrow 	&\tablarrow[+]	&  	&  \\ 
	c &\tabuarrow[+]	&  \tabluarrow	&\tabluarrow[0]	&  	&\tabuarrow[]\tabnwarrow[+]	&  \\ 
	\hline a & 	&\tabnwarrow[]\tablarrow[+] 	&  	& 	\tabnwarrow&  &\tablarrow[]\tabnwarrow[*] \\ 
	\hline B & 	&\tablarrow   &\tabnwarrow[]\tablarrow  &\tablarrow[*]	&  	&  \\ 
\end{tabular} 

Also ist die einzige rechte Hälfte, welche nicht lösbar ist, diejenige, die zur Zuordnung zwischen dem empfangenen c und dem mittleren C gehört. %(+ steht für möglich, 0 für unmöglich und * für möglich nach der Randbedingung)

Um nun tatsächlich die möglichen Zuordnungen zu finden, muss man dasselbe noch in umgekehrter Reihenfolge für die linke Hälfte jeder Zuordnung durchführen. Dabei werden in jedem Log alle Zuordnungen mit frühesten Empfangsereignisse nach der Randbedingung als *-möglich markiert und diese Möglichkeitsmarkierungen dann nach rechts und unten verbreitet:

\newcommand{\tabdarrow}[1][\tabtemp]{\begin{picture}(0,0)\put(0.15,0){\vector(0,-1){0.5}}\end{picture}#1}
\newcommand{\tabrarrow}[1][\tabtemp]{\begin{picture}(0,0)\put(0.25,0.1){\vector(1,0){0.5}}\end{picture}#1}
\newcommand{\tabsearrow}[1][\tabtemp]{\begin{picture}(0,0)\put(0.25,0.1){\vector(1,-1){0.5}}\end{picture}#1}
\newcommand{\tabrdarrow}[1][\tabtemp]{\tabrarrow[]\tabdarrow[#1]}
\begin{minipage}{5.1cm}
\begin{tabular}{c||ccc|ccc}
	&C	&A 	& C	& b	& C	& A \\ \hline
	\hline B & 	&  	& 	&\tabsearrow[]\tabrarrow[*]	&  \tabrarrow	&  \\ 
	\hline  c &\tabsearrow[]\tabrarrow[*]	&  \tabrarrow	&*	&  	&\tabrarrow[]\tabsearrow[?]	&  \\ 
	\hline a & 	&\tabrdarrow[?] 	& \tabdarrow[] \tabsearrow 	& 	&  &\tabdarrow[?] \\ 
	 B & 	& \tabrarrow  &&\tabrarrow[?]	&  \tabrarrow	&  \\ 
\end{tabular} 
\end{minipage}
\hspace{0.5cm}
$\Longrightarrow$
\hspace{0.5cm}
\begin{minipage}{7cm}
	\begin{tabular}{c||ccc|ccc}
		&C	&A 	& C	& b	& C	& A \\ \hline
		\hline B & 	&  	& 	&\tabsearrow[]\tabrarrow[*]	&  \tabrarrow	&  \\ 
		\hline  c &\tabsearrow[]\tabrarrow[*]	&  \tabrarrow	&*	&  	&\tabrarrow[]\tabsearrow[+]	&  \\ 
		\hline a & 	&\tabrdarrow[+] 	& \tabdarrow[] \tabsearrow 	& 	&  &\tabdarrow[+] \\ 
		B & 	& \tabrarrow  &&\tabrarrow[+]	&  \tabrarrow	&  \\ 
	\end{tabular} 
\end{minipage}
		
In der linken Hälfte sind also alle Zuordnungen möglich und, da die insgesamt möglichen Zuordnungen sich aus der $\wedge$-Verknüpfung beider  Matrizen ergeben, sind -- wie wir bereits wissen --  alle Zuordnungen abgesehen von der zwischen dem empfangenen c und dem mittleren C möglich.

Man kann dieses Verfahren optimieren, indem man nur die tatsächlich relevanten (im Bild nicht leeren) Felder speichert. Außerdem fällt auf, dass man während der Berechnung von Solvable$_{L}$ und Solvable$_{R}$ nur jeweils die letzte Zeile/Spalte benötigt, so dass man prinzipiell  alle  Matrixeinträge nacheinander ohne Lauf\-zeit\-ein\-bußen in $O(n)$-Spei\-cher berechnen kann. Allerdings benötigt man leider am Schluss alle Werte von beiden Funktionen zugleich, um entscheiden zu können, ob eine Zuordnung zu einer Lösung führt. 
Man könnte aber gleich eine Datenstruktur verwenden, die angibt, welche Zuordnungen insgesamt möglich sind, und dann während der  Berechnung von Solvable$_{L/R}$ alle ungültigen Zuordnungen streichen. Je nach dem wie gut diese Datenstruktur komprimiert, verringert sich der Speicherverbrauch, möglicherweise aber zum Preis erhöhter Rechenzeit %was allerdings mit Rechenzeit bezahlt werden muss. 
(ein speichermäßig optimaler Fall wären zum Beispiel die Eingabedaten selbst). Als Kompromiss scheint sich eine verkettete Liste von möglichen Intervallen oder eine Baumstruktur zu eignen, was aber in dieser Arbeit nicht weiter untersucht wird. %Dafür scheint man zwar immer noch $O(n^2)$-Speicher zu benötigen (man muss $n_L$ unterschiedliche 
 

%Allerdings benötigt man weiteren Speicher, um das Ergebnis, welche Sendeereignisse nun für ein Empfangsereignis möglich sind zu speichern. Nimmt man für jedes Empfangsereignis eine naive Liste oder Hash, benötigt man insgesmt wieder $O(n^2)$-Speicher. Man könnte aber auch Intervalle verwenden und zusätzlich nur speichern, ob tatsächlich jedes Sendeereignis innerhalb des Intervalls möglich ist. Dadurch verliert man zwar Informationen, kommt aber mit $O(n_L)$ aus. Eine andere Möglichkeit wäre es, die Intervalle in einer Art Baumstruktur zu speichern, womit man vermutlich $O(n_L\log n_L)$ erreichen könnte.

%\begin{picture}(10,10)(0,0)
%	\setlength{\unitlength}{1cm}
%	\multiput(0,0)(1,0){8}{\line(0,1){5}}
%	\multiput(0,0)(0,1){6}{\line(1,0){7}}
%	\put(0.5,1.5){C}
%\end{picture}
%
\pagebreak[0]
\section{Allgemeiner Fall}
Nun betrachten wir den allgemeinen Fall von uSRC*, in dem es auch mehr als zwei Logs geben darf.
Mit denselben Argumenten wie im vorherigen Abschnitt folgt auch hier, dass eine konsistente und eindeutige GA genau dann existiert, wenn man die Empfangsereignisse mit $r_1, ..., r_{n_R}$ durchnummerieren kann, so dass für $r_i, r_j \in R_k$ mit $i<j$ gilt $r_i \prec_k r_j$ und, falls $A(r_i), A(r_j) \in S_l$ sind, $A(r_i) \prec_l A(r_j)$ (vergleiche wieder das Lemma \ref{lem:GROtoGTO}).

Nunmehr werden die Ereignisse in jedem Log aber durch eine beliebige Zuordnung nicht mehr in zwei Hälften aufgeteilt, sondern ein solcher Schnitt kann nur noch durch $e_1, \ldots, e_{n_L}$ Ereignisse mit $e_i \in L_i$ erfolgen. 

Man sieht aber leicht, dass es eine Lösung für die rechte Hälfte eines Schnitts genau dann gibt, wenn es in dieser Hälfte ein erstes Empfangsereignis $r_1$ mit einem zugehörigen Sendeereignis gibt, so dass die Menge der Ereignisse rechts von diesen beiden und den Ereignissen des Schnitts wiederum lösbar ist %für die Ereignisse in der rechten Hälfte eines neuen Schnitt, der mit diesen beiden Ereignissen sowie den Ereignissen des vorherigen Schnitts für die anderen $n_L -2 $ Logs durchgeführt wird, wiederum eine Lösung existiert. 
(da dort dann $r_2, \ldots, r_{n_R}$ sortierte Empfangsereignisse existieren müssen, so dass $r_1, \ldots, r_n$ ebenfalls eine Lösung bildet).

Ein Beispiel hierzu ist: 

$
\begin{array}{cccccccc}
\ldots & e_1 &  \ldots  \\
\ldots & e_2 & S & \ldots & S & e'_2 & \ldots\\
\ldots & e_3 & S & \ldots & S & e'_3 & \ldots\\
\ldots & e_4 &  \ldots  \\
\end{array}
$

Dabei sind die beiden neuen, einander zugeordneten Ereignisse mit $e'_2$ und $e'_3$ bezeichnet und $S$ steht für ein beliebiges Sendeereignis. Ist nun die rechte Hälfte des Schnitts $e_1, e'_2, e'_3, e_4$ lösbar, so ist es offensichtlich auch die rechte Hälfte des Schnitts $e_1, e_2, e_3, e_4$. Umgekehrt, existieren in keinem Log zwei solche neuen Ereignisse, so ist die rechte Hälfte eben nicht lösbar.

Formuliert man dies wieder als rekursive Funktion ergibt sich:

\begin{tabular}{rllcl}
	Solvable$_{R}$ & \multicolumn{3}{l}{$(e_1, e_2, \ldots, e_{n_L})$} \\
	& =& \multicolumn{2}{l}{$(\nexists i: \exists r \in R_i \text{ mit } e_i \prec_i r$}\\
	&  & $\vee ( \exists k, l, e'_1, e'_2, \ldots, e'_{n_L}$, so dass: && $e'_i \in L_i$ \\
	&  &   & $\wedge$&$ e_i = e'_i$ $\forall i$ mit $i \neq k$, $i \neq l$\\
	&  &   & $\wedge$&$ e_k \prec_k e'_k \wedge e_l \prec_l e'_l$\\
	&  &   & $\wedge$&$  P(e'_k) = P(e'_l)$\\
	&  &   & $\wedge$&$ D(e'_k) \neq D(e'_l)$\\
	&  &   & $\wedge$&$ \nexists i: \exists r \in R_i \text{ mit } e_i \prec_i r \prec_i e'_i$\\
	&  &   & $\wedge$&$ \text{Solvable}_R$ $(e'_1,e'_2, \ldots, e'_{n_L}))$\\
\end{tabular}

Und analog für die linke Hälfte:

\begin{tabular}{rllcl}
	Solvable$_{L}$ & \multicolumn{3}{l}{$(e_1, e_2, \ldots, e_{n_L})$} \\
	& =& \multicolumn{2}{l}{$(\nexists i: \exists r \in R_i \text{ mit } r \prec_i e_i$}\\
	&  & $\vee ( \exists k, l, e'_1, e'_2, \ldots, e'_{n_L}$, so dass: && $e'_i \in L_i$ \\
	&  &   & $\wedge$&$ e_i = e'_i$ $\forall i$ mit $i \neq k$, $i \neq l$\\
	&  &   & $\wedge$&$ e'_k \prec_k e_k \wedge e'_l \prec_l e_l$\\
	&  &   & $\wedge$&$ P(e'_k) = P(e'_l)$\\
	&  &   & $\wedge$&$ D(e'_k) \neq D(e'_l)$\\
	&  &   & $\wedge$&$ \nexists i: \exists r \in R_i \text{ mit } e'_i \prec_i r \prec_i e_i$\\
	&  &   & $\wedge$&$ \text{Solvable}_L$ $(e'_1,e'_2, \ldots, e'_{n_L}))$\\
\end{tabular}


Offenbar gibt es maximal $n^{n_L}$ mögliche Parameter und $n_L^2$ Werte für $k$ und $l$, so dass sich die Funktionen in $O(n_L^2 \cdot n^{n_L})$ mit $O(n^{n_L})$-Speicher berechnen lassen. (Die $e'_i$ lassen sich für jedes Log vorberechnen.)

Damit $r$ und $s$ mit $P(r) = P(s)$ einander zugeordnet werden können, benötigt man wieder zumindest $e_1, \ldots, e_{n_l}$ Ereignisse, für die gilt $e_i = r$ und $e_j = s$ für ein $i, j$ sowie $\text{Solvable}_L(e_1, \ldots, e_{n_l}) \wedge \text{Solvable}_R(e_1, \ldots, e_{n_l})$.

Im Gegensatz zum vorherigen Abschnitt ist diese Bedingung aber nicht mehr hinreichend, da zu den Ereignissen des Schnittes $e_1, \ldots, e_{n_L}$ nun Empfangsereignisse gehören können, zu denen es keine Sendeereignisse gibt. Es muss daher für jedes Empfangsereignis in der Schnittmenge  auch ein passendes Sendeereignis in ihr geben, was man folgendermaßen formulieren kann: Ist $R' = R \cap \{e_1, \ldots, e_{n_L}\}$ und $S' = S \cap \{e_1, \ldots, e_{n_L}\}$, so muss es eine Menge $S'' \subseteq S'$ geben, so dass %$|S''| = |R'|$ ist und 
für jedes $t \in \packetTypSet$ gilt $|\{r \in R'|P(r) = t\}| = |\{s \in S''|P(s) = t\}|$. 

Dabei spielt die Reihenfolge keine Rolle (denn im Schnitt sind alle Ereignisse gleichzeitig und früher bzw. später als die Ereignisse in den beiden Hälften), so dass diese Bedingung mit einem geeigneten Hash in $O(n_L)$ überprüft  werden kann. Für zwei Ereignisse gibt es offenbar $O(n^{n_L-2})$ mögliche Schnitte, welche diese enthalten, so dass man mit den Ergebnissen von Solvable$_{L/R}$ für zwei Ereignisse in $O(n_L\cdot n^{n_L-2})$ überprüfen kann, ob die Zuordnung möglich ist. Insgesamt kann man dann also alle Zuordnungen in $O(n_L^2\cdot n^{n_L} + n_L \cdot  n^{n_L}) =  O(n_L^2\cdot n^{n_L})$ berechnen. Die Berechnung der eigentlichen Zuordnung aus den Matrizen von Solvable$_{L/R}$ spielt also bei der Laufzeit asymptotisch keine Rolle. Es könnte aber  aus Geschwindigkeitsgründen trotzdem wünschenswert sein, den Algorithmus ohne eine solche Nachberechnungsphase zu implementieren, indem man ähnlich wie im vorherigen Abschnitt  während der Berechnung von Solvable$_{L/R}$ aus einem Set der möglichen Zuordnungspaare alle als ungültig erkannten Paare streicht. Auch die dynamische Programmierung ist weiterhin möglich, indem man die Werte in einem $n_L$-dimensionalen Hyperwürfel speichert und für jeden Würfeleintrag alle zweidimensionalen Ebenen scannt, die diesen Eintrag enthalten.



Für größere $n_L$ lässt sich dieses Verfahren zwar nicht mehr in realistischer Zeit durchführen, trotzdem ist es um einiges schneller als das naive Durchprobieren aller Kombinationen, welches exponentiell zu $n$ statt $n_L$ wäre.
Eine Möglichkeit zur Optimierung, könnte es sein, zuerst ein anderes und schnelleres, aber nicht fehlerfreies,  Verfahren (z.B.: die Heuristik aus Kapitel \ref{Heuristik}) zu verwenden, um die möglichen Lösungsmengen einzuschränken. Dies wird hier aber nicht weiter betrachtet. %Dann kann man versuchen, den Algorithmus dieses Kapitels auf die verkleinerten Teilmengen anzuwenden. 



Außerdem kann man den Algorithmus auch erweitern, um SRC* statt uSRC* zu lösen.  Dazu kann man prinzipiell entweder versuchen in jedem Funktionschritt mehrere Empfangsereignisse zuzuordnen (was die Laufzeit um einen Faktor von $2^{(n_L-1)}$ verlangsamt) oder man wandelt das SRC* in ein uSRC* Problem um, indem man jedes Sendeereignis $S$ eines bestimmten Typs durch $2n_L$-Sendeereignisse $S_1 S_2 \ldots S_{2n_L}$ ersetzt. Ersetzt man dann noch jedes Empfangsereignis $r \in R_i$ mit $P(r)=P(s)$ durch $r_i r_{2{n_L}-i+1}$, wobei $P(S_j) = P(r_k) \Leftrightarrow j=k$ gelten solle, so kann jedes neue Sendeereignis nur von genau einem Knoten empfangen werden. Da in keinem Log ein einzelnes Sendeereignis mehrmals empfangen werden darf, ist damit das SRC*-Problem auf uSRC* reduziert.\footnote{Inwiefern sich diese Verdopplung der Zahl der Empfangsereignisse und die ">Ver$n_L$fachung"< der Sendeereignisse auf die Laufzeit auswirkt, müsste genauer untersucht werden. Das einfache Ersetzten von $n$ durch $n_L\cdot n$ in der O-Notation würde die Laufzeit mit dem Faktor $n_L^{n_L}$ multiplizieren, was schlechter ist als eine Modifikation von Solvable$_{L/R}$.}

\chapter{Zusammenfassung}
\label{chap:summary}
% wenn man in der Forschung bestimmte Hypothesen über das Verhalten von Netzwerken experimentell überprüfen möchte oder wenn man in der Industrie  auftretende Fehler untersuchten muss. Ein anderes Beispiel ist der LHC, bei dem aus den Aufnahmen, welche durch die einzelnen Detektoren entstanden und versenden wurden, berechnete werden muss, ob sie alle das gleiche oder unterschiedliche Teilchen gesehen haben. %und den berechnet  dem zeitlichen Ablauf \\%, wie welcher Knoten welchen anderen beeinflusst hat, sei 
%Es könnte auch passieren, dass jemand, während der Benutzung einer P2P-Chatsoftware (z.B.: Skype) ermordet wird, dann könnte man versuchen, aus den Ereignissen im Netzwerk den genauen Todeszeitpunkt zu ermitteln und die Zahl der Verdächtigen einzuschränken.

In dieser Arbeit wurde das Problem des Findens von möglichen Zuordnungen zwischen Sende- und Empfangsereignissen %in beliebigen Logs 
untersucht. Dazu wurden zuerst untere Grenzen für die Laufzeit aller Algorithmen, welche diese Zuordnungen ermitteln können,  hergeleitet und anschließend zwei entsprechende Algorithmen präsentiert.

Die Komplexitätsbetrachtungen haben gezeigt, dass alle drei der hier behandelten Probleme (SRC, pSRC und uSRC) NP-vollständig sind. Dazu wurde das für seine NP-Vollständigkeit bekannte X3C-Problem zuerst auf uSRC reduziert und der  dadurch entstehende Spezialfall von uSRC wiederum zu einem SRC-Problem umgewandelt. Anschließend wurden noch zwei Reduktionen von SRC und pSRC auf das jeweils andere Problem beschrieben.

Anschließend wurde ein aus der Literatur (\cite{WhoSaidThat}, \cite{Marold}) bekannter Algorithmus untersucht, von dem vermutet wurde, dass er pSRC in Polynomialzeit löst. Mittels Gegenbeispielen ließ sich aber zeigen, dass es sich nur um eine Heuristik handelt, die keine exakte Lösung finden kann. Nichtsdestotrotz wurden einige Spezialfälle, bei denen die Zahl der vorhandenen  Logs stark eingeschränkt wurde, entdeckt, die zu einem sinnvollen Ergebnis führen. %bei denen das Ergebnis sinnvoll ist.

Danach wurde aus einer neuen Definition für die korrekte Lösung ein alternativer Algorithmus entworfen, der uSRC* (eine Verallgemeinerung von uSRC) exakt löst. Obwohl dieser Algorithmus eine exponentielle Laufzeit besitzt, wurde gezeigt, dass er um einiges schneller ist, als das naive Durchprobieren aller Lösungen. Er wurde dabei zuerst für den Spezialfall zweier Logs in rekursiver und iterativer Form beschrieben und anschließend verallgemeinert. 

%Im letzten Kapitel \ref{chap:summary} wurde eine Zusammenfassung geschrieben (<- wohl unnötig??)

Für die zukünftige Forschung in diesem Gebiet dürfte es vor allem interessant sein, nach schnelleren Lösungsalgorithmen zu suchen sowie die Probleme zu verallgemeinern.

Man könnte beispielsweise versuchen, die beiden Algorithmen dieser Arbeit zu kombinieren.
Da die Heuristik bekanntermaßen keine möglichen Zuordnungen ausschließt (\cite{WhoSaidThat}), kann man mit ihr den Lösungsraum verkleinern. Wendet man dann den exakten Algorithmus auf diesen verkleinerten Lösungsraum an, kann man womöglich trotz dessen exponentieller Laufzeit schnell die korrekte Lösung finden.

Desweiteren enthalten die Logs auch zusätzliche Informationen, nämlich Zeitstempel, die hier vollständig ignoriert wurden. Diese basieren auf -- im allgemeinen nicht synchronisierten -- physikalischen Uhren. In vielen Fällen kann man jedoch eine maximale Abweichung der Uhren voneinander angeben (\cite{Lamport}), so dass von Anfang an für eine Zuordnung nur die Ereignisse eines gewissen Intervalls möglich sind. Prinzipiell scheint es zudem auch möglich, aus einer teilweisen Lösung %einigen eindeutig zugeordneten Sende- und Empfangsereignisse 
zu mehreren Zeitpunkten die exakte zeitliche Abweichung zwischen allen Uhren zu berechnen. Daraus könnte man eine (womöglich nicht-lineare) Funktion konstruieren, welche die Zeiten aller vorhandenen Uhren ineinander umrechnet (\cite{TimeSync}), woraus  man eine Lösung für weitere Bereiche der Logs ermitteln kann.

%TODO: auf der leitung abhören?

%(Man könnte natürlich bereits eingeschränkte Vektoruhren an den Algorithmus geben, eingeschränkt mittels eventuell zusätzlich verfügbaren Informationen. Verfügt beispielsweise jeder Sender/Empfänger über eine physikalische Uhr, kann man diese vor einem Experiment synchronisieren und für die Zeit der Aufzeichnung davon ausgehen, dass die auf den physikalischen Uhren basierenden Zeitstempel bei gleichzeitigen kleiner $\epsilon$ sein müssen. Ein Wert von $\epsilon = 1 \min$ scheint für ein stundenlanges Experiment realistisch zu sien)

Bei allen Untersuchungen in dieser Arbeit wurde vorausgesetzt, dass es keine Über\-trag\-ungs- oder Ausbreitungsverzögerung gibt und jede gesendete Nachricht unmittelbar beim Empfänger ankommt. %en ist. 
Dies gilt sicherlich für LANs, in größeren Systemen lassen sich diese Verzögerungen jedoch nicht mehr ignorieren. Hierzu sollte man versuchen entsprechende allgemeinere Algorithmen zu entwickeln und die Komplexität des so verallgemeinerten Problems analysieren. \footnote{Das hier bezüglich der Heuristik präsentierte Gegenbeispiel würde im allgemeinen Fall nicht funktionieren.}%Vermutlich ist die Verallgemeinerung auch NP-vollständig, dies darf jedo. Das für die Heuristik vorgebrachte Gegenbeispiel.}

%Eine Verallgemeinerung mit beliebigen Verzögerungen könnte sich auch in der fernen Zukunft, wenn extrasolare Kolonien gegründet wurden, als sehr bedeutsam erweisen, beispielsweise in juristischer Hinsicht:  %könnten solche Algorithmen auch in Gerichtsverhandlungen eine wichtige, juristische Rolle einnehmen:
%Angenommen auf Epsilon Eridani wird ein neues Verfahren zur Konstruktion von Warptriebwerken entwickelt und im dortigen Patentamt patentiert. Welche Auswirkungen hat dies auf die Besatzung eines Raumschiffs, welche von % auf ihrem Weg 
%von Alpha Centauri zum Sirius reist? Könnten sie für eine Patentverletzung verklagt werden, wenn sie das Patent nicht kannten, weil es für sie physikalisch unmöglich war, es zu kennen? Oder wenn zwar eine auf Quantenverschränkung basierendes Überlichtkommunikation erfunden würde, sie aber an Bord ihres Schiffs kein entsprechendes Gerät besitzen?


 %Koordination 

\appendix
\chapter{Beweise für Kapitel Komplexität}
\section{Eindeutige Empfänger und keine Senderambivalenz (uSRC)}
In diesem Abschnitt des Anhangs werden die im Abschnitt \ref{section:uniqueReceiver} skizzierten Beweise im Detail vorgestellt, wodurch gezeigt wird, dass X3C auf das Finden einer konsistenten und eindeutigen GA reduziert werden kann. 

Die Notation von X3C und die Definition der Logs, auf die das Problem reduziert wurde, kann man folglich dort nachlesen.

\begin{plem}{\ref{lem:match=>3set}}\label{proof:match=>3set}
Existiert eine Lösung für uSRC, so existiert eine Lösung für X3C.
\end{plem}
\begin{proof}
	Angenommen es existiert eine konsistente und eindeutige GA $A$. \\
	Da $A$ eindeutig ist, gilt für alle $r_1, r_2 \in R$ mit $A(r_1) = A(r_2)$, dass $r_1 = r_2$ ist, beziehungsweise dass für $r_1 \neq r_2$ dementsprechend $A(r_1) \neq A(r_2)$ gilt.
	
	Betrachten wir nun die Zuordnung der gesendeten und empfangenen Ereignisse vom Typ $X$: \\
	Zur Vereinfachung des Formalismus heiße $x \in L_i \neq L_0$ mit $P(x) = X$ ab sofort $x^i$ (eindeutig, da es in jedem Log $L_i$ nur ein einziges solches Ereignis gibt)\\
	Offensichtlich gilt für jedes $x^i$, entweder $A(x^i) \prec \LTB$ oder $\LTB \prec A(x^i)$.\\
	Dann lassen sich die Logs nach dieser Eigenschaft aufteilen, wodurch zwei Indexmengen $I = \{i | A(x^i) \prec \LTB\}$ und $J = \{j |\LTB\prec A(x^j)\}$ definiert werden, für die  $I \cap J = \emptyset$ und $I \cup J = \{1, 2, \ldots, n_L\}$ gilt.
	
	Es existieren genau $n_L$ gesendete $X$ und $n_L$ empfangene $X$, die in jeweils unterschiedlichen Logs liegen, also folgt aus der Eindeutigkeit von $A$, dass für jedes gesendete $X$ ein Log in der entsprechenden Indexmenge liegt.
	Da es genau $\frac{m_T}{3}$ gesendete $X$ vor $\LTB$ gibt, muss $|I| = \frac{m_T}{3}$ sein und $|J| = n_L - \frac{m_T}{3}$.
	%Daraus folgt $|I| + |J| = n_L$ und 
	%$|I| = \frac{m_T}{3}$ und $|J| = n_L - \frac{m_T}{3}$
	
	
	Für jedes $r \in L_i$ mit  $i \in I$ und $P(r) \neq X$ gilt, $r \prec_i x^i$, also folgt aus der Konsistenz von $A$, dass  $A(r) \prec A(x^i) \prec \LTB$ gilt.
	Da sich nur $X$-se zwischen $\LTA$ und $\LTB$ befinden, also $P(s) = X$ für alle $s \in L_0$ mit $\LTA \prec s \prec \LTB$ gilt, folgt $A(r) \prec \LTA$. % für das $r$ aus der vorherigen Zeile.
	
	Seien $i, i' \in I$ und $r \in L_i$, $r' \in L_{i'}$ mit $P(r) = P(r') \neq X$ für diesen Absatz fest.\\
	Es gilt offensichtlich $P(A(r)) = P(r) = P(r') = P(A(r'))$ und $A(r), A(r') \prec \LTA$. \\
	Da vor $\LTA$ jeder Ereignistyp nur ein einziges Mal vorkommt, also $\forall t\neq X:|\{s \in L_0 | s \prec \LTA \wedge P(s) = t\}| = 1$ formal geschrieben, %für alle festen $t$ kann durch die Eindeutigkeit von $A$ auch nu
	folgt daraus $A(r) = A(r')$ und aus der Eindeutigkeit von $A$ folgt $r = r'$ und somit $i = i'$.
	
	Das heißt die Logs sind disjunkt bezüglich der Typen ihrer Ereignisse, also $\{P(r) \neq X | r \in L_i\} \cap \{P(r) \neq X| r \in L_j\} = \emptyset$ für $i,j \in I$ mit $i\neq j$.
	Da die Typen der Logs den Sets entsprechen, gilt $M_i \cap  M_j = \emptyset$ für die ursprünglichen Sets und $i,j \in I$ mit $i\neq j$.
	
%	Wie oben erwähnt existiert für jedes Empfangsereignis genau ein Sendeereignis in $L'_0$, was sich formal als $C(t) = |\{s \in L'_0 | P(s) = t\}$ für alle möglichen empfangenen Packettypen $t$ schreiben lässt.\\
%	Daraus folgt $A^{-1}: S \rightarrow L$ ist durch $A^{-1}(A(r)) = r$ wohldefiniert.
	
	Sei $\hat{L_i} = L_i \setminus \{x^i\}$.\\
	Aus $|\hat{L}_i| = 3$ und der Disjunktivität aller $\hat{L}_i$ untereinander bezüglich der Ereignistypen für alle $i$, folgt $|\bigcup_{i\in I} \hat{L}_i| = |\hat{L}_i|\cdot |I| = 3\cdot\frac{m_T}{3} = m_T$.\\
	%Da auch $|\{s \in L'_0 | s \prec \LTA\}| = m_T$ und $A(r) \prec \LTA$ für $r \in L'_i$ gilt, muss $\{A(r)| r \in L'_i\} = \{s \in L'_0 | s \prec \LTA\}$ gelten.\\
	%$A(r
	Da $P(r)\neq P(r')$ für $r \in \hat{L}_i \neq \hat{L}_j \ni r'$ gilt, ist $\bigcup_{i \in I} \{P(r) | r \in \hat{L}_i \} = \{1,2,\ldots,m_T\}$, woraus folgt $\bigcup_{i \in I} M_i = \{1,2,\ldots,m_T\}$.
	
	
	Setzt man nun $\{T_i\} = \{M_i | i \in I\}$, so besitzt man eine gültige Lösung für X3C.
	%Man kann auch die Sendeereignisse vor $\LTB$ zählen und erhält: $|\{s \in L'_0 | s \prec \LTB\}| = |\{s \in L'_0 | s \prec \LTA\}| + |\{s \in L'_0 | \LTA \prec s \prec \LTB\}| = m_T + \frac{m_T}{3} = \frac{4*m_T}{3}$\\
	%Daraus folgt für jedes Sendeereignis $s \in L'_0$ mit $s \prec \LTA$ ist das zugeordnete Empfangsereignis $A^{-1}(s) \in \bigcup_{i\in I} L_i$\\
\end{proof}

\begin{plem}{\ref{lem:match<=3set}}
	Existiert eine Lösung für X3C, so existiert eine Lösung für uSRC.% 3-Exactcoverproblems, so existiert eine eindeutige und konsistente GA $A$
	
	Zudem gibt es zwei Indexmengen $I$ und $J$ mit $I \cap J = \emptyset$ und $I \cup J = \{1, \ldots, n_L\}$, so dass für alle $r \in R_i =  L_i$ mit $i\in I$ gilt $A(r) \prec \LTB$ und für alle $r \in R_j = L_j$ mit $j \in J$ gilt $\LTB \prec A(r)$.
	
	%Weiterhin gilt $A(q) \prec A(r)$ für $q \in L_i, r \in L_{i'}$ mit $P(q) = P(r)$ und $i,i' \in I$ und $i < i'$, sowie $A(q) \prec A(r)$ für $q \in L_j, r \in L_{j'}$ mit $P(q) = P(r)$ und $j,j' \in J$ und $j < j'$. 
	Außerdem sind die Ereignisse innerhalb dieser Mengen von Logs nach Typ und jeweiliger Lognummer sortiert, das heißt, ist $k,k' \in I$ mit $k < k'$ oder $k,k' \in J$ mit $k < k'$, so gilt für alle $q \in L_k, r \in L_{k'}$ mit $P(q) = P(r)$, dass $A(q) \prec A(r)$ ist.
\end{plem}
\begin{proof}
	\label{proof:match<=3set}
	 Sei $\{T_i\} \subseteq \{M_i\}$ mit $T_i \cap T_j = \emptyset$ für $i \neq j$ und $\bigcup_i T_i = \bigcup_i M_i$ eine gegebene Lösung des Coverproblems.
	 
	 Dann existiert  ein $I$, so dass $\{T_i\} = \{M_i | i\in I\}$ gilt. Sei zudem $J$ = $\{1, \ldots, n_L  \} \setminus I$.
	 
	 Wir bezeichnen wie im vorherigen Beweis $r \in R_i$ mit $P(r) = X$ als $x^i$ und $\hat{L}_i = L_i \setminus x^i$.
	 
	 Es muss nun gezeigt werden, dass eine eindeutige GA $A$ mit folgenden Eigenschaften existiert:
	 \begin{itemize}
\item	 Für $i \in I$ muss $A(r) \prec \LTA$ für $r \in \hat{L}_i$ und zudem $\LTA \prec A(x^i) \prec \LTB$ sein.
\item	 Für $j \in J$ muss $\LTB \prec A(r) \prec \LTC$ für $r \in \hat{L}_j$ und zudem $\LTC \prec A(x^j)$ sein. 
\item	 Für $i,i' \in I$ mit $i<i'$ muss für alle $q \in L_i, r \in L_{i'}$ mit $P(q) = P(r)$: $A(q) \prec A(r)$ gelten.
\item	Für $j,j' \in J$ mit $j<j'$ muss für alle $q \in L_j, r \in L_{j'}$ mit $P(q) = P(r)$: $A(q) \prec A(r)$ gelten.
	\end{itemize}

	 Für die ersten beiden Eigenschaften muss man sich nur überzeugen, dass es in den angegebenen Bereichen genügend Sendeereignisse jedes Typs gibt, wodurch auch folgt, dass die entsprechende Abbildung eine GA darstellt:\mybreak
     Da die $T_i$ disjunkt sind, gibt es für jeden Typ $t$ mit $1 \leq t \leq m_T$ genau ein einziges $i$ und $r \in L_i$ mit $P(r) = i$.
	 Da für jedes $t$ auch ein $s \in L_0$ mit $P(s) = t$ und $s\prec \LTA$ existiert, existiert für alle $r \in L'_i$ mit $i \in I$ die geforderte Zuordnung.\mybreak
	 Es gilt zudem $|\bigcup_i T_i| = |\bigcup_i M_i|= m_T$, also ist $|I|=|\{T_i\}| = \frac{m_T}{3}$, da $|T_i| = 3$ für alle $i$ ist und die $T_i$ disjunkt sind. 
	 Daraus folgt $\{x^i|i \in I\} = |I| =  \frac{m_T}{3} = |\{x \in L_0 | P(x) = X \wedge \LTA \prec x \prec \LTB\}|$, weshalb es für die geforderten Zuordnungen von $I$  genügend Sendeereignisse gibt.
	 
	 
	 Betrachten wir nun die Zuordnungen für die durch $J$ festgelegten Logs:
	 Für jeden Typ $t$ existieren insgesamt $C(t)$ Empfangsereignisse. Da eines dieser Ereignisse in $\bigcup_{i\in I} L_i$ enthalten ist, muss $|\{j \in J | \exists r \in L_j: P(r) = t\}| = C(t) -1 $ sein.\mybreak%ist $|\{L_j | \exists r \in L_j: P(r) = t\}| = C(t) -1$, was genau 
	 Dies ist genau die Zahl der Sendeereignisse vom Typ $t$ in $L_0$ im Intervall zwischen $\LTB$ und $\LTC$ ist, also ist $|\{s \in L_0 | P(s) = t \wedge \LTB \prec s \prec \LTC\}| = |\{j \in J | \exists r \in L_j: P(r) = t\}|$ und es gibt genügend Sendeereignisse (da von jedem Typ maximal ein Ereignis in jedem Log $L_j$ sein kann).\mybreak
	 Schließlich gilt auch $|\{x \in L_0 | P(x) = X \wedge \LTC \prec x \}| = n_L  - \frac{m_T}{3} = |J|$, also existiert für jedes von einem Log aus $J$ empfangene $X$ ein entsprechendes Sendeereignis.\mybreak % im für $A$ verlanges Intervall.
	 Also existiert eine eindeutige GA $A$ mit den ersten beiden oben verlangten Eigenschaften.
	 
	 Die letzten beiden Eigenschaften folgen trivial daraus, dass die Sendeereignisse mit gleichem Typ in $L_0$ vor und nach $\LTB$ nur in Blöcken auftauchen. Gibt es also zwei $i,i' \in I$ mit $i<i'$ und $q \in L_i, r \in L_{i'}$ mit $P(q) = P(r)$, so dass gilt $A(r) \prec A(q)$, so kann man die Zuordnungen von $r$ und $q$ vertauschen, also eine neue GA $A'$ mit $A'(r) = A(q)$ und $A'(q) = A(r)$ definieren, die dann die Bedingung erfüllt (und offensichtlich ist $A'$ weiterhin konsistent, sofern es $A$ war).
	 	 
	 Nun ist nur noch zu zeigen, dass $A$ zusammen mit der festgelegten GTO $\prec =\prec_0$ tatsächlich konsistent ist, also dass aus $e_1 \prec_n e_2$ für $e_1, e_2 \in L_n$ folgt $A(e_1) \prec A(e_2)$.\mybreak
	 Für alle $s_1,s_2 \in L_0$ mit $s_1 \prec_0 s_2$ gilt $A(s_1) = s_1 \prec_0 s_2 = A(s_2)$ und somit wie erfordert $A(s_1) \prec A(s_2)$.\mybreak
	 Für $i \in I$ gilt: Ist $e_1, e_2 \in L_i$ mit $e_1 \prec_i e_2$ gegeben, so ist $P(e_1) < P(e_2)$. Also gilt $P(A(e_1)) < P(A(e_2))$. \mybreak
	 Offensichtlich gilt für alle $s_1, s_2 \in L_0$ mit $s_1, s_2 \prec \LTB$, dass $s_1 \preceq_0 s_2 \Leftrightarrow P(s_1) \leq P(s_2)$ gilt. 
	 Also folgt aus $P(A(e_1)) < P(A(e_2))$, dass $A(e_1) \preceq_0 A(e_2)$ gilt und somit mit der Bedingung der Eindeutigkeit, $A(e_1) \prec A(e_2)$.\mybreak
	 Für $j \in J$ gilt ebenfalls: Ist $e_1, e_2 \in L_j$ mit $e_1 \prec_j e_2$ gegeben, so ist $P(e_1) < P(e_2)$. Also gilt $P(A(e_1)) < P(A(e_2))$. 
	 Auch für alle $s_1, s_2 \in L_0$ mit $\LTB \prec s_1, s_2 \prec \LTC$ gilt offenbar $s_1 \preceq_0 s_2 \Leftrightarrow P(s_1) \leq  P(s_2) $.
	 Damit folgt $A(e_1) \preceq_0 A(e_2)$ und mit der Eindeutigkeit wieder  $A(e_1) \prec A(e_2)$.\mybreak
	 Somit ist $A$ konsistent.
	 %Da $T_i \cap T_j = \emptyset$ für $i \neq j$ ist, 
	 
	 Es existiert also eine eindeutige, konsistente GA als Lösung für uSRC. % für das Zuordnungsproblem.
	 
\end{proof}

\section{Keine Senderambivalenz (SRC)}
\label{app:src}
Hier werden nun detailliert die Beweise von Abschnitt \ref{section:uniqueSender} präsentiert, die zeigen, dass X3C auch auf das Finden einer konsistenten GA reduziert werden kann.

Die dazu konstruierten Logs kann man im Abschnitt \ref{section:uniqueSender} nachlesen, die Notation von X3C im Abschnitt \ref{section:uniqueReceiver}, außerdem wurden dort die Logs definiert, auf denen die Logs von \ref{section:uniqueSender} basieren.



Da für die Reduktion eine große Anzahl von Sendeereignissen nötig ist, durch die es kompliziert wird, eine GTO zu definieren, ersetzten wir die GTO, als Ordnungsrelation über den Sendeereignissen, durch eine Ordnungsrelation über den Empfangsereignissen: Diese heißt dementsprechend global receiving order (GRO), wird mit dem Symbol $\lessdot$ dargestellt und ist eine partielle Ordnungsrelation über $R \times R$. Sie entspricht der GTO, indem sie eine globale Reihenfolge der Ereignisse festlegt, allerdings eben die Reihenfolge der Empfangsereignisse anstatt der Sendeereignisse.


Wie bei der GTO gibt es auch für die GRO eine Konsistenzbedingung, bevor man diese aber formulieren kann, benötigt man den Begriff einer inversen GA:

\begin{lem}
	\label{lem:GA-1}
	Ist $A$ eine eindeutige GA, so existiert eine inverse GA $A^{-1}:R\cup A(R)\rightarrow R$, so dass für alle $r \in R$ gilt:
	\[A^{-1}(A(r)) = A^{-1}(r) = r\]
\end{lem}
\begin{proof}
	Es ist nur zu zeigen, dass die obige, implizite Definition von $A^{-1}$ widerspruchsfrei ist, also dass nach der Definition aus $e_1 = e_2$ tatsächlich folgt $A^{-1}(e_1) = A^{-1}(e_2)$.\\
	Für $e_1 = e_2 \in R$ ist dies offensichtlich der Fall.\\
	Sind $e_1, e_2 \in A(R) \subseteq S$, so gibt $r_1, r_2 \in R$ mit $e_1 = A(r_1)$ und $e_2 = A(r_2)$. \\
	Da $A$ eindeutig ist, ist $r_1 = r_2$ und somit $A^{-1}(e_1) = A^{-1}(A(r_1)) = r_1 = r_2 = A^{-1}(A(r_2)) = A^{-1}(e_2)$
\end{proof}

Nun kann man die Konsistenzbedingung für eine GRO angeben, die lautet:
\begin{lem}
	\label{lem:GROtoGTO}
	Ist eine eindeutige GA $A$ mit ihrer Umkehrfunktion $A^{-1}$ gegeben und erfüllt $\lessdot$ die Eigenschaft
	\[e_1, e_2 \in L_n \cap (R \cup A(R)): (e_1 \prec_n e_2 \Rightarrow A^{-1}(e_1) \lessdot A^{-1}(e_2))\]
	so ist $A$ konsistent. %existiert eine mit $A$ konsistente GTO $\prec$, so dass für $s_1 = A(r_1)$ und $s_2 = A(r_2)$ gilt $s_1 \prec s_2 \Leftrightarrow r_1 \lessdot r_2$. 
\end{lem}
\begin{proof}
%Betrachtet man die Definition von $A^{-1}$, nämlich, dass $A^{-1}(A(r)) = r$ und $A^{-1}(r) = r$ für alle $r\in R$ gilt, so sieht man leicht, dass die im Lemma genannte  Eigenschaft äquivalent zur Konjunktion dieser vier Bedingungen ist:
%\begin{itemize}
%	\item$r_1, r_2 \in R_n: r_1 \prec_n r_2 \Rightarrow r_1 \lessdot r_2$
%	\item$s_1 \in S_n, r_2 \in R_n: s_1 \prec_n r_2 \wedge s_1 = A(r_1) \Rightarrow r_1 \lessdot r_2$
%	\item$s_2 \in S_n, r_1 \in R_n: r_1 \prec_n s_2 \wedge s_2 = A(r_2) \Rightarrow r_1 \lessdot r_2$
%	\item$s_1, s_2 \in S_n: s_1 \prec_n s_2 \wedge s_1 = A(r_1) \wedge s_2 = A(r_2) \Rightarrow r_1 \lessdot r_2$
%\end{itemize}
%
Es wird mittels Induktion über die Zahl der nicht zugeordneten Sendeereignisse gezeigt, dass sich aus der GRO $\lessdot$ eine GTO $\prec$ konstruieren lässt, so dass das Paar $A, \prec$ konsistent ist:

Induktion über $|M| = |\{s \in S|\forall r: A(r) \neq s\}|$
	%In jedem Induktionsschritt sei dabei $L, S, R$ auf die für diesen Schritt relevanten Ereignisse beschränkt.
	
	
	Induktionsanfang $|M|=0$: \\
	Dann ist $A^{-1}$ eingeschränkt auf die Menge der Sendeereignisse (Also $A^{-1}: S \rightarrow R$) eine bijektive Abbildung zwischen allen Sende- und allen Empfangsereignissen, und somit lässt sich $\prec$ wohldefinieren als: Für $s_1, s_2 \in S$ gilt $s_1 \prec s_2$ genau dann falls $A^{-1}(s_1) \lessdot A^{-1}(s_2)$ erfüllt ist. \mybreak
	Äquivalent dazu ist folgende Formulierung: Für $r_1, r_2\in R$ sei $A(r_1) \prec A(r_2) \Leftrightarrow r_1 \lessdot r_2$
	%Da $A$ eindeutig ist, lässt sich $\prec$ durch $s_1 \prec s_2 \Leftrightarrow r_1 \lessdot r_2$ für alle $s_1=A(r_1)$ und $s_2 = A(r_2)$ wohldefinieren.
	
	Damit erhält man tatsächlich eine Ordnungsrelation:\mybreak
	Da $A$ eindeutig und $\lessdot$ irreflexive ist, gibt es keine $r_1, r_2$ mit $A(r_1) = A(r_2)$ und $r_1 \lessdot r_2$, also ist $\prec$ irreflexive.\mybreak
	Aus $A(r_1) \prec A(r_2)$ folgt $r_1 \lessdot r_2$ und, da $\lessdot$ antisymmetrisch ist, folgt daraus, dass nicht $r_2 \lessdot r_1$ gilt und somit auch nicht $A(r_2) \prec A(r_1)$. Daher ist $\prec$ ebenfalls antisymmetrisch.\mybreak
	Gilt $s_1 \prec s_2$ und $s_2 \prec s_3$, so gibt es eindeutige $r_1, r_2, r_3 \in R$ mit $r_1 \lessdot r_2$ und $r_1 \lessdot r_3$ sowie $s_1 = A(r_1)$, $s_2 = A(r_2)$ und $s_3 = A(r_3)$. Da $\lessdot$ transitiv ist, gilt $r_1 \lessdot r_3$ und somit $s_1\prec s_3$, weshalb auch $\prec$ transitiv ist.
	
	Gilt $e_1 \prec_n e_2$ so ist $A^{-1}(e_1) \lessdot A^{-1}(e_2)$, woraus folgt $A(A^{-1}(e_1)) \prec A(A^{-1}(e_2))$\\
	Ist $e_1 \in R$, so ist $A^{-1}(e_1) = e_1$ und $A(A^{-1}(e_1)) = A(e_1)$. \\
	Ist dagegen $e_1 \in S$, so ist $A(A^{-1}(e_1)) = e_1 = A(e_1)$.\\
	Entsprechend ist auch immer $A(A^{-1}(e_2)) = A(e_2)$ also folgt aus  $e_1 \prec_n e_2$, dass $A(e_1) \prec A(e_2)$ gilt und das Paar $(\prec,A)$ konsistent ist.
	
	Also ist $A$ konsistent.
	
	
%	
	%Die letzten beiden Bedingungen sind erfüllt, da es keine $s_1$ mit $A(r) \neq s_1$ für alle $r\in R$ gibt.\\
	%Außerdem lässt sich eine Ordnungsrelation mit dieser Definition offensichtlich in Polynomialzeit berechnen. (trivial in $O(|R|^2 + |S|^2)$, wenn man die Sendeereignisse von alle möglichen Paare von Empfangsereignisse in einer zuvor gelöschten Hashmatrix speichert)
	
	
	
	Induktionsschritt: $|M|\rightarrow |M|+1$\\
	Sei $s \in S_n$ mit $A(r)\neq s$ für alle $r\in R$ ein Sendeereignis, welches niemals empfangen wurde.
	Sei $\bar{L} = L \setminus \{s\}$ die Menge der Ereignisse ohne dieses $s$. Die GA $A$ eingeschränkt auf $\bar{L}$ heiße $\bar{A}$ und ist offensichtlich eindeutig, da die Einschränkung bloß die Abbildung $A(s) = s$ entfernt. Dementsprechend existiert eine Umkehrabbildung $\bar{A}^{-1}$.\\   %(entsprechend sei auch $\bar{S}, \bar{L_i}, \bar{a}
	Alle weiteren Bezeichner wie $\bar{S}$, $\bar{S}_n$, $\ldots$ seien analoge Einschränkungen von $S, S_n, \ldots$ %$\bar{

	Weiterhin erfüllt $\lessdot$ offenkundig die Bedingung, dass für $e_1, e_2 \in \bar{L}_n \cap (R \cup A(R)) \subset L_n \cap (R \cup A(R))$  mit $e_1 \prec_n e_2$ gilt $\bar{A}^{-1}(e_1) \lessdot \bar{A}^{-1}(e_2)$, da dies für $e_1, e_2 \in L_n \cap (R \cup A(R))$ gilt.\\
	Also existiert nach der Induktionsannahme eine GTO $\bar{\prec}$, so dass das Paar $A, \bar{\prec}$ konsistent ist, da $|\bar{M}| = |M|-1 < |M|$ ist.
	
	Wir definieren nun eine neue Ordnungsrelation $\prec$, für die erstmal gelte $a \prec b \Leftrightarrow a \bar{\prec} b$ für $a \neq s \neq b$\\
	Es lassen sich nun drei Fälle unterscheiden:
	\begin{enumcases}
		\item $s \prec_n e$ für alle $e \in \bar{L}_n$ \\
		Dann sei $s \prec e$ für alle $t \in \bar{S}$\\% mit $t\neq s$\\
		Daraus folgt automatisch $A(s) \prec A(e')$ für alle $e' \in \bar{L}_n$ mit $s \prec_n e'$
		
		\item $e \prec_n s$ für alle $e \in \bar{L}_n$ \\
		Dann sei $t \prec s$ für alle $t \in \bar{S}$\\% mit $t\neq s$\\
		Daraus folgt automatisch $A(e') \prec A(s)$ für alle $e' \in \bar{L}_n$ mit $e' \prec_n s$
		
		
		\item Es gibt $e \prec_n s \prec_n e'$ mit $e,e' \in \bar L_n$ \\
		Sei $e$ maximal und $e'$ minimal, also es gebe keine $f \in \bar L_n$ mit $e \bar\prec_n f \bar\prec_n s$ oder $s \bar\prec_n f\bar\prec_n e'$\\
		Dann sei $A(e) \prec s \prec A(e')$.\\
		Außerdem sei $A(f) \prec s$ für alle $ f \in \bar L$ mit $A(f) \bar{\prec} A(e)$ und $s \prec f'$ für alle $f' \in \bar L$ mit $A(e') \bar{\prec} A(f')$\\
		Daraus folgt: Ist ein beliebiges $f \in  L_n$ mit $f \prec_n s$ gegeben, so gilt $A(f) \prec A(s)$ und ist ein beliebiges $f'$ mit $s \prec_n f'$ gegeben, so gilt $A(s) \prec A(f')$
	\end{enumcases}
	
	In jedem Fall ist das definierte $\prec$ mit $A$ offensichtlich konsistent, da $\bar{\prec}$ konsistent ist und auch das eingefügte $s$ die Konsistenzbedingung erfüllt.
	Es ist auch wohldefiniert, da in $\prec$ bisher keine Aussagen über $s$ getroffen wurden und die neuen Bedingungen widerspruchsfrei sind.
	
	Zu zeigen ist nur noch, dass $\prec$ auch tatsächlich eine Ordnungsrelation ist:\mybreak
	Irreflexiv und antisymmetrisch ist trivial, wenn man bedenkt, dass $\bar{\prec}$ eine Ordnungsrelation ist und in allen drei Fällen nur irreflexive und antisymmetrische Beziehungen hinzugefügt wurden.\mybreak
	Auch die  Transitivität ist in den ersten beiden Fällen offensichtlich, aber für den letzten muss man diese drei Möglichkeiten betrachten: ($e, e' \in L_n$ seien dabei wie oben das maximale und minimale Ereignis mit $e \prec_n s \prec_n e'$, und $s_1, s_2$ seien in $\bar{S}$)
	\begin{enumcases}
		\item $s \prec s_1$ und $s_1\bar{\prec} s_2$\\
		Ist $s_1 = A(e')$, so ist $A(e') \bar{\prec} s_2$ und somit $s \prec s_2$.\\
		Ansonsten ist $A(e') \bar{\prec} s_1 \bar{\prec} s_2$ und somit $A(e') \bar{\prec} s_2$ nach der Transitivität von $\bar{\prec}$, also gilt $s \prec s_2$
		\item $s_1 \prec s$ und $s \prec s_2$\\
		Es gilt entweder $s_1 \bar{\prec} A(e)$ oder $s_1 = A(e)$ sowie $A(e') \bar{\prec} s_2$ oder $A(e')=s_2$\\
		Aus $A(e) \bar{\prec} A(e')$ folgt somit $s_1 \prec s_2$
		\item $s_1 \bar{\prec} s_2$ und $s_2 \prec s$\\
		Ist $s_2 = A(e)$, so ist $s_1 \bar{\prec} A(e)$ und somit $s_1 \prec s$.\\
		Ansonsten ist $s_1 \bar{\prec} s_2 \prec A(e)$ und somit $s_1 \bar{\prec} A(e)$ nach der Transitivität von $\bar{\prec}$, also gilt $s_1 \prec s$
	\end{enumcases}
	
	Also ist die so definierte Ordnungsrelation $\prec$ tatsächlich eine GTO und zusammen mit $A$ auch konsistent.
\end{proof}


Damit können wir nun die im Abschnitt \ref{section:uniqueSender} nur zusammengefassten Beweise konkretisieren.
Das erste Lemma lautete:
\begin{plem}{\ref{lem:konsistent=eindeutig,eindeutig}}
	Jede konsistente Lösung von L' ist eindeutig.
\end{plem}

\begin{proof}
	\label{proof:konsisten=eindeutig,eindeutig}
%A14 a41 A13 a31 A12 a21  a   <->A12 A13 A14 
%A21 a12 A23 a32 A24 a42  a   <->A24 A23 A21
%A31 a13 A32 a23 A34 a43  a   <->A34 A32 A31
%A41 a14 A42 a24 A43 a34  a   <->A43 A42 A41


%A14 a41 A13 a31 A12 a21  a   <->A12 A13 A14 
%                    A21         a12         A23 a32 A24 a42  a   <->A24 A23 A21
%            A31                     a13     A32 a23 A34 a43  a   <->A34 A32 A31
%    A41                                 a14 A42 a24 A43 a34  a   <->A43 A42 A41
%

%        A14                 a41 A13 a31 A12 a21  a   <->A12 A13 A14 
%            A21 a12 A23 a32 A24 a42  a   <->A24 A23 A21
%A31 a13             A32 a23 A34 a43  a   <->A34 A32 A31
%A41 a14 A42             a24 A43 a34  a   <->A43 A42 A41


%A14 A13 A12 a41 a31 a21  a   <->A12 A13 A14 
%A21 A23 A24 a12 a32 a42  a   <->A24 A23 A21
%A31 A32 A34 a13 a23 a43  a   <->A34 A32 A31
%A41 A42 A43 a14 a24 a34  a   <->A43 A42 A41

%A12 A13 A14 a21 a31 a41  a  A12 A13 A14 | A12 A13 A14 
%A21 A23 A24 a12 a32 a42  a  A21 A23 A24 | A21 A23 A24
%A31 A32 A34 a13 a23 a43  a  A31 A32 A34 | A31 A32 A34
%A41 A42 A43 a14 a24 a34  a  A41 A42 A43 | A41 A42 A43


%    A12 A13 A14                           A12 A13 A14 a21 a31 a41  a          A12             A13 A14 | A12 A13 A14 
%        A21 A23 A24                                   A21             A23 A24 a12 a32 a42  a  A21 A23 A24 | A21 A23 A24
%            A31 A32 A34                                   A31                     A32         A34     a13 a23 a43  a  A31 A32 A34 | A31 A32 A34
%A41 A42 A43 a14 a24 a34  a  A41 A42 A43 |                     A41                     A42             A43


%  A' B' C' X' A' a' a A'  B' b' b B'  C' c' c C' X' x' x X' A'B'C' X'  

Angenommen $A$ ist nicht eindeutig, das heißt es gibt $r_1, r_2 \in R'$ mit $r_1 \neq r_2$ und $A(r_1) = A(r_2)$.
Daraus folgt $P(r_1) = P(r_2)$ und somit $r_1, r_2 \in R$, da es keine zwei Empfangsereignisse in $R' \setminus R$ gibt, die denselben Typ haben.
Außerdem haben offensichtlich alle Empfangsereignisse innerhalb desselben Log einen unterschiedlichen Typ, so dass  zwei Logs $L_i, L_j$ mit $i\neq j$ existieren, so  dass $r_1 \in L_i$ und $r_2 \in L_j$ ist.

%Seien zwei Empfangsereignisse  aus unterschiedlichen Logs  $L_i, L_j$ mit $i\neq j$ gegeben. 
Es gibt nun $e_{ij} \in L'_j, e_{ji} \in L'_i$, für die jeweils genau vier Sendeereignisse existieren, nämlich: $E^1_{ij}, E^2_{ij}, E^3_{ij}, E^4_{ij}$ sowie $ E^1_{ji}, E^2_{ji}, E^3_{ji}, E^4_{ji}$.

Diese sind nach der Definition der Logs folgendermaßen angeordnet: 

\[E^1_{ij} \prec_i E^2_{ij} \prec_i e_{ji} \prec_i r_1 \prec_i  E^3_{ij} \prec_i  E^4_{ij} \in L_i\]  
\[E^1_{ji} \prec_j E^2_{ji} \prec_j e_{ij} \prec_j r_2 \prec_j  E^3_{ji} \prec_j  E^4_{ji} \in L_j\]

Da es keine weiteren Sendeereignisse gibt, ist offensichtlich $A(e_{ij}) \in \{E^1_{ij}, E^2_{ij}, E^3_{ij}, E^4_{ij}\}$ und $A(e_{ji}) \in \{E^1_{ji}, E^2_{ji}, E^3_{ji}, E^4_{ji}\}$

\begin{enumcases}
	\item $A(e_{ij}) \in \{E^1_{ij}, E^2_{ij}\}$ und $A(e_{ji}) \in \{E^1_{ji},E^2_{ji}\}$ \\
	Aus $E^2_{ij} \prec_i e_{ji}$ folgt $E^2_{ij} = A(E^2_{ij}) \prec A(e_{ji}) \preceq_j E^2_{ji}$, also $E^2_{ij} \prec E^2_{ji}$\\
	Aus $E^2_{ji} \prec_j e_{ij}$ folgt $E^2_{ji} = A(E^2_{ji}) \prec A(e_{ij}) \preceq_i E^2_{ij}$, also $E^2_{ji} \prec E^2_{ij}$\\
	%Also $E^1_{ij} \prec E^2_{ji}$ und $E^1_{ji} \prec E^2_{ij}$
	Aber es kann nicht gleichzeitig $E^2_{ij} \prec E^2_{ji}$ und $E^2_{ji} \prec E^2_{ij}$ gelten.$\lightning$
	\item $A(e_{ij}) \in \{E^1_{ij},E^2_{ij}\}$ und $A(e_{ji}) \in \{E^3_{ji}, E^4_{ji}\}$\\
	Aus $r_2 \prec_j E^3_{ji}$ folgt $A(r_2) \prec A(E^3_{ji}) = E^3_{ji} \preceq_j A(e_{ji})$, also $A(r_2) \prec A(e_{ji})$\\
	Aus $e_{ji} \prec_i r_1$ folgt $A(e_{ji}) \prec A(r_1)$\\
	Also $A(r_2) \prec A(r_1)$ und somit $A(r_1) \neq A(r_2)$ $\lightning$
	\item $A(e_{ij}) \in \{E^3_{ij},E^4_{ij}\}$ und $A(e_{ji}) \in \{E^1_{ji}, E^2_{ji}\}$\\
	Symmetrisch zum vorherigen Fall
	\item $A(e_{ij}) \in \{E^3_{ij},E^4_{ij}\}$ und $A(e_{ji}) \in \{E^3_{ji}, E^4_{ji}\}$\\
	Mit $e_{ji} \prec_i E^3_{ij}$ folgt $E^3_{ji} \preceq_j A(e_{ji}) \prec A(E^3_{ij}) = E^3_{ij}$, also $E^3_{ji} \prec E^3_{ij}$.\\
	Mit $e_{ij} \prec_i E^3_{ji}$ folgt $E^3_{ij} \preceq_i A(e_{ij}) \prec A(E^3_{ji}) = E^3_{ji}$, also $E^3_{ij} \prec E^3_{ji}$.\\
	Aber es kann nicht gleichzeitig $E^3_{ij} \prec E^3_{ji}$ und $E^3_{ji} \prec E^3_{ij}$ gelten.$\lightning$
\end{enumcases}

Daraus folgt, dass die Annahme falsch war, und somit jede konsistente GA $A$ zu $L'$ auch eine eindeutige GA ist.
\end{proof}

Die beiden letzten  Lemmas diesen Abschnitts zeigen die Äquivalenz der Logs $L$ aus Abschnitt \ref{section:uniqueReceiver} und der Logs $L'$ aus Abschnitt \ref{section:uniqueSender}:
\begin{plem}{\ref{lem:konsistent=eindeutig,L'=>L!}}
Ist $A$ eine zu $L'$ konsistente GA, so ist $A$ eingeschränkt auf $L$ eine konsistente GA zu $L$.
\end{plem}
\begin{proof}
	\label{proof:konsistent=eindeutig,L'=>L!}
Sei ein konsistentes Paar $A, \prec$ gegeben.
Da $\prec$ eine Ordnungsrelation ist, ist die Einschränkung von $\prec$ auf $L$ ebenfalls eine.

Sei $L'' = L' \setminus L$ die Menge, der zu $L$ hinzugefügten Ereignisse.
Offensichtlich haben die in $L'$ hinzugefügten Ereignisse einen anderen Packettyp als alle Ereignisse in $L$, also  $P(e_1) \neq P(e_2)$ für $e_1 \in L, e_2 \in L''$. Daraus folgt, ist $e_1 \in L$ gegeben, so muss $P(A(e_1)) = P(e_1)$ sein und somit ist $A(e_1) \in L$. Daraus folgt, dass $A$ eingeschränkt auf $L$ eine Abbildung von $L$ nach $S$ ist (und nicht nach $S'$).

Dass $A$ eingeschränkt auf $L$ auch die anderen Eigenschaften einer konsistenten GA hat, ist ebenfalls trivial zu zeigen:
\[\forall s \in S': A(s) = s \Rightarrow \forall s \in S' \setminus L'': A(s) = s\]
\[\forall e \in L': P(e) = P(A(e)) \Rightarrow \forall e \in L' \setminus L'': P(e) = P(A(e))\]
\[\forall r \in R': N(r) \neq N(A(r)) \Rightarrow \forall r \in R' \setminus L'': N(r) \neq N(A(r))\]
$(\forall n \in N: \forall e_1, e_2 \in L'_n: (e_1 \prec_n e_2 \Rightarrow A(e_1) \prec A(e_2))) $\\
\hspace*{1cm} $\Rightarrow (\forall n \in N: \forall e_1, e_2 \in L'_n \setminus L'': (e_1 \prec_n e_2 \Rightarrow A(e_1) \prec A(e_2)))$
\end{proof}

\begin{plem}{\ref{lem:konsistent=eindeutig,L=>L'!}}
\label{proof:konsistent=eindeutig,L=>L'!}
	Existiert eine eindeutige, konsistente Lösung zu $L$, so gibt es eine Lösung für $L'$.
\end{plem}
\begin{proof}
Sei $A, \prec$ die eindeutige, konsistente Lösung für $L$ und $A'$ die im Beweisanfang von Lemma \ref{lem:konsistent=eindeutig,L=>L'!} definierte Abbildung.

Offensichtlich ist dieses $A'$ eindeutig, da es für alle $r_1, r_2\in R' \setminus R$ mit $A'(r_1) = A'(r_2)$ ein Tripel $m,i,j$ gibt, so dass  $A'(r_1) = A'(r_2) = E^m_{ij}$ und somit $r_1 = e_{ij} = r_2$ ist
%Für $r_1, r_2 \in R$ mit $r_1 \neq r_2$ ist $A'(r_1)\neq A'(r_2)$, da $A$ eindeutig ist.\\
%Für $r_1 \in R$ und $r_2 \in R' \setminus R$ ist natürlich $S \ni A(r_1) \neq A(r_2) \in S' \setminus S$


Außerdem ist $A'$ eine GA, da es alle unter der entsprechenden Definition \ref{def:GA} aufgeführten Eigenschaften erfüllt:

\begin{enumerate}
	\item $\forall s \in S': A'(s) = s$\\
	Dies ist trivial zu sehen
\item $\forall e \in L': P(e) = P(A'(e))$\\
Dies folgt daraus, dass $A$ eine GA ist und $P(e_{ij})= P(E_{ij})$ für alle $i,j$ gilt
\item $\forall r \in R': N(r) \neq N(A'(r))$\\
Dies folgt daraus, dass $A$ eine GA ist und, dass für $e_{ij}\in L'$ gilt $i \neq j$ sowie $e_{ij} \in L'_j$ und $E_{ij} \in L'_i$
\end{enumerate}

Um zu zeigen, dass $A'$ konsistent ist, muss eine Ordnungsrelation über den Ereignissen definiert werden. Leider ist es durch die vielen, nicht zugeordneten Sendeereignisse kompliziert direkt eine GTO anzugeben. Daher wird zuerst eine GRO $\lessdot$  definiert, welche die Empfangsereignisse in $L'_I$ und $L'_J$ getrennt nach Typ und Nummer des sie enthaltenden Logs sortiert:

Seien $r_1, r_2 \in R'$ gegeben. %Um diese Empfangsereignisse nun nach Indexmenge, Typ, Log und Reihenfolge zu sortieren, 
Dann gelte $r_1 \lessdot r_2$ genau dann wenn  eine der folgenden Bedingungen erfüllt ist (mindestens oder genau eine, macht dabei keinen Unterschied):

\begin{enumerate}
	\item $r_1 \in L'_i, r_2 \in L'_j$ mit $i \in I$, $j\in J$
	\item $r_1 \in L'_i, r_2 \in L'_{i'}$ mit $i,i' \in I$ und $B(r_1) < B(r_2)$
	\item $r_1 \in L'_i, r_2 \in L'_{i'}$ mit $i,i' \in I$ und $B(r_1) = B(r_2)$ sowie $i < i'$
	\item $r_1 \in L'_i, r_2 \in L'_{i'}$ mit $i,i' \in I$ und $B(r_1) = B(r_2)$ sowie $i = i'$ und $r_1 \prec_i r_2$
	\item $r_1 \in L'_j, r_2 \in L'_{j'}$ mit $j,j' \in J$ und $B(r_1) < B(r_2)$
	\item $r_1 \in L'_j, r_2 \in L'_{j'}$ mit $j,j' \in J$ und $B(r_1) = B(r_2)$ sowie $j < j'$
	\item $r_1 \in L'_j, r_2 \in L'_{j'}$ mit $j,j' \in J$ und $B(r_1) = B(r_2)$ sowie $j = j'$ und $r_1 \prec_j r_2$
\end{enumerate}


Geht man diese Bedingungen durch, sieht man leicht, dass $\lessdot$ tatsächlich eine Ordnungsrelation ist:\\
Für jedes Paar Empfangsereignisse $r_1,r_2$ kann genau eine Bedingung erfüllt sein, jede Bedingung ist selbst antisymmetrisch und keine andere Bedingung ist symmetrisch zu einer anderen, so dass $\lessdot$ insgesamt antisymmetrisch ist.\\
Außerdem ist es irreflexiv, da im Fall $r_1=r_2$ keine Bedingung erfüllt ist.\\
Außerdem ist $\lessdot$ transitiv, da jede der sieben Bedingungen einer transitiven Ordnungsrelation entspricht, wobei bei Gleichheit in dieser Relation die anderen Bedingungen zur Unterscheidung verwendet werden. Detaillierter lässt sich die Transitivität zeigen, indem man alle Möglichkeiten aufzählt: %wovon man sich leicht überzeugen kann: %, indem man alle Möglichkeiten durchgeht:\\
Sei $r_1, r_2, r_3 \in R'$ mit $r_1 \lessdot r_2$ und $r_2 \lessdot r_3$ gegeben. %Ist $r_1 \in L_i$ mit $i\in I$ und $r_3 \in L_j$ mit $j \in J$, so ist offensichtlich $r_1 \lessdot r_3$. \\
%Ist  $r_1 \in L_j$ mit $j \in J$ so folgt aus $r_1 \lessdot r_2$, dass $r_2 \in L_{j'}$ mit $j' \in J$ ist und aus $r_2 \lessdot r_3$ folgt $r_3 \in L_{j''}$ mit $j'' \in J$. Ist dagegen $r_3 \in L_{i''}$ mit $i'' \in I$, so folgt analog, dass $r_1 \in L_i$ und $r_2 \in L_{i'}$ mit $i,i'\in I$ liegen. Daraus folgt, dass nur die folgenden drei Fälle zu unterscheiden sind:
Aus $r_1 \lessdot r_2$ folgt, dass eine der obigen Bedingungen erfüllt ist: 
\begin{enumcases}
%		\item $r_1 \in L_i$ mit $i\in I$ und $r_3 \in L_j$ mit $j \in J$
%		
%		Dann ist offensichtlich ist offensichtlich $r_1 \lessdot r_3$
%		
	\item $r_1 \in L'_i, r_2 \in L'_j$ mit $i \in I$, $j\in J$.\\
	Dann folgt aus $r_2 \in L'_j$ und $r_2 \lessdot r_3$, dass für $r_2, r_3$ eine der letzten drei Bedingungen erfüllt ist und $r_3 \in L'_{j'}$ mit $j' \in J$ gilt. Also ist $r_1 \lessdot r_3$.
	
	\item $r_1 \in L'_i, r_2 \in L'_{i'}$ mit $i,i' \in I$ und $B(r_1) < B(r_2)$.\\
	Ist $r_3 \in L'_j$ mit $j \in J$, so ist offensichtlich $r_1 \lessdot r_3$ erfüllt.\\
	Ist dagegen $r_3\in L'_{i''}$ mit $i'' \in I$, so muss $r_2 \lessdot r_3$ durch eine der Bedingungen 2 bis 4 gegeben sein und es gilt $B(r_3) \geq B(r_2) > B(r_1)$.\\
	Also ist $B(r_1)<B(r_3)$ und $r_1 \lessdot r_3$.
	
	\item $r_1 \in L'_i, r_2 \in L'_{i'}$ mit $i,i' \in I$ und $B(r_1) = B(r_2)$ sowie $i < i'$.\\
	Ist $r_3 \in L'_j$ mit $j \in J$, so ist offensichtlich $r_1 \lessdot r_3$ erfüllt.\\
	Ist dagegen $r_3\in L'_{i''}$ mit $i'' \in I$, so muss $r_2 \lessdot r_3$ durch eine der Bedingungen 2 bis 4 gegeben sein.\\
	Ist $B(r_3) > B(r_2) = B(r_1)$ so ist $r_1 \lessdot r_3$ nach Bedingung 2.\\
	Ansonsten ist $B(r_3) = B(r_2) = B(r_1)$ und $i' \leq i''$, also $i < i' \leq i''$ und $r_1 \lessdot r_3$ nach Bedingung 3.
	
	\item $r_1 \in L'_i, r_2 \in L'_{i'}$ mit $i,i' \in I$ und $B(r_1) = B(r_2)$ sowie $i = i'$ und $r_1 \prec_i r_2$.\\
	Ist $r_3 \in L'_j$ mit $j \in J$, so ist offensichtlich $r_1 \lessdot r_3$ erfüllt.\\
	Ist dagegen $r_3\in L'_{i''}$ mit $i'' \in I$, so muss $r_2 \lessdot r_3$ durch eine der Bedingungen 2 bis 4 gegeben sein.\\
	Ist $B(r_3) > B(r_2) = B(r_1)$ so ist $r_1 \lessdot r_3$ nach Bedingung 2.\\
	Ist $B(r_3) = B(r_2) = B(r_1)$ und $i' < i''$, so ist $i = i' < i''$ und $r_1 \lessdot r_3$ nach Bedingung 3.\\
	Ist $B(r_3) = B(r_2) = B(r_1)$, $i' = i''$ und $r_2 \prec_i r_3$, so ist $r_1 \prec_i r_2 \prec_i r_3$ und somit $r_1 \lessdot r_3$ nach Bedingung 4.
	
	\item $r_1 \in L'_j, r_2 \in L'_{j'}$ mit $j,j' \in J$ und $B(r_1) < B(r_2)$.\\
	Dann muss $r_3\in L'_{j''}$ mit $j'' \in J$ sein, also ist $r_2 \lessdot r_3$ durch eine der Bedingungen 5 bis 7 gegeben. Also gilt $B(r_3) \geq B(r_2) > B(r_1)$ und $r_1 \lessdot r_3$.
	
	\item $r_1 \in L'_j, r_2 \in L'_{j'}$ mit $j,j' \in J$ und $B(r_1) = B(r_2)$ sowie $j < j'$\\
	Dann muss $r_3\in L'_{j''}$ mit $j'' \in J$ sein, also ist $r_2 \lessdot r_3$ durch eine der Bedingungen 5 bis 7 gegeben.\\
	Ist $B(r_3) > B(r_2) = B(r_1)$ so ist $r_1 \lessdot r_3$ nach Bedingung 5.\\
	Ansonsten ist $B(r_3) = B(r_2) = B(r_1)$ und $j' \leq j''$, also $j < j' \leq j''$ und $r_1 \lessdot r_3$ nach Bedingung 6.
	
	\item $r_1 \in L'_j, r_2 \in L'_{j'}$ mit $j,j' \in J$ und $B(r_1) = B(r_2)$ sowie $j = j'$ und $r_1 \prec_j r_2$.\\
	Dann muss $r_3\in L'_{j''}$ mit $j'' \in J$ sein, also ist $r_2 \lessdot r_3$ durch eine der Bedingungen 5 bis 7 gegeben.\\
	Ist $B(r_3) > B(r_2) = B(r_1)$ so ist $r_1 \lessdot r_3$ nach Bedingung 5.\\
	Ist $B(r_3) = B(r_2) = B(r_1)$ und $j' \leq j''$, so ist $j < j' \leq j''$ und $r_1 \lessdot r_3$ nach Bedingung 6.\\
	Ist $B(r_3) = B(r_2) = B(r_1)$, $j' = j''$ und $r_2 \prec_j r_3$, so ist $r_1 \prec_j r_2 \prec_j r_3$ und somit $r_1 \lessdot r_3$ nach Bedingung 7.
\end{enumcases}

$\lessdot$ ist also tatsächlich eine Ordnungsrelation.

%Wir definieren nun eine GTO $\prec'$: Für $s, t \in S'$ gelte $s \prec t$ genau dann, wenn  es $q, r \in R'$ mit $q \lessdot r$ gibt, so dass $s = A'(q)$ und $t = A'(r)$ ist.
%
%Nun ist zu beweisen, dass $A'$ und $\prec'$ zusammen konsistent sind.\\
%Dazu zeigen wir zuerst, dass sie konsistent für $e_1, e_2 \in R' \cup \{A(r) |r \in R'\}$ sind, also für $e_1, e_2 \in L_n \cap (R' \cup \{A(r) |r \in R'\})$ folgt aus $e_1 \prec_n e_2$, dass $A'(e_1) \prec' A'(e_2)$ gilt.
%

Es bleibt nur zu zeigen, dass $\lessdot$ zusammen mit $A'$ konsistent ist, das heißt für alle $e_1, e_2 \in L'_n \cap (R' \cup A'(R'))$ gilt $e_1 \prec_n e_2 \Rightarrow A'^{-1}(e_1) \lessdot A'^{-1}(e_2)$.\\ %,   dass folgende vier Eigenschaften erfüllt, woraus folgen wird, dass GTO $\prec'$ existiert, für den das Paar $(A', \prec')$ (und somit $A'$ alleine) konsistent ist:
Je nachdem, ob es sich bei $e_1, e_2$ um Sende- oder Empfangsereignisse handelt, %$e_1, e_2 \in S$ oder $e_1, e_2 \in R$ gilt, 
zerfällt der obige Ausdruck in diese vier Fälle:
\begin{itemize}
	\item$r_1, r_2 \in R'_n: r_1 \prec_n r_2 \Rightarrow r_1 \lessdot r_2$
	\item$s_1 \in S'_n, r_2 \in R'_n: s_1 \prec_n r_2 \wedge s_1 = A'(r_1) \Rightarrow r_1 \lessdot r_2$
	\item$s_2 \in S'_n, r_1 \in R'_n: r_1 \prec_n s_2 \wedge s_2 = A'(r_2) \Rightarrow r_1 \lessdot r_2$
	\item$s_1, s_2 \in S'_n: s_1 \prec_n s_2 \wedge s_1 = A'(r_1) \wedge s_2 = A'(r_2) \Rightarrow r_1 \lessdot r_2$
\end{itemize}

Für jeden dieser Fälle muss nun gezeigt werden, dass die Eigenschaft tatsächlich erfüllt ist:
\begin{itemize}
	\item Sind $r_1, r_2 \in R'_n$ mit $n \in I \cup J$ gegeben, so folgt aus $r_1 \prec_n r_2$ nach der Konstruktion der Logs, dass $B(r_1)\leq B(r_2)$ ist, und somit nach Bedingung 2, 4, 5 oder 7 der Definition von $\lessdot$ gilt $r_1 \lessdot r_2$.
	
	\item Sind $r_1 \in R'_k$ und $s_2 \in S'_k$ mit $r_1 \prec_k s_2$ gegeben, so hat $s_2$ die Form $s_2 = E^m_{kl} $ mit $A'^{-1}(E^m_{kl})  = e_{kl} \in R'_l$\\
	Offenbar ist $m>1$, da es keine Empfangsereignisse vor dem Block der $E^1$-Sen\-de\-erei\-gnisse gibt. \\%Daraus folgt $l \in J$ nach der Definition von $A'$.\\
	Ist $m = 2$, so ist $B(r_1) < B(s_2) = B(e_{kl})$ nach der Konstruktion von $L'_k$ und $k, l \in J$ nach der Konstruktion von $A'$, also ist $r_1 \lessdot e_{kl}$.\\
	Ist $m = 3$, so ist $B(r_1) \leq B(s_2) = B(e_{kl})$ nach der Konstruktion von $L'_k$ und $k < l$ sowie $k \in I\Leftrightarrow l \in I$ nach der Definition von $A'$, also ist $r_1 \lessdot e_{kl}$.\\
	Ist $m=4$, so ist $k \in I$, $l \in J$ und somit $L'_k \ni  r_1 \lessdot e_{kl} \in L'_l$.
	
	\item Sind $s_1 \in S'_k$ und $r_2 \in R'_k$ mit $s_1 \prec_k r_2$ gegeben, so hat $s_1$ die Form $s_1 = E^m_{kl} $ mit $A'^{-1}(E^m_{kl}) = e_{kl}\in R'_l$.\\
	Offenbar ist $m<4$, da es keine Empfangsereignisse nach dem Block der $E^4$-Sendeereignisse gibt.\\
	Ist $m = 1$, so ist gilt $l \in I$ und entweder $k \in J$ oder $k \in I$ mit $k > l$. Im ersten Fall ist $e_{kl} \lessdot r_2$ trivial, im zweiten ist $B(e_{kl}) = B(r_2) = X$, da die Ereignistypen aller durch $I$ bestimmten Logs bis auf die abschließenden $X$ disjunkt sind. Damit und $k > l$ folgt $e_{kl} \lessdot r_2$.\\
	Ist $m = 2$, so ist $B(e_{kl}) = B(s_1) \leq B(r_2)$ nach der Konstruktion von $L'$ sowie $k, l \in J$ und $k > l$ nach der Konstruktion von $A'$, also ist $L'_l\ni e_{kl} \lessdot r_2 \in L_k$.\\ %$B(e_{kl}) \leq B(s_2) = B(r_2)$ nach der Konstruktion von $L'$ und $k < l$ sowie $k \in I \Leftrightarrow l \in I$, also ist $e_{kl} \lessdot r_2$
	Ist $m = 3$, so ist $B(e_{kl}) = B(s_1) < B(r_2)$ nach der Konstruktion von $L'$ und $k \in I \Leftrightarrow l \in I$ nach der Konstruktion von $A'$, also ist $e_{kl} \lessdot r_2$.
	
	\item
	Sind $s_1, s_2 \in S'_n$ mit $n \in I \cup J$, $s_1 = A'(r_1)$, $s_2 = A'(r_2)$ und $s_1 \prec_n s_2$ gegeben, so haben sie die Form $s_1 = E^m_{nk}$ und $s_2 = E^{m'}_{nl}$. Die dazugehörigen Empfangsereignisse haben dementsprechend die Form $r_1=e_{nk} \in R'_k$ und $r_2 = e_{nl} \in R'_l$. 
	
	Ist $m=1$ so ist $k \in I$ und es gilt entweder $n \in J$ oder $n \in I$ mit $n>k$ nach der Konstruktion von $A'$. Im Unterfall $m' = 1$ folgt $l \in I$ nach der Definition von $A'$ und aus $s_1 \prec_n s_2$ folgt nach der Konstruktion von $L'_n$, dass entweder $B(E^1_{nk}) < B(E^1_{nl})$ oder $B(E^1_{nk}) = B(E^1_{nl})$ mit $k <l $ gilt, da alle Sendeereignisse mit Index 1 in einem sortierten Block liegen. Daraus folgt $e_{nk} \lessdot e_{nl}$.\\
	Ist dagegen $m' = 2$, so ist $n, l \in J$ und $n > l$ nach der Konstruktion von $A'$. Da $k \in I$ ist, gilt $L'_k \ni e_{nk} \lessdot e_{nl} \in L'_l$.\\
	Ist $m' = 3$, so ist entweder $l \in J$ (woraus sofort $e_{nk} \lessdot e_{nl}$ folgt) oder $l, n  \in I$ mit $n < l$. Daraus folgt wiederum $n > k$, also $k<l$. 
	Da alle Ereignisse der Logs von $I$ außer $X$ bloß disjunkte Basistypen besitzen, folgt aus $B(e_{nk}) = B(E^1_{nk})$ mit $n,k \in I$, dass $B(e_{nk}) = B(E^1_{nk}) = X$ ist. Analog folgt $B(e_{nl}) = B(E^3_{nl}) = X = B(e_{nk})$, woraus %  und $k \neq l$ unterschiedliche Logs bezeichnen, muss $B(e_{nk}) = B(e_{nl}) = X$ sein, woraus
	 mit $k,l \in I$ und $k < l$ folgt, dass $e_{nk} \lessdot e_{nl}$ ist.\\
	%Da $B(e_{nk}) = B(E^1_{nk})$ und $B(e_{nl}) = B(E^3_{nl})$ gilt,  und außerdem alle Ereignisse der Logs von $I$ außer $X$ bloß disjunkte Basistypen besitzen und $k \neq l$ unterschiedliche Logs bezeichnen, muss $B(e_{nk}) = B(e_{nl}) = X$ sein, woraus mit $k,l \in I$ und $k < l$ folgt, dass $e_{nk} \lessdot e_{nl}$ ist.\\
	Ist dagegen $m' = 4$, so ist $n \in I$ und $l \in J$ nach der Konstruktion von $A'$. Da $k \in I$ ist, gilt $L'_k \ni e_{nk} \lessdot e_{nl} \in L'_l$.
		
	Der nächste Fall ist $m=2$, woraus folgt $n,k \in J$ und $n > k$. Für $m'$ bleiben nach der Konstruktion von $A'$ die Werte $\{1,2,3\}$ übrig, was die Konstruktion von $L'$ auf $\{2,3\}$ reduziert, was zu $l \in J$ führt.\\
	Aus $m'=2$ folgt mit der Konstruktion von $L'$ entweder $B(E^2_{nk}) < B(E^2_{nl})$ oder $B(E^2_{nk}) = B(E^2_{nl})$ mit $k < l$. In beiden Fällen ergibt sich $e_{nk} \lessdot e_{nl}$.\\
	Aus $m'=3$ folgt mit der Konstruktion von $A'$, dass $n < l$ und somit $ k < n < l$ gilt, und mit der Konstruktion von $L'$ folgt $B(E^2_{nk}) \leq B(E^3_{nl})$ und somit $e_{nk} \lessdot e_{nl}$.
	
	Ist $m=3$, so muss $m'$ nach der Konstruktion von $L'$ mindestens 2 sein:\\
	Ist $m' = 2$, so ist $n, l \in J$ nach der Konstruktion von $A'$, woraus wiederum folgt $k \in J$. Aus der Konstruktion von $L'_n$ folgt durch $E^3_{nk} \prec_n E^2_{nl}$, dass $B(e_{nk}) = B(E^3_{nk})<B(E^2_{nl})=B(e_{nl})$ gilt und somit $e_{nk} \lessdot e_{nl}$.\\
	Ist $m' = 3$, so gilt entweder $B(E^3_{nk}) < B(E^3_{nl})$ oder $B(E^3_{nk}) = B(E^3_{nl})$ mit $k<l$. Außerdem ist entweder $n,k,l \in I$ oder $n,k,l \in J$, woraus folgt $e_{nk} \lessdot e_{nl}$.\\
	Ist $m' = 4$, so ist $n \in I$ und $l \in J$ nach der Konstruktion von $A'$. Wäre $k \in J$ so wäre $n \in J \lightning$, also ist $k \in I$ und es folgt sofort $e_{nk} \lessdot e_{nl}$.
	
	Ist $m=4$ so muss $m'=4$ sein, also gilt $k, l \in J$, $n \in I$ nach der Konstruktion von $A'$. Nach der Definition von $L'_n$ sind alle 4er Sendeereignisse in einem Block, also gilt entweder $B(E^4_{nk}) < B(E^4_{nl})$ oder $B(E^4_{nk}) = B(E^4_{nl})$ mit $k<l$. Daraus folgt $e_{nk} \lessdot e_{nl}$.
	
	\item
	Sind $s_1, s_2 \in L_0$ gegeben, so gibt $r_1 \in R_k$ mit $s_1 = A'(r_1) = A(r_1)$ und $r_2 \in R_l$ mit $s_2 = A'(r_2) = A(r_2)$. Außerdem findet man folgende Möglichkeiten vor:
	
	$s_1 \prec_0 \LTA$ und $s_2 \prec_0 \LTB$, woraus nach der Konstruktion von $L_0$ folgt $k, l \in I$ und $P(s_1) < P(s_2)$. Daraus folgt mit $B(r_1) = P(r_1) = P(s_1)$ und $B(r_2) = P(r_2) = P(s_2)$ wiederum $r_1 \lessdot r_2$.
	
	Ist $\LTA \prec_0 s_1 \prec_0 s_2 \prec_0 \LTB$, so ist $k,l\in I$ und $X = P(s_1) = P(s_2) = P(r_1) = P(r_2) = B(r_1) = B(r_2)$. Daraus folgt $k< l$ und $r_1 \lessdot r_2$, da die Anordnung der Sendeereignis in $L_0$ für Ereignisse mit dem gleichen Typ als aufsteigend bezüglich der Nummerierung der Logs vorausgesetzt wurde.
	
	Ist $\LTB \prec_0 s_1 \prec_0 s_2$, so ist $k,l \in J$ und es gilt entweder $B(r_1) <  B(r_2)$ oder $B(r_1) = B(r_2)$ mit $k < l$, abermals begründet durch die Konstruktion von $L_0$ und der Sortierung bezüglich der Lognummerierung. Daraus folgt sofort $r_1 \lessdot r_2$.
	
	Ist $s_1 \prec_0 \LTB \prec_0 s_2$, so ist $k \in I$ und $l \in J$, woraus sofort folgt $R_k \ni r_1 \lessdot r_2 \in R_l$.
	
	%Ist $m = m'$, so folgt aus $s_1 \prec_n s_2$, dass $B(E^m_{nk}) < B(E^m_{nl})$ und somit $e_{nk} \lessdot e_{kl}$ gilt.\\
	%Aus $m = 1$ ist $n \in I$ nach der Definition von $A'$ und somit $e_{nk} \lessdot e_{nl}$ nach $\lessdot$-Bedingung 2 und somit $s_1 \prec s_2$ \\
	%Aus $m \in \{2,3,4\}$ ist $k, l \in J$ und somit $e_{nk} \lessdot e_{nl}$ nach $\lessdot$-Bedingung 5 und somit $s_1 \prec s_2$\\
	%Ist $m\neq m'$, so gilt offenbar $m < m'$ und nach der Definition von $A$ gilt zudem $m' < 4$ und $n \in J$ (denn aus $n \in I$ würde folgen $m = 4 = m'$ und umgekehrt).\\
	%Ist $m=1$ und $m' \geq 2$, so ist $e_{nk} \in L_i$ mit $i\in I$ und $e_{nl} \in L_j$ mit $j \in J$ und somit $e_{nk} \lessdot e_{nl}$ und $s_1 \prec s_2$\\
	%Ist $m=2$, so ist $m' = 3$ und nach der Definition von $A$ gilt $n > k$ und $n < l$. Also ist $k < n < l$ und $e_{nk} \in L_j$ und $e_{nl} \in L_{j'}$ mit $j, j', n \in J$ \\
	%%Nach der Konstruktion von $L'_n$ gibt es inverse Empfangsereignisse $e_{kn}, e_{ln} \in L'_n$ mit $E^2_{nk} \prec_n e_{kn}$ und  $e_{ln}  \prec_n E^3_{nl}$.\\
	%Angenommen es gilt zudem $B(E^2_{nk}) > B(E^3_{nl})$, dann gilt nach der Konstruktion von $L'_n$ offensichtlich $s_2 = E^3_{nl} \prec_n E^2_{nk} = s_1$. Widerspruch zu $s_1 \prec_n s_2 \lightning$\\
	%Aus $B(E^2_{nk}) = B(E^3_{nl})$ folgt dagegen mit $k < l$, dass nach Bedingung 6 der GRO gilt, $e_{kn} \lessdot e_{ln}$ und somit $s_1 \prec' s_2$.\\
	%Ebenso folgt aus $B(E^2_{nk}) = B(E^3_{nl})$ mit Bedingung 5, dass $e_{kn} \lessdot e_{ln}$ und $s_1 \prec' s_2$ gilt.
\end{itemize}
%
%Es gibt nun folgende Möglichkeiten:
%\begin{enumcases}
%\item $k = l$\\
%Dann wäre $r_1 = e_{ik} = e_{il} = r_2$ und $A(r_1) = A(r_2)$. Widerspruch zu $s_1 \prec_i s_2 \lightning$ 
%\item $k \in I$, $l \in I$ und $k < l$\\
%
%\end{enumcases} aus $s_1 \prec_l s_2$ -- wie man an der Definition von $L'$ sieht, dass gilt:
%

%Für zwei Sendeereignisse $s, t\in L'$ gelte $s \prec' t$ genau dann falls (mindestens) eine dieser Bedingungen erfüllt ist:
%\begin{itemize}
%\item $s, t \in S \cap L_0$ und $s \prec_0 t$\\
%(hieraus folgt $a \prec b \Rightarrow a\prec' b$)
%\item $s \in S \cap L'_i$ mit $i \in I$ und $t \in S \cap L'_j$ mit $j \in J$
%\item $s \in S \cap L'_i$ mit $i \in I$ und $t \in L_0$ mit $t < \LTB$ und $T_B(s) < P(t)$
%\item $s \in S \cap L'_i$ mit $i \in I$ und $t \in L_0$ mit $t < \LTB$ und $T_B(s) < P(t)$
%\item XXXX?
%\item $s \in S \cap L_0$
%\end{itemize}
%
%    A12 A13 A14                           A12 A13 A14 a21 a31 a41  a          A12                     A13                     A14 | A12 A13 A14 
%        A21 A23 A24                                   A21             A23 A24 a12 a32 a42  a      A21     A23                 A24 | A21 A23 A24
%            A31 A32 A34                                   A31                     A32         A34     a13 a23 a43  a  A31 A32 A34 | A31 A32 A34
%A41 A42 A43 a14 a24 a34  a  A41 A42 A43 |                     A41                     A42                     A43


%  A' B' C' X' A' a' a A'  B' b' b B'  C' c' c C' X' x' x X' A'B'C' X'  
%
%$\prec'$ ist eine Ordnungsrelation: \\
%$\nexists A: A \prec' A$\\
%$\nexists A, B: A\prec' B \wedge B \prec' A$\\
%$A \prec' B \wedge B \prec' C \Rightarrow A \prec' C$
%

Damit wurde gezeigt: Für alle $e_1, e_2 \in L'_n \cap (R' \cup A'(R'))$ gilt $e_1 \prec_n e_2 \Rightarrow A'^{-1}(e_1) \lessdot A'^{-1}(e_2)$.


Mit Lemma \ref{lem:GROtoGTO} folgt daraus, dass $A'$ wie gewünscht konsistent ist.
\end{proof}

\chapter{Heuristik}\label{heuristic}
\section{Erweiterte Notation}


%Um den restlichen Text leichter verständlich zu machen und keine Konfusion aufkommen zu lassen, wird hier zunächst folgende Notation eingeführt:
Da die Arbeitsweise der Heuristik eng mit Intervallvektoruhren verknüpft ist, macht es Sinn, für alle  Beweise eine Notation zu verwenden, die auf diesen Uhren basiert. Dazu werden alle Ereignisse über einer Indexmenge $I$ durchnummeriert und jedem Ereignis $e$ wird eine Intervallvektoruhr $V(e) \in I^{n_L} \times I^{n_L}$ zugewiesen. 
Statt $V(e)$ wird zudem im folgenden oft nur $e$ geschrieben, sofern die Bedeutung aus dem Kontext klar ersichtlich ist.
%\begin{tabular}{ll}
%	%$L_i$ & Log i, mit $1 < i < n_L$\\
%	%$L = \bigcup L_i$ & Das gesamte Log\\
%	%$n_T = \sum_{i=1}^{n_L} |L_i|$ & Gesamtzahl der Ereignisse\\
%	$S(r)$ &  Sendeereignisse, dem Empfangsereignis r zugeordnet\\
%	$S_f(r)$ & Kleinstes Sendeereignis in $S(r)$\\
%	$S_l(r)$ & Größtes Sendeereignis in $S(r)$\\
%	%$R$ & Menge aller Empfangsereignisse \\ %\left\lbrace l \in  \right\rbrace
%	%$S$ & Menge aller Sendeereignisse\\
%	$n_R = |R|$ & Zahl der Empfangsereignisse\\
%	$n_S = |S|$ & Zahl der Sendeereignisse\\
%	%$p, q,r \in R$ & Empfangsereignis \\
%	%$s, t \in S$ & Sendeereignis \\
%	$I^{n_L}$ & Menge der möglichen Vektoruhren\\
%	$I^{n_L} \times I^{n_L}$ & Menge der möglichen Intervallvektoruhren
%\end{tabular}
%
%Ein Ereignis $e$ wird durch folgende Eigenschaften charakterisiert:\\
%\begin{tabular}{ll}
%$L(e)$ & Das Log in dem es liegt mit $e\in L_{L(e)}$\\
%$P(e)$ & Pakettyp des Ereignisses\\
%$D(e) \in {s,r}$ & Der Typ des Ereignisses, entweder Sende- oder Empfangsereignis\\
%$V(e) \in I^{n_L} \times I^{n_L}$ & Die Matrix der $n_l \times 2$ Intervallvektoruhr
%\end{tabular}



Die Einträge einer Intervallvektoruhr $V(e)$ bzw. $e$ haben die Form $e_{i,min}$ bzw. $e_{i,max}$. \\
Gilt $e_{i,min} = e_{i,max}$, so wird zur Klarheit einfach $e_i$ anstatt $e_{i,min}$ verwendet. \\
Außerdem sei $e_{min}$ der $n_L$-Vektor $(e_{1,min}, e_{2,min}, \ldots, e_{n_L,min})$, und $e_{max}$  sei der $n_L$-Vektor $(e_{1,max}, e_{2,max}, \ldots, e_{n_L,max})$.\\
Es gelte $e < f$ falls $e_{i,m} < f_{i,m}$ für alle $1 < i < n_L$ und $m \in \left\lbrace min,max\right\rbrace$.\\
Es gelte $e \leq f$ falls $e_{i,m} \leq f_{i,m}$ für alle $1 < i < n_L$ und $m \in \left\lbrace min,max\right\rbrace$.\\
Es gelte $e = f$ falls $e_{i,m} = f_{i,m}$ für alle $1 < i < n_L$ und $m \in \left\lbrace min,max\right\rbrace$.\\
$>$ und $\geq$ gelt entsprechend, $e \neq f$ gelte, wenn nicht $e = f$ gilt.\\
Achtung: Aus $e \leq f, e \neq f$ folgt dann nicht $e < f$
%Dementsprechend folgt aus $\neg(e \leq f)$ bloß $e \geq f$<-falsch
%Es gelte $r \neq q$ falls $r_{i,m} < r_{i,m}$ für alle $1 < i < n_l$ und $m \in \left\lbrace min,max\right\rbrace$.\\

Durch die Intervallvektoruhren wird jedem Empfangsereignis $r$ eine Menge von möglichen Sendeereignissen \[S(r) = \{s \in S | V(s)_{min} \leq V(r)_{max} \wedge V(s)_{max} \geq V(r)_{min} \wedge P(r) = P(s)\}\]
zugewiesen.

Das erste dieser Sendeereignisse heiße $S_f(r) \in S(r)$ und das letzte $S_l(r) \in S(r)$. Es gilt also für alle $s \in S(r)$, dass $S_f(r) \leq s \leq S_l(r)$ ist.

In manchen Beweisen werden mehrere unterschiedliche Belegungen $V$, $V'$ oder $V''$ betrachtet, in diesen Fällen bezeichnen $S$, $S'$ und $S''$ die Sendeereignisse, die einem Empfangsereignis durch diese neuen (Intervall-)Vektoruhren zugewiesen werden. Dazu muss in der obigen Definition einfach das $V$ durch eben  diese $V'$ oder $V''$ ersetzt werden.\\
Die abkürzende Schreibweise $e = V(e)$ wird dabei wirklich nur für $V(e)$ und nicht etwa für $V'(e)$ verwendet. (sofern $V(e) \neq V'(e)$ gilt)

Außerdem gehen wir zur besseren Übersichtlichkeit in diesem Anhang \ref{heuristic} davon aus, dass $L_0 = \emptyset$ ist, so dass wir eine mit 1 beginnende Nummerierung der Logs verwenden und $n_L$ die Zahl der Logs angibt.

\section{Eigenschaften der Lösungen}\label{sec:solprop}
In diesem Abschnitt werden Eigenschaften der auf Matterns Vektoruhren \cite{Vektoruhren} basierenden Intervallvektoruhren betrachtet, die auch unabhängig von der eigentlichen Heuristik gelten.

Dazu wird als nächstes der Begriff einer gültigen Lösung eingeführt, der im wesentlichem dem der konsistenten GA entspricht, allerdings nur auf den Werten der Vektoruhren basiert  und weder eine GA noch eine GTO erfordert:

%Der später untersuchte Algorithmus liefert eine Menge von potentiell möglichen Zuordnungen zwischen Sende- und Empfangsereignissen. Um zu entscheiden, ob sämtliche dieser berechneten Zuordnungen gültig sind, muss man zuerst wissen, was eine gültige Lösung eigentlich ist. \\
%Die von uns verlangten Bedingungen sind umgangssprachlich:\\
%Es muss eine globale, zeitliche Reihenfolge geben, in der die Ereignisse geschehen sind. (wir gehen davon aus, dass sich alle Empfangs-/Sendeknoten stationär, in der Nähe voneinander befinden, so dass keine relativistischen Effekte auftreten können und eine Newtonsche globale Zeit existiert)\\
%An jedem Ort sind alle Ereignisse in einer wohldefinierten Reihenfolge geschehen und keine Ereignisse sind dort gleichzeitig geschehen.\\
%Jede empfangene Nachricht wurde tatsächlich gesendet.\\
%Jede gesendete Nachricht wird von jedem Knoten maximal einmal empfangen.
%
%Formalisiert ergibt dies: 
%
%
\begin{defi}
	Eine Belegung der Vektoruhren $V: \bigcup_i L_i \rightarrow I^{n_L}$ zusammen mit einer bijektive Sortierfunktion $e: \left\lbrace 1, 2, \ldots, n_t\right\rbrace \rightarrow L$ heißt gültige Lösung zu den Logs $L_i$, falls sie folgende Bedingungen erfüllt:
	\begin{enumerate}
		\item $V(e_1) \leq V(e_2) \leq V(e_3) \leq \ldots \leq V(e_{n_{t-1}}) \leq V(e_{n_t})$
		\item $V(e_i) \leq V(e_j), V(e_i) \neq V(e_j)$ für alle $e_i, e_j \in L_k$ und $i<j$
		%\item $e_{min} = e_{max}$ für alle $e \in L$
		\item $|S(r)| = 1$ für alle $r \in R$, wobei $S(r) = \{s \in S | V(s) = V(r) \wedge P(s) = P(r)\}$ wie üblich
		%\item $s = r$ für $r \in R, s \in S(r)$
		\item $|\{ r \in R \cap L_m | s \in S(r)\}| \leq 1$ für alle $s \in S$, $1 \leq m \leq n_l$
		%\item $s \leq r$, für alle $s \in S, r \in R$ mit $P(r) = P(s)$ und $r_l = s_l$ mit $l = L^P(r)$ (d.h. $s$ ist das $r$ zugeordnete Sendeereigniss)%wenn $r$ ein $s$ zugeordnete Empfangsereignis (also $P(r) = P(s) \wedge r_l = s_l$ mit $l = L^P(r)$)
		%\item Jedes Sendeereignis in jedem Log maximal einem zugeordnet ist. (also für jedes m, $s \in S \cap L_l$ ist $|\left\lbrace r \in R \cap L_m | r_l = s_l \wedge P(r) = P(s) \right\rbrace| \leq 1$)
	\end{enumerate}
\end{defi}

%Um zu sehen, dass diese Definition den Bedingungen des Problem genügt, bietet es sich an, sie mit einer anderen Definition für dasselbe Problem zu vergleichen. Dazu eignet sich die Definition aus ''Who said that``\cite{WhoSaidThat}.\\
%Dort wird statt von einer gültigen Lösung von einem konsistenten Paar einer partiellen Ordnungsrelation GTO $\prec$ zusammen mit einer Zuordnungsfunktion GA $A$ gesprochen, ansonsten entspricht ihre Notation der hier verwendeten:
%
Es ist nun einfach zu zeigen, dass dieser Begriff zu dem einer konsistenten GA äquivalent ist:

\begin{lem}
	Für jede gültige Lösung $V, e$ existiert ein konsistenter GTO $\prec$ und GA $A$, die jedem Empfangsereignis dieselben Sendeereignisse zuweisen.\\
	Entsprechendes gilt für die Rückrichtung.
\end{lem}
\begin{proof}
	Die Zuordnung der Sendeereignisse zu einem Empfangsereignis $r$, wird in den beiden Notationen jeweils entweder durch $S(r)$ oder durch $A(r)$ angegeben. 
	Dabei gilt $S(r) = \{A(r)\}$ für alle $r \in R$.
%	Außerdem schreiben die Autoren von \cite{WhoSaidThat} $P(e)$ anstatt $P(e)$. & %
	
	
	''$\Rightarrow$``: 
	Sei $(V, e)$ eine gültige Lösung.
	
	Sei $A(l) = \begin{cases}
	l & \text{für  } l \in S \\
	s \in S(l) & \text{für  } l \in R \quad (\text{eindeutig, da } |S(l)| = 1) \\
	\end{cases}$
	
	Daraus folgt:
	\begin{enumerate}
		\item $\forall s \in S: A(s) = s$
		\item $\forall f \in L: P(f) = \begin{cases}
		P(A(f)) & \text{für } f \in S\\
		P(s) = P(A(f)) & \text{für } f\in R \text{ und } s \in S(f)
		\end{cases} = P(A(f))$
		\item $\forall r \in R: N(r) \neq N(A(r))$, da $V(r)_i$ eindeutig ist für alle $r \in L_i$, so dass aus $N(r) = N(A(r))$ folgen würde $A(r) = r$, was ein Widerspruch zu $r \notin S$ wäre.
	\end{enumerate}
	Damit ist $A$ tatsächlich eine GA nach der Definition von \cite{WhoSaidThat}.\\
	Dann sei eine GTO folgendermaßen definiert: \\
	Sei $e_i \prec e_j$ für zwei durch die Sortierfunktion bestimmte Ereignisse $e_i, e_j \in S$ genau dann, wenn gilt $i < j$.\\
	Damit ist $\prec$ eine irreflexive Ordnungsrelation.\\
	Ist dann $f_1, f_2 \in L_k$ mit $f_{1_k} < f_{2_k}$ (entspricht $f_1 \prec_k f_2$ nach der Notation von \cite{WhoSaidThat}), so ist $V(A(f_1)) = V(f_1) \leq V(f_2) = V(A(f_2))$ und somit gilt $A(f_1) \prec A(f_2)$, also ist $\prec$ konsistent.\\
	Damit existiert ein konsistentes Paar $(\prec, A)$
	
	
	
	''$\Leftarrow$`` Sei $(\prec, A$) ein konsistentes Paar eines GTO und GA.\\
	Aus der partiellen Relation $\prec$ kann man durch topologischen Sortieren eine globale Relation berechnen. Fügt man nun noch die Empfangsereignisse hinzu, so dass sie direkt nach ihrem Sendeereignisse gelistet sind, erhält man eine globale Reihenfolge $e: \{1,..,n_T\} \rightarrow L$\\
	Indem man dem ersten Ereignis eine beliebige Vektoruhr zuweist, deren Werte man für das nächste Sendeereignis sukzessiv vergrößert, erhält man leicht Vektoruhren $V: L \rightarrow I^{n_L}$ mit $V(e_i) \leq V(e_j)$ für $e_i \leq e_j$.\\
	Man kann dabei auch erreichen, dass $V(e_i)_l = k$ für das $k$-te Ereignis $e_i$ im Log $L_l$ gilt, denn aus $e_i \prec_l e_j$ folgt $i < j$, da in der GTO dann gilt $A(e_i) \prec A(e_j)$. Dadurch kann man beim sukzessiven Erhöhen der Vektoruhren den Wert eines Eintrags in der $l$-ten Zeile jeweils nur bei Erreichen eines Ereignisses im $l$-ten Log inkrementieren.\\ %Aus der Konstruktion der Sortierfunktion $e$ folgt zudem, dass es $e_m$ und $e_n$ gibt mit $e_m = A(e_i)$, $e_n = A(e_j)$ und $m < i < n < j$, %, da $\prec$ eine irreflexive Relation ist
	% so dass aus $A(e_i) \prec A(e_j)$ folgt $A(e_i) \neq A(e_j)$.\\
	Dadurch erreicht man auch automatisch $V(e_i) \leq V(e_j), V(e_i) \neq V(e_j)$ für $e_i, e_j \in L_k$ mit $i<j$ und ebenso  $V(e_i) = V(A(e_i))$. Daraus folgt dann auch $S(e_i) = \{A(e_i)\}$.\\
	Außerdem gilt für zwei $q, r\in R_k$ mit $q\leq r$, $q\neq r$, dass $A(q) \prec A(r)$ ist, also ist $S(q) \neq S(r)$ und es gilt $|\{r \in R_k | s \in S(r)\}| \leq 1$.\\
	Also gibt es eine gültige Lösung, im oben definierten Sinne, mit derselben Zuordnung als sie durch das Paar $(\prec, A)$ definiert wurde.
\end{proof}

Da man nun weiß, dass diese Definition sinnvoll ist, kann man mit ihr weiterarbeiten.
Es existieren verschiedene Möglichkeiten eine Lösung, bei der nur einige Ereignisse die Bedingungen für eine gültige Lösung erfüllen, fortzusetzen, so dass man weitere Ereignisse hinzufügen kann, welche dann auch diese Bedingungen erfüllen.

Das nächste Lemma behandelt den Fall, dass man eine gültige Lösung für zumindest alle Empfangsereignisse und alle diesen zugeordneten Sendeereignissen besitzt (natürlich kann die teilweise Lösung unter diesen Bedingungen auch noch weitere Sendeereignisse umfassen).\\
Dann kann man zu dieser Lösung immer ein bisher noch nicht enthaltenes Sendeereignis hinzufügen\footnote{Dieser Beweis in der Notation der Vektoruhren entspricht ungefähr dem Induktionsschritt der GRO im Lemma \ref{lem:GROtoGTO}.}: % in der GA/GTO-Notation.}:

\begin{lem}
	\label{lem:solution_RSR}
	Ist $X \subseteq L$ und existiert eine gültige Lösung $(V', e)$ für $L'_i = L_i \cap (R \cup S(R) \cup X)$ und sei $s \in L_j \setminus   L'_j$, so existiert eine gültige Lösung $(V'', f)$ für $L''_i = \begin{cases} L'_j \cup \{s\} & i= j\\
	L'_i & \text{sonst}\end{cases}$, so dass $V''(d) = V'(d)$ für $d \in L'$ ist. %mit $V''(d)_{min} \geq V'(d)_{min} \wedge V''(d)_{max} \leq V'(d)_{max}$ für alle $d \in L$, wenn eine der Bedingungen gilt:
\end{lem}
\begin{proof}
	%Seien die Vektoruhren entsprechend der gültigen Lösung gesetzt und $e$ die Sortierfunktion. Z.z. ist: Für jedes $s \in L_i \ L'_i$ gibt es eine gültige Lösung für $L''_i = L'_i \cup \{s\}$, wofür eine neue Lösung konstruiert $V'(e)_{min} \geq V(e)_{min} \wedge V'(e)_{max} \leq V(e)_{max}$ wird.\\
	\OBDA habe $s \in L'_j$ bereits einen eindeutigen Index $s_j$ (wenn nicht könnte man einfach die Indexmenge  als $\mathbb{Q}$ betrachten und einen entsprechenden Bruch als Index wählen).\\
%	O.B.d.A. Sei in diesem Beweis $I \subseteq \mathbb{Q}$, also die Einträge der Vektoruhren mindestens rationale Nummern. (Da $\mathbb{Q}$ und $\mathbb{N}$ dieselbe Kardinalität haben, kann man diese rationalen Vektoruhreinträge für praktische Zwecke auf die natürlichen Zahlen abbilden, und da es nur eine endliche Anzahl von Vektoruhren gibt, auch auf eine endliche Anzahl von natürlichen Zahlen)\\
	Für alle $d \in L'$ sei nun $V''(d) = V'(d)$.\\
	Dann sind die Bedingungen 3 und 4 automatisch erfüllt, da $s \notin R \cup S(R)$.\\
	Desweitern lassen sich folgende Fälle unterscheiden:
	\begin{enumerate}
		\item Es gibt kein $a \in L'_j$ mit $V'(a)_j < s_j$
		
		Dann kann man $V''(s) < V'(e)$ für alle $e \in L'$ wählen und $f_i = e_{i+1}, f_1 = s$ setzen, wodurch man offensichtlich alle Bedingungen erfüllt 
		\item Es gibt kein $b \in L'_j$ mit $V'(b)_j > s_j$
		
		Dann kann man $V''(s) > V'(e)$ für alle $e \in L'$ wählen und $f_i = e_{i}, f_{|L'|+1} = s$ setzen, wodurch man offensichtlich alle Bedingungen erfüllt 
		%Dann kann man $V''(s) := V(s)_{max}$ und $f_i = e_{i-1}, f_(n''_t) = s$ setzen und erfüllt offensichtlich alle Bedingungen
		\item Es gibt $a,b \in L'_j$ mit $V'(a)_j < s_j < V'(b)_j$ \\
		\OBDA sei $a$ maximal und $b$ minimal, so dass es kein $c\in L'$ gibt mit $V'(a)_j < V'(c)_j < s_j$ oder $s_j < V'(c)_j < V'(b)_j$.\\
		Dann gibt es ein $i$ mit $a = e_i$ und es gilt offenbar $e_{i+1} \leq b$. Sei $V''(s)_{k,m} = V''(a)_{k,m}$ für alle $k \neq j$ und $V''(s)_j = s_j$.\\
		Sei $f_k = \begin{cases}
		e_k & \text{für } k\leq i\\
		s & k=i+1\\
		e_{k-1} & k> i+1
		\end{cases}$
		
		Damit erfüllt das neue, keinem Ereignis zugeordnete Sendeereignis die Bedingungen einer gültigen Lösung (da nur die Bedingungen bezüglich der Vektoruhr für es relevant sind). Außerdem wurde die Reihenfolge der Elemente in $L'$ nicht verändert, so dass diese anderen Ereignisse ebenfalls weiterhin alle Bedingungen erfüllen.
		%Da $e_{i_k} \leq \frac{e_{i_k}+e_{{i+1}_k}}{2} \leq e_{i+1_k}$ gilt, ist $f_i \leq f_k$ für $i < k$ und Bedingung 1 erfüllt.\\
		%Da $e_{i_k} \neq \frac{e_{i_k}+e_{{i+1}_k}}{2} \neq e_{i+1_k}$, ist auch Bedingung 2 erfüllt.\\
		%Da auch $\frac{e_i+e_{i+1}}{2} \neq e_j$ für alle $j$ gilt, gibt es kein $r\in R$ mit $s \in S(r)$, wodurch auch die anderen beiden Bedingungen erfüllt sind.
		%Dann kann man davon ausgehen, dass $x \leq a$ für alle $x \in L'$ mit $x \leq s_{min}$ gilt 
	\end{enumerate}
\end{proof}

Der nächste betrachtete Fall ist, dass eine gültige Lösung für alle Empfangsereignisse existiert. In diesem Fall kann man allerdings nicht gleich die Axiome für eine gültige Lösung verwenden, da weniger Aussagen über die Sendeereignisse getroffen sind. 
%Mit den vom Algorithmus gewählten Grenzen und den Vektoruhren der Empfangsereignisse  kann aber eine eindeutige Zuordnung festgelegt werden, und die Bedingungen können entsprechend umformuliert werden. \\
Stattdessen verlangt man, dass jedem Empfangsereignis ein Sendeereignis zugeordnet ist und Empfangsereignisse mit unterschiedlichen Vektoruhren nicht vom gleichen Sendeereignis stammen können.\\
Dies ergibt in mathematischer Formulierung:

\begin{lem}
	\label{lem:solution_R}
	Seien Intervallvektoruhren $V$ gegeben, so dass für $e \in L_i$ der Wert $V(e)_i$ eindeutig ist und der lokalen Reihenfolge entspricht.\\
	Existiert eine bijektiven Sortierfunktion $f: \{1,2, \ldots n_R\} \rightarrow R$ und Vektoruhren $V': R \rightarrow I^{n_L}$ mit folgenden Eigenschaften: 
	\[V'(f_1) \leq V'(f_2) \leq \ldots \leq V'(f_{n_R})\]
	\[f_{i_{min}} \leq V'(i) \leq f_{i_{max}}\]
	\[|S'(f_i)| = 1\] 
	\[S'(f_i) \neq S'(f_j)  \text{ für } V'(f_i) \neq V'(f_j)\] 
	So existiert eine gültige Lösung $(V'', e)$ mit $V''(f_i) = V'(f_i)$ für alle $f_i$.
\end{lem}
\begin{proof}
	Sei $V''(f_i) = V'(f_i)$, so dass man im folgenden $V'$ statt $V''$ schreiben kann.\\
	Sei $V'(s) = V'(r)$ für $\{s\} = S'(r)$. (Eindeutig da $S'(f_i) \neq S'(f_j)$ für $V'(f_i) \neq V'(f_j)$)\\
	Da $s \in S'(r)$ ist, gilt damit offenbar $s_{min} \leq V'(s) \leq s_{max}$.
	
	Damit existiert eine gültige Lösung zu $L'_i = L_i \cap (R \cup S(R))$, denn:
	\begin{enumerate}
		\item Es gibt eine Sortierfunktion $e: \{1,2, \ldots, |R \cup S(R)|\} \rightarrow R \cup S(R)$ mit $V'(e_i) \leq V'(e_j)$ für $i\leq j$,
		da es eine solche Funktion für die Menge $\{V'(r) | r\in R\}$ gibt und nach der Definition von $V'(s)$ gilt: $\{V'(e) | e\in R \cup S(R)\} =  \{V'(r) | r\in R\}$.
		\item Für $e_i, e_j \in L_k$ mit $i < j$, gilt $e_{i_k} < e_{j_k}$, da der $k$-te Index eindeutig ist und  $e_{min} \leq V'(e) \leq e_{max}$ %wie auch $V'(e_i) \leq V'(e_j)$ 
		gilt. Also ist $V'(e_i)_k < V'(e_j)_k$ und somit $V'(e_i) \neq V'(e_j)$.
		\item $|S''(r)| = |S'(r)| = 1$, da $S''(r) = \{s\} = S'(r)$ ist, da $V'(s) = V'(r)$ für $s \in S'(r)$ gesetzt wurde und $|S'(r)|=1$ für alle $r$ vorausgesetzt wurde.
		\item Sind $p, q \in L_k$ mit $q \neq p$, so ist $V'(p) \neq V'(q)$, also ist nach den Voraussetzungen $S'(p) \neq S'(q)$. Da $|S'(r)| = 1$ ist $S'(p) \cap S'(q) = \emptyset$, also gibt es kein $s$ mit $s \in S(p)$ und $s\in S(q)$, somit gibt es maximal ein $r \in R_k$ mit $s \in S(r)$ für alle $s$. Also gilt $|\{r \in R \cap L_k | s\in S(r)\}| \leq 1$ für alle $s \in S$.
	\end{enumerate}
	Daraus folgt das eine gültige Lösung für $R \cup S(R)$ mit $V''(f_i) = V'(f_i)$ existiert. 
	Mit Lemma \ref{lem:solution_RSR} folgt dann induktiv, dass auch eine gültige Lösung für $L$ mit $V''(f_i) = V'(f_i)$ existiert, da man beliebig oft ein $s \in L \setminus (R \cup S(R))$ zur existierenden Lösung hinzufügen kann.
\end{proof}

%\begin{lem}
%Falls für jedes $r \in R$ und für jede Vektoruhr $V'(r)$ mit $r_{min} \leq V'(r) \leq r_{max}$ und $|S'(r)| = 1$ eine gültige Lösung existiert, so existiert auch eine gültige Lösung für jedes $s$ mit einer Vektoruhr $s_{min} \leq V'(s) \leq s_{max}$, sofern ein $r \in R$ mit $r_{min} \leq V'(s) \leq r_{max}$ existiert
%\end{lem}
%\begin{proof}
%Setze $V''(r) = V'(s)$. Dann gilt $r_{min} \leq V''(r) \leq r_{max}$ und $S''(r) = {s}$, da $s_{min} \leq V''(r) \leq s_{max}$ gilt und es durch die Eindeutigkeit des $k$-ten Vektoruhreintrags im $k$-ten Log maximal ein Sendeereigniss zu einem Empfangsereigniss mit fester Vektoruhr geben kann.\\
%Das heißt es gibt eine gültige Lösung mit $V'(s) = V''(r) = V''(s)$, da bei einer gültigen Lösung $r$ und alle $s \in S(r)$ dieselbe Vektoruhr haben.
%\end{proof}
%

%Marttens Definition von gleichzeitig: !(u <= v & u != v) & !(v <= u & v != u)
%wird zu
%!(u <= v & u != v) & !(v <= u & u != v)
%
%!(u[i] <= v[i] Ai & u != v) & !(v[i] <= u[i] Ai & u != v)
%
%(Ei u[i] > v[i] | u = v) & (Ei v[i] > u[i] | u = v)
%
%(Ei u[i] > v[i] & Ei v[i] > u[i]) | ( Ei v[i] > u[i] & u = v) | (Ei v[i] > u[i] & u = v) | (u=v & u=v)
%
%(Ei u[i] > v[i] & Ei v[i] > u[i]) | (u=v)
%

Nun definieren wir ein weiteres Kriterium für die Existenz einer gültigen Lösung, bei dem man die Logs in zwei Hälften aufteilt:
Dabei ist intuitiv klar, dass wenn man die Ereignisse in den Logs in zwei Hälften aufteilen  und dann für jede Hälfte eine gültige Lösung finden kann, daraus eine Zuordnung für sämtliche Ereignisse berechnet werden kann. (Eine ähnliche Aufteilung wurde von \cite{Vektoruhren} als Schnitt bezeichnet)

\begin{lem}
	\label{lem:solution_distcut}
	Gibt es gültige Lösungen $(V^1, F^1)$ und $(V^2,F^2)$ für die Logs $L^1_i$ und $L^2_i$ mit $L^1 \cap L^2 = \emptyset$, so gibt es auch eine gültige Lösung $(V, F)$ für $L_i = L^1_i + L^2_i$ mit $V(e^1) = V^1(e^1)$ für alle $e^1 \in L^1$ und $V(e^2) = V^2(e^2)$ für alle $e^2 \in L^2$, falls gilt $V(e^1) \leq V(e^2)$ und $V(e^1)_i < V(e^2)_i$ für alle $e^1 \in L^1_i$ und $e^2 \in L^2_i$
\end{lem}
\begin{proof}
	Sei $L = \bigcup_j L_i$, $L^1 = \bigcup_j L^1_j$ und $L^2 = \bigcup_j L^2_j$\\
	%Offensichtlich basierend alle Bedingungen, die an eine gültige Lösung gestellt werden, nur auf den Werten der einzelnen Vektoruhren relativ zueinander. Also kann man diese Vektoruhren beliebig ändern, sofern die Eindeutigkeit $V(e_i)_i = e_{i_i}$ der lokalen Zeit für $e_i \in L_i$ weiterhin gilt.\\
	%Also kann man \OBDA davon ausgehen, dass es $e^1_i \in L^1_i$ gibt, so dass $V(f^1)_i \leq e^1_i$ für alle $f^1 \in L^1$ gilt. Genauso wie es $e^2_i \in L^2_i$ gibt, so dass $V(f^2)_i \geq e^2_i$ für alle $f^2 \in L^2$\\
	%Daraus folgt direkt $V(f^1) \leq V(f^2)$ für alle $f^1 \in L^1$ und $f^2 \in L^2$\\
	Seien die Vektoruhren für alle $e \in L$ folgendermaßen gesetzt: 
	\[V(e) =  \begin{cases}
	V^1(e)&\text{falls }e\in L^1\\
	V^2(e)&\text{falls }e\in L^2
	\end{cases}\]
	Außerdem kann man für die Sortierfunktion setzen: \[F(i) = \begin{cases}
	F^1(i)& \text{falls }i \leq |L^1|\\
	F^2(i-|L^1|) & \text{falls }i > |L^1|
	\end{cases}\]
	Dies erfüllt, wie man leicht erkennen kann, alle an eine gültige Lösung gestellten Bedingungen.\\
	Die ersten beiden sind erfüllt, weil die Sortierung der Ereignisse in $L^1$ und $L^2$ untereinander in $L$ nicht geändert wurde und die Vektoruhren von allen $e^2 \in L^2$ größer als die von allen $e^1\in L^1$ sind.\\
	Die letzen beiden sind erfüllt, weil die Vektoruhren selbst % (abgesehen durch die \OBDA-Annahme) 
	nicht geändert  wurden und somit auch die Zuordnungen innerhalb der Logs unverändert bleiben. Zudem kann es durch die unterschiedlichen Vektoruhren für beide Logs  keine Zuordnungen zwischen Ereignissen aus den beiden unterschiedlichen Logs geben.
\end{proof}


\section{Eingabe}
%
%Die Eingabe an den Algorithmus sind die als Logs bezeichneten Mengen von Ereignissen $L_i$, aufgezeichnet von den einzelnen Knoten.\\
%Für jedes Ereignis wird dabei eine initiale Vektoruhr vorgegeben, welche folgende Eigenschaften erfüllen müssen:

Dieser Abschnitt beschreibt die initiale Belegung der Intervallvektoruhren vor Ausführung des Algorithmus:

Damit die Ereignisse eindeutig unterscheidbar sind, muss jedes Ereignis einen eindeutigen Index im jeweiligen Log besitzen, also: 
\[e_{l,min} = f_{l,max} \text{ für alle } e \in L_l\]
\[e_l \neq f_l \text{ für alle } e,f \in L_l \text{ mit }e \neq f\]

Jede Art von Sendeereignis muss eindeutig einem Sendeknoten zugeordnet sein, also:
Für jeden Typ $t$ gibt es ein Log $L_l$, so dass \[\{ s \in S | P(s) = t\} \subseteq L_l\]

Außerdem werden die restlichen Werte der Vektoruhren folgendermaßen initialisiert ($\infty$ muss dabei nicht unbedingt unendlich bedeuten, es kann auch ein so großer endlicher Wert sein, dass es keine größeren Vektoruhreinträge gibt):

\[e_{i,min} = -\infty \text{ für alle } e \in L_l  \text{ und } i\neq l\]
\[e_{i,max} = \infty  \text{ für alle } e \in L_l  \text{ und } i\neq l\]


%(Man könnte natürlich bereits eingeschränkte Vektoruhren an den Algorithmus geben, eingeschränkt mittels eventuell zusätzlich verfügbaren Informationen. Verfügt beispielsweise jeder Sender/Empfänger über eine physikalische Uhr, kann man diese vor einem Experiment synchronisieren und für die Zeit der Aufzeichnung davon ausgehen, dass die auf den physikalischen Uhren basierenden Zeitstempel bei gleichzeitigen kleiner $\epsilon$ sein müssen. Ein Wert von $\epsilon = 1 \min$ scheint für ein stundenlanges Experiment realistisch zu sien)

Es wird im folgenden davon ausgegangen, dass zu dieser Eingabe mindestens eine gültige Lösung existiert.

\section{Pseudocode}
Dieser Abschnitt gibt einen Pseudocode für die Arbeitsweise der Heuristik an, der auf den in den vorherigen Abschnitten eingeführten Intervallvektoruhrnotationen basiert:

\label{heuristic:code}
\begin{algorithmic}[1]
	\REPEAT\vspace{0.5cm}
	\STATE \COMMENT{Kreuztausch: Änderung der Empfänger}
	\WHILE {$\exists r \exists i: r_{i,min} < S_f(r)_{i,min} \vee r_{i,max} > S_l(r)_{i,max}$}
	\STATE $r_{min} \gets \max ( r_{min}, S_f(r)_{min})$
	\STATE $r_{max} \gets \min ( r_{max}, S_l(r)_{max})$
	\ENDWHILE\vspace{0.5cm}
	\STATE \COMMENT{Kreuztausch: Änderung der Sender}
	\WHILE {$\exists r \exists i: S_f(r)_{i,max} > r_{i,max} \vee S_l(r)_{i,min} < r_{i,min}$}
	\STATE $S_f(r)_{max} \gets \min ( S_f(r)_{max}, r_{max})$
	\STATE $S_l(r)_{min} \gets \max ( S_l(r)_{min}, r_{min})$
	\ENDWHILE\vspace{0.5cm}
	\STATE \COMMENT{Wischen: Minimum}
	\WHILE {$e,f \in L_l$  mit $e_l<f_l$ und $\exists i: e_{i,min} > f_{i,min}$}
	\STATE $f_{i,min} \gets e_{i,min}$
	\ENDWHILE\vspace{0.5cm}
	\STATE \COMMENT{Wischen: Maximum}
	\WHILE {$e,f \in L_l$  mit $e_l<f_l$ und $\exists i: e_{i,max} > f_{i,max}$}
	\STATE $e_{i,max} \gets f_{i,max}$
	\ENDWHILE\vspace{0.5cm}
	\UNTIL { keine Änderung}
\end{algorithmic}
%\begin{verbatim}
%repeat
%  foreach LOG
%    foreach E in LOG upwards (F= next E)
%	  E_imax = min(E_imax, F_imax)
%	  if E=R then 
%	    S_l = maximum {s | s_imax >= r_imin && s_imin <= r_imax für alle i}
%	    E_imax = min(E_imax, S_l_imax)
%	  end
%  end
%while find crosschangable rec-event with send-events :
%        R with S={s | s_imax >= r_imin && s_imin <= r_imax für alle i}
%        und R_imin < S_f_imin || 
%            R_imax > S_l_imax ||
%            S_f_imax > R_imax ||
%            S_l_imin < R_imin
%  crosschange: für alle i:
%        R_imin = max ( R_imin, S_f_imin)
%        R_imax = min ( R_imax, S_l_imax)
%        S_f_imax = min(S_f_imax, R_imax) 
%        S_l_imin = max(S_l_imin, R_imin)
%end
%
%while find E,F in Log mit E_log < F_log und 
%               F_imax < E_imax ||
%               E_imin > F_imin
%   E_imax = min(E_imax, F_imax)
%   F_imin = max(F_imin, E_imin)
%end
%
%until no change in one loop
%\end{verbatim}

Eine andere Beschreibung kann man in \cite{Marold} finden.

\section{Rückgabe des Algorithmus}
In diesem Abschnitt werden einige Eigenschaften der vom Algorithmus  berechneten Intervallvektoruhren aufgezählt.

Die Ausgabe besteht grundsätzlich aus den Vektoruhren und den eigentlich relevanten möglichen Sendermengen. Letztere sind für ein Empfangsereignis $r\in R$ gegeben durch:
\[S(r) = \{ s \in S | s_{max} \geq r_{min} \wedge s_{min} \leq r_{max} \wedge P(s) = P(r)\}\] 
%Jedem Empfangsereignis $r$  wird eine Menge von Sendeereignissen $S(r)$ mit $S(r) = \left\lbrace s \in S | s_{i,max} \geq r_{i,min} \wedge s_{i,min} \leq r_{i,max} \forall i \wedge P(s) = P(r)\right\rbrace$ zugeordnet.\\ 

Es gibt dabei kein Empfangsereignis $r$ mit einem Index $i$, so dass gilt %\in S(r)$ % = $\\ %{s | s_imax > r_imin && s_imin < r_imax für alle i}
$r_{i,min} \leq S_f(r)_{i,min}$, 
$r_{i,max} \geq S_l(r)_{i,max}$, 
$S_f(r)_{i,max} \geq r_{i,max}$ oder
$S_l(r)_{i,min} \leq r_{i,min}$\\
Es gibt keine Ereignisse $e,f$ in Log $L_l$ mit $e_l < f_l$ und $e_{i,min} > f_{i,min} \vee e_{i,max} > f_{i,max}$

Dies folgt daraus, dass die Kreuztausche solange durchgeführt werden, wie die ersten Bedingungen für $r$ nicht erfüllt sind und das Wischen solange bis die Bedingungen für $e,f$ erfüllt sind. Somit terminiert der Algorithmus erst wenn diese Bedingungen erfüllt sind.

%Da der Algorithmus bekanntermaßen keine gültiges Zuordnung zwischen Sende- und Empfangsereignissen ausschließt (Zitat: Scheuermann/Kiess), gilt $S(r) \neq \emptyset$. Also sind $S_f(r)$ und $S_l(r)$ immer definiert (da durch das Wischen auch eine Anordnung der Ereignisse in jedem Log sichergestellt ist)\\
%Für $e \in L_l$ gilt $e_l = e_{l,min} = e_{l,max}$. (schon in der Eingabe)

Positiv formuliert  ergibt sich mit den entsprechenden Abkürzungen\footnote{Sie stehen für ">Sender"<, ">Kreuztausch"< oder ">Wischen"<, und werden in den folgenden Beweisen als Hochindizes bei Vergleichen benutzt, um diese zu erklären und zu begründen.}:
\begin{lem}
%Für jedes $r \in R$ gilt: $S_f(r)_{i,min} \leq r_{i,min} \leq S_l(r)_{i,min}$ und $S_f(r)_{i,max} \leq r_{i,max} \leq S_l(r)_{i,max}$ \\
Für die Ausgabe des Algorithmus gilt:
\begin{description}
\item[S:] \[r_{min} \leq s_{max} \wedge s_{min} \leq r_{max} \text{ für alle } s\in S(r)\]

\item[KT:] \[S_f(r) \leq r \leq S_l(r) \text{ für jedes } r \in R\] % und $S_f(r)_{i,max} \leq r_{i,max} \leq S_l(r)_{i,max}$ 

\item[WI:] \[e \leq f \text{ für alle } e,f \in L_l  \text{ mit } e_l \leq f_l\]
\end{description}
\end{lem}

\newcommand{\SE}{^{S}}
\newcommand{\KT}{^{KT}}
\newcommand{\WI}{^{W}}

%Ist $r_i \in L_i \cap R$, so gilt $r_{i,max} = r_{i,min} \leq S_l(r)_{i,min} \leq r_{i,max}$, also $S_l(r)_{i,min} = r_i$.\\
%Ebenso gilt $r_{i,min} = r_{i,max} \geq S_f(r)_{i,max} \geq r_{i,min}$, also $S_f(r)_{i,max} = r_i$.

%Im folgenden wird davon ausgegangen, dass der Algorithmus auf Eingabedaten angewandt wird, zu denen tatsächlich eine gültige Lösung existiert.\\
%Denn es ist zu zeigen, dass alle gefundenen Lösungen tatsächlich korrekt sind, was voraussetzt, dass es auch welche gibt.

%Notationsmäßig bezieht sich ab jetzt $e_{min}$ und $e_{max}$ immer auf die Vektoruhren, die vom Algorithmus berechnet wurden.

Das nächste Lemma zeigt, dass die minimalen und maximalen Grenzen eines Empfangsereignisses scharf und ausreichend sind. Jedes Sendeereignis im $k$-ten Log dessen eindeutiger $k$-ter Index zwischen Minimum und Maximum des Empfangsereignis liegt, ist also nach dem Algorithmus ein mögliches Sendeereignis und bei jedem möglichen Sendeereignis liegt der Index dazwischen (Also muss man nicht die Vektoruhr des Sendeereignis beachten, sondern bloß dessen Position im Log).\\
Formal schreibt sich das als: 
\begin{lem}
	Für ein Ereignis $r \in R$ mit $s \in L_l$ für alle $s \in S$ mit $P(s) = P(r)$ lässt sich $S(r)$ schreiben als \[S(r) = \left\lbrace s \in L_l | r_{l,min} \leq s_l \leq r_{l,max} \wedge P(s) = P(r) \right\rbrace\]
\end{lem}
\begin{proof}
	Nach der Definition von $S(r)$ und der Einschränkung der versendeten Pakettypen ist \[S(r) = \left\lbrace s \in L_l | s_{max} \geq r_{min} \wedge s_{min} \leq r_{max} \wedge P(s) = P(r)\right\rbrace\]
	\\ 
	''$\subseteq$``: Zu zeigen ist: $s_{i,max} \geq r_{i,min} \wedge s_{i,min} \leq r_{i,max} \forall i \Rightarrow r_{l,min} \leq s_{l} \leq r_{l,max}$.
	
	Da $s_l = s_{l,min} = s_{l,max}$ ist, gilt $s_l \geq r_{l,min} \wedge s_l \leq r_{l,max}$, also $r_{l,min} \leq s_l \leq r_{l,max}$.
	
	''$\supseteq$``: Zu zeigen ist: $r_{l,min} \leq s_{l} \leq r_{l,max} \Rightarrow s_{i,max} \geq r_{i,min} \wedge s_{i,min} \leq r_{i,max} \forall i$.
	
	Angenommen es gibt ein $s$ mit $r_{l,min} \leq s_{l} \leq r_{l,max}$, aber $s_{i,max} < r_{i,min}$ für ein bestimmtes $i\neq l$.\\
	Offenbar ist dieses $s \notin S(r)$ und es gilt $S_f(r)_{i,max} \geq r_{i,min} > s_{i,max}$, also $S_f(r) \geq\WI s$, da sich $S_f(r)$ und $s$ im selben Log befinden. Da $s \neq S_f(r) \in S(r)$ sein muss, folgt $S_f(r)_l > s_l$, da $s_l \neq t_l$ für alle $s,t \in L_l$ gilt.\\
	Daraus folgt: $r_{l,min} \leq s_l < S_f(r)_l \leq\KT r_{l,min} \lightning$  \\
	Analog folgt, dass $s_{i,min} > r_{i,max}$  unmöglich ist.
\end{proof}

Das nächste Lemma zeigt, dass zwei Empfangsereignisse im selben Log, deren Sendeereignisse ebenfalls im gleichen Log liegen, unterschiedliche frühest- und spätestmögliche Sendeereignisse besitzen:

\begin{lem}\label{lem:minMaxOrder} Für zwei Empfangsereignisse $q, r \in L_l$ mit einem festen $m$ mit $S(q) \subseteq L_m$ und $S(r) \subseteq L_m$ , gilt $q_l < r_l \Rightarrow q_{m,min} < r_{m,min} \wedge q_{m,max} < r_{m,max}$.
\end{lem}
\begin{proof}
	Sei $q_l < r_l$ 
	\begin{enumcases}
		\item $min$-Einträge:\\
		Angenommen es gilt $q_{m,min} \geq r_{m,min}$, so ist $S_f(q) \geq S_f(r)$, da $S_f(q)_m = q_{m,min} \geq r_{m,min} = S_f(r)_m$ ist, also ist $S_f(r)_{l,max} \leq S_f(q)_{l,max} \leq\KT q_l < r_l$.
		Daraus folgt $S_f(r)$ erfüllt nicht $S_f(r)_{i,max} \geq r_{i,min}$ für alle $i$, also ist $S_f(r) \notin S(r)\lightning$
		\item $max$-Einträge:\\
		Angenommen es gilt $q_{m,max} \geq r_{m,max}$, so ist $S_l(q) \geq S_l(r)$, also ist $S_l(q)_{l,min} \geq S_l(r)_{l,min}\geq\KT r_l > q_l$\\
		Daraus folgt $S_l(q)$ erfüllt nicht $S_l(q)_{i,min} \leq q_{i,max}$ für alle $i$, also ist $S_l(q) \notin S(q) \lightning$ 
	\end{enumcases}
\end{proof}


\begin{lem}\label{lem:minMaxUnique} Für zwei Empfangsereignisse $q, r \in L_l$ mit $q_l \neq r_l$ gilt $S_f(q) \neq S_f(r)$ und  $S_l(q) \neq S_l(r)$.
\end{lem}
\begin{proof}
	Ist $P(q) \neq P(r)$ ist es trivial.\\
	Gilt $P(q) = P(r)$, so gibt es ein $L_m$ mit $S(q) \subseteq L_m$ und $S(r) \subseteq L_m$. Somit gilt nach dem vorherigen Lemma \ref{lem:minMaxOrder}, dass gilt $q_{m,min} \neq r_{m,min}$ und $q_{m,max} \neq r_{m,max}$.\\
	Daraus folgt $S_f(q)_m = q_{m,min} \neq r_{m,min} = S_f(r)_m$ und $S_l(q)_m = q_{m,max} \neq r_{m,max} = S_l(r)_m$.\\
	Also gilt die Behauptung dieses Lemmas.
\end{proof}

Eine interessante Eigenschaft der Vektoruhren ist es, dass es möglich ist, den Minimumanteil der Intervallvektoruhr eines einzelnen Sendeereignisses ohne vollständige Ausführung des Algorithmus zu bestimmen. Es gilt nämlich:
\begin{lem}
	Für ein Sendeereignis $s \in S_i$ ist \[s_{j,min} = \begin{cases}
	s_{i,max} \text{ (=eindeutiger Index)}& \text{für } i=j \\
	r_{j} & \text{falls es ein }r\in L_j \cap R \text{ mit }S_l(r) = s \text{ gibt}\\
	max(\{e_{j,min}\} \cup \{r_{j,min} |s  \in S_l(r)\})& \text{sonst, mit } e \in L_i \text{ das größte } e \text{ mit } e_i < s_i \\
	\end{cases}\]
\end{lem}
\begin{proof}
	Betrachte die einzelnen Fälle:
	
	\begin{enumerate}
		\item[Fall 1] i = j\\
		Dies ist trivial und folgt aus der Eingabe
		\item[Fall 2] Es gibt ein $r\in L_j$ mit $S_l(r) = s$\\
		Dann ist $s_{j,min} \leq\SE r_{j,max}$ und $r_{j,min} \leq\KT  s_{j,min}$ und aus $r_{j,min} = r_{j,max}$ folgt:\\
		$s_{j,min} \leq r_{j,max} = r_{j,min} \leq s_{j,min}$\\
		$\Rightarrow s_{j,min} = r_{j}$
		\item[Fall 3] Offensichtlich wird der Wert $s_{j,min}$ vom Algorithmus nur auf zwei Weisen geändert. Entweder beim Wischen, oder beim Kreuztauschen.\\
		Beim Wischen wird nun $s_{j,min} = \max(s_{j,min}, e_{j,min})$ gesetzt, mit $e \in L_i$ das größte $e$  mit   $e_i < s_i$\\
		Beim Kreuztauschen wird entsprechend $s_{j,min} = \max(s_{j,min}, r_{j,min})$ gesetzt, für ein $r$ mit $s = S(r)$ .\\
		%e_{j,min} \leq s_{j,min}$\\
		Also ist $s_{j,min} \geq max(\{e_{j,min}\} \cup \{r_{j,min} |s  \in S_l(r)\})$\\
		Auch $\leq$ gilt, wovon man sich überzeugen kann, indem man beobachtet, dass jeder Wert der $s_{j,min}$ zugewiesen werden könnte, kleiner als die obige Maximumsbildung ist.\\
		Dazu wird mit $e^T$ der Wert der Vektoruhren des Ereignis des $e$ zum Ausführungszeitpunkt $T$ des Algorithmus notiert. (beispielsweise gezählt als Schleifendurchlauf).
		Zu Beginn ist $s^{0}_{j,min}$ offensichtlich $0$.\\
		Jede $min$-Grenze wird nur vergrößert, also ist $e^{T}_{j,min} \leq e^{T'}_{j,min} \leq e_{j,min}$ für $T \leq T'$\\
		Wird $s_{min}$ im Verlauf durch ein Empfangsereignis $r$, für das auch im Endergebnis $S_l(r) = s$ gilt, gesetzt, so gilt offenbar $r^T_{min} \leq r^{T'}_{min}$ für alle $T \leq T'$. Also ist in dem Fall die Betrachtung des neusten $r$ ausreichend.\\
		Gab es dagegen einen Zeitpunkt $T$ mit $S^T_l(q)=s$ mit einem $q \in R$ mit $S_l(q) \neq s$, so gilt abermals $q^T_{min} \leq q^{T'}_{min}$ für jeden späteren Zeitpunkt $T'\geq T$. Direkt nach einem Kreuztausch für $S_l(q) \subseteq L_i$ gilt zu allen Zeiten $q^T_{i,max} \leq S^T_l(q)_{i,max} = S^T_l(q)_{i,min} \leq q^T_{i,max}$.  Da die $max$-Grenze nur verkleinert wird, gilt offenbar $S^T_l(q)_i = q^T_{i,max} \geq q_{i,max} = S_l(q)_i$.\\
		Also folgt aus $s = S_l^T(q) \in L_i$, dass $s_i \geq S_l(q)_i$ gilt, also $s_{min} \geq S_l(q)_{min} \geq q_{min} \geq q^T_{min}$, wobei das erste $\geq$ allein durch Wischen gilt!\\
		Der Anteil des Wischen wurde aber bereits zu $s_{min} \leq e_{min}$ gezeigt, also ist  das oben angegebene Maximum tatsächlich der Wert von $s_{min}$.
		%Man sieht leicht, dass auch während der Ausführung des Algorithmus $S_l(r)_i = r_{i,max}$ gilt, indem man den Beweis im obigen Lemma betrachtet. (für diesen Beweis ist diese Aussage allerdings nicht mal notwendig, es reicht, dass $S_l(r)_i \leq r_{i,max}$ immer gilt)\\
		%Da die $max$-Grenze immer verringert wird, gilt für zwei $q,r \in L_k \cap R$ zu unterschiedlichen Ausführungszeitpunkten $T \leq T'$ mit $q^T_{i,max} = r^{T'}_{i,max}$, dass  $q \leq r$ ist  (der Vergleich ist gültig für die Intervallvektoruhrwerte zum entsprechenden Schleifendurchlauf, oder für die lokale Ordnung innerhalb des Logs)\\
		%Also gilt für alle möglicherweise zugewiesenen Werte $q^{ALT}_{j,min} \leq r_{j,min}$ mit $s = S^{ALT}_l(q)$ und $s = S_l(q)$
	\end{enumerate}
\end{proof}

Im Abschnitt \ref{sec:solprop} wurde allgemein gezeigt, dass man zwei gültige Lösungen zu einer kombinieren kann, wenn die Einträge disjunkt sind, alle Ereignisse im zweiten Log eine spätere Vektoruhr als die im ersten besitzen, und die Vektoruhren eine Reihenfolge im eindeutigen Index erhalten. 

Im Spezialfall eines vom Algorithmus verarbeiteten Log kann man dies vereinfachen, indem man verlangt, dass in jeder partiellen gültigen Lösung nur Vektoruhren vergeben werden, die auch vom Algorithmus als möglich erkannt wurden. Dann ist es nämlich nicht mehr nötig, dass jede Vektoruhr im zweiten Log später ist als die im ersten, sondern es reicht, wenn dies für die Vektoruhren der Empfangsereignisse gilt.

Dazu benutzt man einfach das Lemma, dass  eine gültige Lösung zu $R \cup S(R)$ zu einer allgemeinen Lösungen mit diesen Vektoruhren fortgesetzt werden kann, und die Tatsache, dass jedes Sendeereignis die gleiche Vektoruhr wie das zugeordnete Empfangsereignis besitzt.

\begin{lem}
	\label{lem:solution_cut}
	Gibt es gültige Lösungen $(V^1, F^1)$ und $(V^2,F^2)$ für die Logs $L^1_i$ und $L^2_i$ mit $L^1 \cap L^2 = \emptyset$, so gibt es auch eine gültige Lösung $(V, F)$ für $L_i = L^1_i + L^2_i$ mit $V(r^1) = V^1(r^1)$ für alle $r^1 \in L^1 \cap R$ und $V(r^2) = V^2(r^2)$ für alle $r^2 \in L^2 \cap R$, falls gilt $V(r^1) \leq V(r^2)$ für alle $r^1 \in L^1 \cap R$ und $r^2 \in L^2 \cap R$ sowie $r_{min}\leq V(r) \leq r_{max}$ für alle $r \in L \cap R$ und $s_{min}\leq V(s) \leq s_{max}$ für alle $s \in L\cap S(R)$
\end{lem}
\begin{proof}
	Sei $L'_i = L_i \cap (R \cup S(R))$, $L'^1_i = L'_i \cap L^1$ und $L'^2_i = L'_i \cap L^2$.\\
	Aus $V(r^1) \leq V(r^2)$ für alle $r^1 \in L^1_i \cap R$ und $r^2 \in L^2_i \cap R$, folgt $V(s^1) \leq V(s^2)$ für alle $s^1 \in L^1_i \cap S(R)$ und $s^2 \in L^2_i \cap S(R)$, da bei einer gültigen Lösung die Sende- und zugeordneten Empfangsereignisse dieselbe Vektoruhr haben und beide vorhanden sein müssen.\\
	Also ist $V(e^1) \leq V(e^2)$ für alle $e^1 \in L'^1$ und $e^2 \in L'^2$.\\
	Außerdem wurde im Lemma verlangt, dass $e_{min} \leq V(e) \leq e_{max}$ für alle $e \in L'_i$ gilt, woraus folgt $V(e)_i = e_{i}$.\\
	Da dieser Index eindeutig ist, ist $V(e)_i \neq V(f)_i$ für $e,f \in L_i$ mit $ e\neq f$.\\
	Daraus folgt mit $V(e^1) \leq V(e^2)$, dass gilt $V(e^1)_i < V(e^2)_i$ für $e^1 \in L'^1_i$ und $e^2 \in L'^2_i$.\\
	Also existiert nach Lemma \ref{lem:solution_distcut} eine gültige Lösung für $L'_i$, welche die Werte von $V'(e)$ für $e\in L'$ erhält.\\
	Mit der induktiven Anwendung von Lemma \ref{lem:solution_RSR} folgt aus der Existenz einer gültigen Lösung für $L'_i = L_i \cap (R \cup S(R))$, dass es eine gültige Lösung für $L_i$ gibt, die ebenfalls alle Vektoruhren beibehält.
\end{proof}


Nun muss man diese Erkenntnisse benutzen, um damit zu untersuchen, ob jede vom Algorithmus gefundene Lösung, tatsächlich eine gültige Lösung ist.\\
Die Grundidee ist, dass man eine beliebige Zuordnung von Empfangsereignis und Sendeereignis wählt, die nach dem Algorithmus möglich, und aus den restlichen, nicht zugeordneten Ereignissen eine gültige Lösung konstruiert.




\section{Spezialfall: \texorpdfstring{$n_R=1$}{Ein Empfänger}}
\label{heuristic:nr=1}
In diesem Abschnitt wird der Spezialfall behandelt, dass es nur einen Empfänger gibt und sich in allen anderen Logs bloß Sendeereignisse befinden.\\
Dies ist besonders einfach, da dann die bekannte lokale Reihenfolge automatisch eine globale Reihenfolge aller Empfangsereignisse darstellt, und oben gezeigt wurde, dass eine solche Reihenfolge, mit einigen leicht zu zeigenden Bedingungen, ausreicht, um eine gültige Lösung zu induzieren.

\begin{lem}\label{lem:n_R=1,help}
	Ist $L'_i \subseteq L_i$ und $L' = \bigcup_i L'_i$ eine Untermenge der Ereignisse mit $L'_i \cap R = \emptyset$ für alle $i \neq l$ für ein festes $l$ und gilt für jedes $r \in L'_l \cap R$, dass  $S_f(r) \in L'$ ist, so gibt es eine gültige Lösung $(V', e)$ für $L'_i$ mit $V'(r) = r_{min}$ für alle $r \in L' \cap R$.
\end{lem}
\begin{proof}
	Sei $V'(r) = r_{min}$ für alle $r \in R' = L' \cap R$.\\
	Offenbar existiert eine Sortierfunktion $e: \{1,2,\ldots,|R'|\} \rightarrow R'$ mit $V'(e_i) \leq V'(e_j)$ für $i < j$, da nach dem Wischen innerhalb eines Logs die Minima sortiert sind und alle $r$ in $L'_l$ liegen.\\
	Offensichtlich gilt auch $q_{min} \leq V'(q) \leq q_{max}$ für alle $q \in R$.\\
	Oben wurde gezeigt, dass für $S_f(q)$ gilt $S_f(q)_{min} \leq\KT q_{min} \leq\SE S_f(q)_{max}$, also ist $|S(q)| \geq 1$ und nach der Eindeutigkeit mindestens einer Koordinate in jedem Log gilt somit $|S(q)| = 1$.\\
	Für zwei Empfangsereignisse $p, q$ mit $p\neq q$ im selben Log mit Sendeereignissen im gleichen Log (vom gleichen Typ) gilt nach Lemma \ref{lem:minMaxOrder} $p_{min} \neq q_{min}$ also gilt $S'(p) \neq S'(q)$. Somit folgt aus $S'(q) = S'(p)$, dass $p=q$ also $V'(p)=V'(q)$ gilt.
	
	Somit existiert nach Lemma \ref{lem:solution_R} eine gültige Lösung mit diesen Werten von $V'(r)$.
	
\end{proof}

Auf Grund der Symmetrie kann man dieses Lemma auch umkehren, so dass sich analog zeigen lässt, dass wenn alle $S_l(r) \in L'$ sind, eine gültige Lösung mit $V'(r) = r_{max}$ existiert.

Damit folgt dann, dass jedes Sendeereignis im Intervall (vom gleichen Typ) zu einer gültigen Lösung führt:

\begin{lem}
In diesem Spezialfall gibt es für jedes Empfangsereignis $r$ zu jeder Wahl der Vektoruhr $V'(r)$ mit $r_{min} \leq V'(r) \leq r_{max}$ und $|S(r)| = 1$ eine gültige Lösung.
\end{lem}
\begin{proof}
	Sei $V'(r)$ fest.\\
	Offenbar ist $V'(r)$ mit $ e: 1 \mapsto r$ eine gültige Lösung für $B=\{r\} \cup S(r)$.\\
	Sei $A = \{q \in R | q \leq r, q\neq r\} \cup \{S_f(q) | q \in R, q \leq r, q\neq r\}$.\\
	Dann gibt es nach dem vorherigen Lemma \ref{lem:n_R=1,help} eine gültige Lösung für $A$, so dass $V'(q) = q_{min}$ für alle $q\in A$ ist.\\
	Sei $C = \{q \in R | q \geq r, q\neq r\} \cup \{S_l(q) | q \in R, q \geq r, q\neq r\}$.\\
	Dann gibt es nach der Umkehrung des vorherigen Lemmas \ref{lem:n_R=1,help} eine gültige Lösung für $C$, so dass $V'(q) = q_{max}$ für alle $q\in C$ ist.\\
	Offenbar ist $q_{min} \leq V'(r)$ für alle $q \in A$ und $q_{max} \geq V'(r)$ für alle $q\in A$, da nach dem Wischen alle Empfangsereignisse in $L_l$ sortiert sind.\\
	Daraus folgt $V'(a) \leq V'(r) \leq V'(c)$ für alle $a \in A, c \in C$ und somit gibt es eine gültige Lösung mit diesen Vektoruhren für $A \cup B \cup C$ nach Lemma \ref{lem:solution_cut}.\\
	Da $R \subseteq A \cup B \cup C$ ist, und somit $S(R) \subseteq A \cup B \cup C$ ist, lässt sich nach Lemma \ref{lem:solution_RSR} jedes weitere Sendeereignis iterativ zu dieser gültigen Lösung hinzufügen, so dass es eine gültige Lösung mit diesen Vektoruhren für alle Ereignisse gibt.
	
	%
	%Sei $V'(q) = \begin{cases}
	%q_{min}&\text{für } q \leq r, q\neq r \\
	%V'(r)&\text{für } q = r \\
	%q_{max}&\text{für } q \geq r, q \neq r \\
	%\end{cases}$
	%
	%Offenbar existiert eine Sortierfunktion $e: \{1,2,\ldots,n_R\} \rightarrow R$ mit $V(e_i) \leq V(e_j)$ für $i < j$, da nach dem Wischen innerhalb eines Logs die Minima und Maxima sortiert sind.\\
	%Offenbar gilt auch $q_{min} \leq V'(q) \leq q_{max}$ für alle $q \in R$.\\
	%Oben wurde gezeigt, dass für $S_f(q)$ gilt $S_f(q)_{min} \leq q_{min} \leq S_f(q)_{max}$, also ist $|S(q)| \geq 1$ und nach der Eindeutigkeit mindestens einer Koordinate in jedem Log gilt somit $|S(q)| = 1$.\\
	%Für zwei Empfangsereignisse $p, q$ mit $p\neq q$ im selben Log mit Sendeereignis im gleichen Log (also vom gleichen Typ) gilt nach einem obigen Lemma $p_{min} \neq q_{min}$ und $p_{max} \neq q_{max}$ also gilt $S'(p) \neq S'(q)$. Somit folgt aus $S'(q) = S'(p)$, dass $p=q$ also $V'(p)=V'(q)$ gilt.
	%
	%Somit existiert nach Lemma 2.2.4 eine gültige Lösung mit diesen Werten von $V'(r)$
	%%Da die Vektoruhr jedes Empfangsereignis eindeutig ist, da diese alle im selben Log liegen, gilt offe
\end{proof}

Also führt in diesem Spezialfall jeder Sender innerhalb des vom Algorithmus bestimmten Intervalles zu einer gültigen Lösung und er wird im Gegensatz zum allgemeinen Fall optimal gelöst.
\section{Spezialfall: \texorpdfstring{$n_S=1$}{Ein Sender}}
\label{heuristic:ns=1}
In diesem Spezialfall arbeitet die Heuristik exakt, wovon man sich anhand folgender Beobachtung leicht überzeugen kann:

Sämtliche Kreuztäusche erfolgen jeweils nur zwischen dem eindeutigen Sendelog und einem weiteren Empfangslog, woraus letztendlich folgt, dass die Intervalle der Vektoruhr eines Empfangsereignisses immer größer sind, als die Intervalle in der Vektoruhr eines Sendeereignisses, es sei denn bei dem Intervall handelt es sich um den eindeutigen Index. Formal:
Ist $r\in R_i$, so gilt für $s \in S(r)$ anfänglich $r_{k,min} \leq s_{k,min} \leq s_{k,max} \leq r_{k,max}$ für alle $k\neq i$.\\
Geht man alle möglichen Änderungen der Intervallvektoruhr bei einem Kreuztausch durch, sieht man, dass diese Eigenschaft invariant unter Kreuztäuschen ist.

Wischen in einem Empfangslog kann diese Eigenschaft zwar kurzzeitig aufheben, sobald das Wischen aber ebenfalls im Sendelog durchgeführt wurde, ist sie aber wiederhergestellt. Die Eigenschaft wird nämlich beim Wischen für das Minimum genau dann zerstört, wenn es $p, q\in R_i$ mit $p \leq q$ und zwei $s\in S(p)$, $t\in S(q)$ gibt, für die gilt $V(p)_{k,min} > V(t)_{k,min}$. Nach dem  Wischen im Empfängerlog gilt dann $V'(q)_{k,min} \geq\WI V(p)_{k,min} > V(t)_{k,min}$. Nach dem Wischen im Senderlog gilt jedoch auch $V'(t)_{k,min} \geq\WI V'(s)_{k,min} \geq  V(p)_{k,min}$ wodurch die Invariante wieder gilt (analog für das Maximum).
%Da zudem anfänglich jedes eines Empfangsereignis , das heißt also, dass das Intervall eines Senderereignisses immer enger 

%Beide Operationen, Wischen und Kreuztausch, behandeln offensichtlich jede Komponente der Vektoruhr unabhängig von den anderen Komponenten. Jeder Kreuztausch erfolgt nur zwischen dem eindeutigen Sendelog und einem Empfangslog. s Wischen wird 

Das bedeutet, dass Zuordnungen nur auf Grund der Reihenfolge der Ereignisse im Sendelog ausgeschlossen werden und keine Zuordnungen in einem Empfangslog von der Reihenfolge der Ereignisse in einem anderen Empfangslog abhängig sind. Also erhält man durch das gleichzeitige Ausführen des Algorithmus auf allen Logs exakt dieselbe Zuordnungen, wie wenn man den Algorithmus einzeln für jeweils jedes Empfangslog und das Sendelog durchführt. Dass aber die gefundene Lösung bei einem Sendelog und einem Empfangslog gültig ist, wurde schon im vorherigen Abschnitt \ref{heuristic:nr=1} bewiesen.

\section{Spezialfall: \texorpdfstring{$n_l = 2$}{Genau 2 Logs} }
\label{heuristic:nl=2}
%
%\begin{lem}
%Sei $i\neq j$. Ist $v  = (s_i, r_j)$ für ein Empfangsereignis $r\in R \cap L_j$ und ein ihm zugeordnetes $s \in S(r) \cap L_i$, so gibt es ein $t\geq v$ für jedes $q \in q\in L_j$ mit  $q_j > v_j$
%\end{lem}
%\begin{proof}
%Mit der lokalen Ordnung folgt aus $q_j > v_j = r_j$ das gilt $q \geq\WI r$, also ist $S_f(q)_{max} \geq\SE q_{min} \geq\WI r_{min}$\\
%Da $q_{j,min} = q_{j,max}$ ist und entsprechendes für $r$ gilt, ist $S_f(q)_{j,max} \geq\SE q_j \geq\WI r_j = v_j$\\
%In einem obigen Lemma %TODO nummerierung
%wurde gezeigt, dass $S_l(r)_i = r_{i,max}$ gilt und aus 
%%\begin{enumcases}
%%\item $q \in L_i$\\
%%Aus der lokalen Ordnung folgt $q \geq\WI s$, also $S_f(q)_{1,max} \geq\SE q_{1,min} = q_1 \geq\WI s_1 = v_1$\\
%%Außerdem ist $S_f(q)_{2,max} \geq\SE q_{2,min} \geq\WI s_{2,min}$
%%\item $q \in L_j$\\
%
%%\end{enumcases}
%\end{proof}
%

In diesem Abschnitt wird der Spezialfall behandelt, dass exakt zwei Logs existieren.

Um zu die Eigenschaften einer gültigen Ausgabe des Algorithmus besser zu verstehen, kann man überlegen, wie man vorgehen muss, um aus dieser Ausgabe nun eine einzige gültige Lösung zu berechnen.
Angenommen also der Algorithmus hätte eine Menge von möglichen Intervallvektoruhren berechnet, wie findet man daraus eine globale Reihenfolge für alle Empfangsereignisse?

Ein naheliegendes Vorgehen ist es, einfach für ein Ereignis eine Vektoruhr innerhalb der berechneten Intervalle zu wählen, und dann die Menge der Ereignisse zu betrachten, die später aufgetreten sein könnten. Dann muss man nun für jedes dieser Ereignisse eine passende Vektoruhr finden.

Es ist leicht eine neue Vektoruhr zu finden, die zu einer globalen Sortierung passt, da man immer das Maximum von der letzten Vektoruhr und einer anderen, innerhalb der Intervallvektoruhr des neuen Ereignis liegenden wählen kann. Diese kommt dann immer direkt nach der letzten Vektoruhr in der Sortierung. %die neue dann immer nach der alten angeordnet sein wird.\\
Das Problem dabei ist nun, weder ein Ereignis noch eine Vektoruhr zu wählen, die später zu Widersprüchen führen könnten.

Die naive Idee, die Minimumvektoruhr für die Maximumbildung zu wählen, funktioniert nicht, da dann möglicherweise kein passendes Sendeereignis gefunden werden kann.
Nimmt dagegen man das Maximum von dieser Vektoruhr mit dem Minimum eines Sendeereignis, entsteht das Problem, dass eventuell ein Sendeereignis doppelt zugeordnet wird.
%Glücklicherweise stellt sich aber heraus, dass, falls man das Minimum des letzt möglichen Sendeereignis wählt, diese Probleme nicht auftreten. \\
%%Das Maximum zwischen der alten Vektoruhr und dem Minimum der Intervallvektoruhren ergibt für jedes dieser Ereignisse eine mögliche neue globale Vektoruhr. Das einzig komplizierte dabei ist, zu entscheiden, welches Ereignis man wählt, um ihm eine globale Vektoruhr zuzuweisen. Glücklicherweise stellt sich heraus,  dass es immer eines gibt, dessen Minimum so klein ist, dass man die resultierende Vektoruhr innerhalb des erlaubten Intervalls für die übrigen Ereignisse bleibt. \\
%Das folgenden Lemmas zeigen, dass dieses Vorgehen tatsächlich nicht nur jedem Ereignis eine eindeutige Vektoruhr zuweist, sondern dies auch unabhängig davon tut, ob die berechneten Intervallvektoruhren korrekt sind. Die Voraussetzung, dass diese Uhren die unter Ausgabe beschriebenen Eigenschaften besitzen, ist ausreichend. \\
%

%Dabei sind die Lemmas möglichst allgemein gehalten und nur an einige Stellen, wird die Einschränkung $n_L = 2$ tatsächlich verwendet.
Glücklicherweise lässt sich zeigen, dass man immer entweder das frühestmögliche oder das spätestmögliche Sendeereignis wählen kann, ohne Widersprüche zu erhalten, also so, dass man später wieder ein Sendeereigniss wählen kann.
% um wieder eine Menge von Ereignissen zu erhalten, entweder, dass

Dies zeigt das nächsten Lemma,  dessen Variablen die folgende intuitive Bedeutung haben: $v$ ist die zuletzt berechnete, globale Vektoruhr. Es werden nur die Ereignisse betrachtet, die nach dem durch diese Vektoruhr festgelegtem Zeitpunkt geschehen sein können (welche sich im $n_L=2$-Fall eindeutig bestimmen lassen). Man kann diese Vektoruhr auch als Zuordnung eines Sendeereignis $s$ zu einem Empfangsereignis $r$ betrachten, welche bei zwei Logs ebenfalls eindeutig ist. $s$ muss dabei entweder das nach den Intervallvektoruhren spätestmögliche oder das frühestmögliche Sendeereignis für $r$ sein. 
$K_i$ sind die Logs, beschränkt auf die Ereignisse, denen noch keine Vektoruhr zugewiesen worden ist.
%Die gestrichenen Varianten $v'$, und $K'_i$ sind die ''Ausgabe`` des Algorithmus und so gewählt, dass sie auch die an $v$, und $K_i$ gestellten Bedingungen erfüllen, so dass sich das Lemma später induktiv anwenden lässt.
%Nehme das minimale (i j) mit $(i j) \geq (a b)$ für ein $(a, b) \in V(R)$
%Sei $(a b)$ die momentane Vektoruhr, $(i,j)$ der Index der aktuell ausgewählten Empfangsereignisse. 
%Angenommen es gibt $(i',j') > (i,j)$.\\
%Sei $v=(v_i)$ die momentane Vektoruhr mit $r_{min} \leq (a, b) \leq r_{max}$, $(p,q) \in L_1 \times L_2$ die nächsten ausgewählten Empfangsereignisse.\\
\begin{lem}
	\label{lem:n2firstLastOkay}
	Sei $r \in R_\rho$ ein Empfangsereignis und $s \in L_\varsigma \cap S(r)$ ein Sendeereignis mit $s=S_f(r)$ oder $s=S_l(r)$, sei $v$ eine Vektoruhr mit $v_\rho = r_\rho$ und $v_\varsigma = s_\varsigma$.\\ 
	Sei $K_i = \{q \in R_i| q_i > v_i\} \neq \emptyset$.\\
	Dann gibt es ein $l$, ein $r' \in K_l$ mit $r'_{max} \geq v$ und $r' \leq q$ für alle $q \in K_l$ und ein $s' \in \{S_f(r), S_l(r)\}$ mit $s' \neq s$, $s'_{max} \geq v$ und $s' \leq q$ für alle $q \in K_m$ für $m \neq l$.
\end{lem}
\begin{proof}
	\OBDA sei $r \in L_1$ und $s \in L_2$. Dann lässt sich $v$ als $(r_1, s_2)$ schreiben.
	
	Nach dem Wischen sind die Ereignisse in den $L_i$ wohlgeordnet, es existieren also $n_L$ feste $e_i \in K_i \subseteq L_i$, so dass $e_i \leq e$ für alle $e \in K_i$ für $i\leq n_L$ gilt.\\
	Für $e_1$ gilt offensichtlich $e_{1_1}\geq\WI r_1 = v_1$ und $e_{1_{2,max}} \geq\WI r_{2,max} \geq\SE S_l(r)_{2,min} \geq\WI s_{2,min} = s_2 = v_2$ also ist $e_{1_{max}} \geq v$.\\
	Ebenso ist $e_{2_2} \geq\WI s_2 = v_2$ und $e_{2_{1,max}} \geq\WI s_{1,max} \geq\SE r_{1,min} = r_1 = v_1$, also ist $e_{2_{max}} \geq v$.
	
	%Für jedes $e_i$ existiert ein minimales $t_i \in S(e_i)$, so dass $v_i \leq t_{i_{i,max}}$, da $S_l(e_i)_{max} \geq e_{i_{max}} \geq v$.\\
	
	\begin{enumcases}
		\item $s = S_f(r)$\\
		Da $e_1, r \in L_1$ sind und $e_{1_1} > v_1 = r_1$ gilt, ist nach der lokalen Ordnung $e_{1_{2,min}} \geq\WI r_{2,min}$. Also ist $S_f(e_1)_2 = e_{1_{2,min}} \geq r_{2,min} = S_f(r)_2 = s_2 = v_2$.\\
		Da auch  $S_f(e_1)_{1,max} \geq\SE e_{1_1} > v_1$ gilt, ist $S_f(e_1)_{max} \geq v$.
		
		Offensichtlich gilt $L_1 \ni S_l(e_2) \neq s \in L_2$.\\
		Außerdem wurde in  Lemma \ref{lem:minMaxUnique} gezeigt, dass  $s = S_f(r) \neq S_f(e_1)$ aus $r\neq e_1$ folgt.
		
		%Außerdem wurde in einem obigen Lemma gezeigt, dass  $S_l(e_1) \neq S_l(r) = s$ aus $r\neq e_1$ folgt.
		Der einfache Fall $S_f(e_1) \leq e_2$ wird weiter unten behandelt, angenommen also es gilt $S_f(e_1) \geq e_2$ (da $S_f(e_1), e_2 \in L_2$ sind, gibt es tatsächlich nur diese beiden Fälle).\\
		So folgt $e_2 \leq S_f(e_1) \leq\KT e_1$ und somit $S_l(e_2)_1 = e_{2_{1,max}} \leq e_{1_1}$. \\
		Also gilt $S_l(e_2) \leq\WI e_1$.
		%Da $e_1$ kein Sendeereignis ist, muss $S_l(e_2)_1\neq e_{1_1}$ sein, also folgt mit der lokalen Ordnung, dass gilt $S_l(e_2) \leq e_1$
		
		%Aus $S_f(e_1)_{max} \leq v$ folgt $S_f(e_1)_2 \leq v_2=s_2 = S_f(r)_{2} \leq\WI e_{1_{2,max}}$ 
		%Dann ist offensichtlich $S_f($
		
		\item $s = S_l(r)$\\
		Da $e_2, s \in L_2$ sind und $e_{2_2} > v_2 = s_2$ gilt, ist $e_{2_{1,min}} \geq\WI s_{1,min} = S_l(r)_{1,min} \geq\KT r_{1,min} = r_1$. Daraus folgt $S_f(e_2)_1 = e_{2_{1,min}} \geq r_1 = v_1$.\\
		Da auch gilt $S_f(e_2)_{2,max} \geq\SE e_{2_2} > v_2$ ist $S_f(e_2)_{max} \geq v$.
		
		Offensichtlich gilt $L_1 \ni S_f(e_2) \neq s \in L_2$.\\
		Außerdem wurde in  Lemma \ref{lem:minMaxUnique} gezeigt, dass  $S_l(e_1) \neq S_l(r) = s$ aus $r\neq e_1$ folgt.
		
		Der einfache Fall $S_f(e_2) \leq e_1$ wird weiter unten behandelt, angenommen also es gilt $S_f(e_2) \geq e_1$ (wiederum sind diese beiden Möglichkeiten ausreichend).\\
		So folgt $e_1 \leq S_f(e_2) \leq\KT e_2$ und somit $S_l(e_1)_2 = e_{1_{2,max}} \leq e_{2_2}$. \\
		Also gilt $S_l(e_1) \leq\WI e_2$.
		
	\end{enumcases}
	
	In beiden Fällen gibt es also ein $l$, so dass für alle $m\neq l$ entweder $S_l(e_l) \leq e_m$ oder $S_f(e_l) \leq e_m$ mit $S_f(e_l)_{max} \geq v$ gilt.\\
	Offensichtlich ist $S_l(e_i)_{max} \geq e_{i_{max}} \geq v$, %Offensichtlich ist $S_l(e_1)_1 \geq e_{1_1} > v_1$ und aus $e_1 \geq r$ folgt $S_l(e_1) \geq^W S_l(r) \geq^W s$, also ist $S_l(e_1)_{max} \geq v$\\
	%Ebenso offensichtlich ist $S_l(e_2)_2 \geq e_{2_2} > v_2$ und aus $e_2 \geq s$ folgt $S_l(e_2)_{1,max} \geq^W s_{1,max} \geq^S r_{1,min} = v_1$, also ist $S_l(e_2)_{max} \geq v$\\
	man kann also das Ergebnis der beiden Fälle schreiben als: Es gibt ein $l$ und ein $s' \in \{S_f(e_l), S_l(e_l)\}$ mit $s'_{max} \geq v$ und $s' \leq e_m$ für alle $m \neq l$\\
	Die Untersuchung der beiden Fälle hat außerdem gezeigt, dass $s \neq s'$ gilt.\\
	Also gilt die Aussage dieses Lemmas.
\end{proof}

Nice to have und auch interessant, aber für die weitere Argumentation völlig nutzlos:

\begin{lem}
	Sei $v$ eine Vektoruhr und $K_i = \{r \in R_i | r_{i} > v_i\}  \neq \emptyset$ und gibt es ein $l$, ein $r \in K_l \cap R$ mit $r_{max} \geq v$ und $r \leq e$ für alle $e \in K_l$ und ein $s \in S(r)$ mit  $s_{max} \geq v$ und $s \leq e$ für alle $e \in K_m$ für $m \neq l$:
	
	Dann gibt es eine neue Vektoruhr $v' = (v'_i)$, und $K'_i = \{r \in R_i | r_{i} > v'_i\}$, so dass folgende Eigenschaften erfüllt sind: %mit $r \leq e$ für alle $e \in L_l$
	\begin{enumerate}
		\item $v' \geq v$
		%\item $v' = v$  falls $q\in K_i$ mit $S_l(q)_{min} \leq v$ existiert.
		\item $r_{min} \leq v' \leq r_{max}$
		\item $s_{min} \leq v' \leq s_{max}$
		\item $v_l = r_l$
		\item $v_m = s_m$ falls $s \in L_m$
		%\item $u' \geq u, u' \neq u$
		\item $K'_i = K_i$ falls $i \neq l$
		\item $K'_l = K_l \setminus \{r\}$
		\item $v' \leq e_{max}$ für alle $e \in K'_i$
		%\item Ist $v' \neq v$, so ist $v'_i \neq v_i$, falls $s \in L_i$
	\end{enumerate}
\end{lem}
\begin{proof}
	%Sei $\epsilon < \min \lefP( \{\text{abs}(p_{im} - q_{im}) | \forall p,q \in L, \forall i,j, \forall m \in \{min,max\}, p_{im} \neq q_{im}\}\right) $ kleiner als die minimale Distanz zwischen zwei Ereignissen. (bei ganzzahligen Koordinaten ist jedes $\epsilon < 1$ ausreichend)
	%\OBDA sei $r \in L_1$ und $s \in L_2$. Dann lässt sich $v$ als $(r_1, s_2)$ schreiben.
	
	Nach dem Wischen sind die Ereignisse in den $L_i$ wohlgeordnet, es existieren also $n_L$ feste $e_i \in K_i \subseteq L_i$, so dass $e_i \leq e$ für alle $e \in K_i$ für $i\leq n_L$ gilt.
	
	%Für jedes $e_i$ existiert ein minimales $t_i \in S(e_i)$, so dass $v_i \leq t_{i_{i,max}}$, da $S_l(e_i)_{max} \geq e_{i_{max}} \geq v$.\\
	Sei $v'_i = \max\{v_i, r_{i,min}, s_{i,min}\}$ für alle $i$.
	
	Dies erfüllt folgende Bedingungen:
	\[v'_{i} \geq v_{i} \forall i \Rightarrow v' \geq v\]
	\[v'_{i} \geq r_{i,min} \forall i \Rightarrow r_{min} \leq v'\]
	\[ v \leq r_{max}  \wedge r_{min} \leq r_{max} \wedge s_{min} \leq\SE r_{max} \Rightarrow v' \leq r_{max} \]
	\[ v'_{i} \geq s_{i,min} \forall i \Rightarrow s_{min} \leq v' \]
	\[ v \leq s_{max} \wedge  r_{i,min} \leq\SE s_{i,max} \wedge s_{i,min} \leq s_{i,max} \forall i \Rightarrow v' \leq s_{max} \]
	
	Also gilt $r_{min} \leq v' \leq r_{max}$ und somit $v'_l = r_l$, da $r_{l,min} = r_{l,max}$ gilt.\\
	Für $s \in L_m$ gilt entsprechend $s_{min} \leq v' \leq s_{max}$ und somit $v'_m = s_m$, da $s_{m,min} = s_{m,max}$ gilt.
	
	
	Sei $K'_{i} = \{  r \in R_i | r_i > v'_i\}$. Da $v' \geq v$ gilt, ist $K'_{i} \subseteq K_i$
	
	
	Nach den Anforderungen von $s$ gilt für $m\neq l$, dass $s \in L_m$ und $s \leq e_m \in K_m$ ist.\\
	Da $e_m$ kein Sendeereignis ist, muss $s_m < e_{m_m}$ gelten und da $e_m \leq q$ für alle $q\in K_m$ gilt, folgt $q_m \geq e_{m_m} > s_m = v_m$, also ist $q \in K'_m$ und $K'_m \supseteq K_m$. \\
	Also ist $K'_m = K_m$ für $m\neq l$.\\
	Da $v_l = r_l$ ist, ist $r \notin K'_l$. Für jedes andere $q \in K_l$ wurde $q \geq r$ verlangt und somit folgt aus der Eindeutigkeit des lokalen Index $q_l > r_l = v_l$, also $q \in K'_l$ und $K'_l \supseteq K_l \setminus \{r\}$.\\
	Also ist $K'_l = K_l \setminus \{r\}$.
	
	Oben wurde gezeigt, dass $v' \leq r_{max}$ und $v' \leq s_{max}$ gilt.\\
	Für alle $q \in K_l$ gilt  $q \geq r$ und folglich $q_{max} \geq r_{max} \geq v'$.\\
	Für alle $q \in K_m$ mit $m\neq l$ gilt entsprechend $q_{max} \geq s_{max} \geq v'$.
	
	Damit erfüllt die obere Wahl von $v'$ und $K'$ die im Lemma geforderten Bedingungen.
	%Für $n_l = 2$ und $m=2$ gilt: $t_1 \in L_2 \ni e_2$ und $t_2 \in L_1 \ni e_1$\\
	%Also ist $e_{1_{2,min}} \leq t_{1_{2,max}} = t_{1_{2,min}} \leq e_{1_{2,max}}$\\
	%Außerdem gibt es tatsächlich nur folgende Fälle:
	%\begin{enumcases}
	%\item $t_1 \leq e_2$\\
	%Dann ist offensichtlich $e_{1_{2,min}} \leq t_{1_{2,min}} <\WI e_{2_2}$, also ist $e_{2_2} > w_{1_2}$ und somit $e_2 \in H_{1_2}$\\
	%Außerdem gilt $e_{1_{min}} \leq\SE t_{1_{max}} \leq\WI e_{2_{max}}$, also $e_2 \geq w_1$
	%\item $t_1 \geq e_2$ und $r \in L_1$\\
	%Dann ist $e_{2_2} < t_{1_2} \leq e_{1_{2,max}}$
	%\item $t_1 \geq e_2$ und $r \in L_2$\\
	%Dann ist $e_{2_2} < t_{1_2} \leq e_{1_{2,max}}$
	%
	%
	%\end{enumcases}
	%Es gibt ein $l$ mit $t_l < e_{3-l}$
	%Entweder $t_1 < e_2$ oder $t_2 < e_1$\\
	%
	%
	%Zu zeigen ist nun nur noch die Existenz eines $l$ mit $e_{i_{max}} \geq S_l(e_l)_{min}$ für alle $i$.
	%
	%%Falls ein $q \in K_i$ mit $S_l(q)_{min} \leq v$ existiert, gibt es ein $l$ mit $S_l(e_l)_{min} \leq S_l(q)_{min} \leq v$. Dann ist offenbar $w_l = \max(v, S_l(e_l)_{min}) = v$ und $e_{i_{max}} \geq v \geq S_l(e_l)_{min}$. %(Dies war nötig für den Spezialfall der dritten Bedingung)
	%
	%%Falls kein solches $q$ existiert, nehmen wir an, auch dieses $l$ gäbe es nicht. Dann existiert für jedes $j$ ein $i$ mit $e_{i_{max}} \leq S_l(e_j)_{min}$.\\
	%%Daraus folgt $e_{i_{max}} \leq S_l(e_j)_{min} \leq e_{j_{max}}$\\
	%%Also gibt es für jedes $j$ ein $i$ mit $e_{i_{max}} \leq e_{j_{max}}$\\
	%%Das heißt es gibt eine Reihenfolge $i_k$ mit $e_{{i_1}_{max}} \leq e_{{i_2}_{max}} \leq \ldots \leq e_{{i_n}_{max}}$, aber auch, es gibt ein $k$ mit $e_{{i_k}_{max}} \leq e_{{i_1}_{max}}$\\
	%%Daraus folgt es gibt eine Menge $I$ mit $e_{i_{max}}= e_{j_{max}}$ und $e_{i_{max}} \leq e_{k_{max}}$ für jedes $i,j \in I$ und $k \notin I$.\\
	%%Sei nun $l \in I$. \\
	%%Für jedes $i$ gilt nun $e_{l_{max}} \leq e_{i_{max}}$ (da $\leq$ offensichtlich $=$ mit einschließt), also $e_{i_{max}} \geq e_{l_{max}} \geq S_l(e_l)_{min}$\\
	%%Aus $e_{i_{max}} \geq v$ für alle $i$ folgt nun $e_{i_{max}} \geq \max(v,S_l(e_l)_{max}) = w_l$.
	%%%\emph{Spezialfall}: $n_l = 2$
	%%
	%%
	%%%Fall 1: $e_{1_{max}} \leq S_l(e_2)_{min}$\\
	%%%Daraus folgt: %$e_{1_{min}} \leq e_{1_{max}} \leq t_{2_{min}} \leq S_l(e_2)_{min}$ \\
	%%%$S_l(e_1)_{min} \leq e_{1_{max}} \leq S_l(e_2)_{min} \leq e_{2_{max}}$ \\
	%%%Aus $e_{2_{max}} \geq v$ folgt $e_{2_{max}} \geq \max(v, S_l(e_1)_{min}) = w_1$
	%%%Da $t_2 \in S(e_2) \subset L_1$ ist, gilt in diesem Fall $e_1 \leq t_2$ und somit $e_{1_{min}} \leq t_{2_{min}} \leq S_l(e_2)_{min} \leq e_{2_{max}}$ \\
	%%
	%%%Fall 2: $e_{1_{max}} \geq S_l(e_2)_{min}$\\
	%%%Dann gilt automatisch $e_{1_{max}} \geq \max(v, S_l(e_2)_{min}) = w_2$
	%%
	%%Es gibt also immer ein $l$, so dass $e_{i_{max}} \geq w_l$ für alle $i$ gilt und somit gilt für $q\in H_{li}$ immer $q_{max} \geq e_{i_{max}} \geq w_l$
	%%
	%%Daraus folgt, dass es immer ein $l$ gibt, dass für $r = e_l$, $u' = µ_l$, $v' = w_l$ und $K'_i = H_{li}$ alle im Lemma genannten Bedingungen erfüllt sind.
	%%%t_{2_{min}} \leq S_l(e_2) 
	%%
	%%
	%%
	%%%Angenommen es gibt kein solches $l$, also gibt es für jedes $l$ ein $i$ mit $q_{i,max} < \max(e_{l_{i,min}}, t_{l_{i,min}})$\\
	%%
	%
\end{proof}
%
%Dieses Lemma hat gezeigt, dass man ausgehend von einer globalen Vektoruhr, ein Empfangsereignis finden kann, für welches das Maximum dieser Uhr mit dem Minimum des spätmöglichsten ihm zugeordneten Sendeereignis wieder eine mögliche globale Vektoruhr ergibt. Zudem lässt sich das Lemma mit dieser Vektoruhr erneut anwenden. %Außerdem bekommt man eine weitere Vektoruhr, die zwar größer als das Maximum dieses Ereignisses ist, aber trotzdem kleiner als das Maximum aller übrigen Ereignisse, deren Maximum größer war, als die ursprüngliche Vektoruhr.
%
%Analog lässt sich zeigen, dass man auch für die früheren Ereignisse eine Vektoruhr finden kann. Dies sei dem Leser zur Übung überlassen...
%
%
%
%%Sei $v_p'=(v_i) = (\max(v_i,p_{i,min}))_i$ und $v_q'=(v_i) = (\max(v_i,q_{i,min}))_i$.\\
%%Gilt $v'_p < v'_q$ sei $v' = v'_p$, ansonsten sei $v'_q < v'_p$.\\ % sei $v' = v'_q$, ansonsten \\
%%Z.z.: Dies erzeugt eine gültige globale Anordnung, also jedes p,q wird gewählt. Also in jedem Schritt gilt $\max{v_i,p_{i,min}} \leq q_{i,max}$ und $\max{v_i,q_{i,min}} \leq p_{i,max}$.\\
%%D.h. wählt man ein $x$ so ist weiterhin $y$ möglich. jedes $q$ mit $\max{v_i,q_{i,min}} \leq p_{i,max}$ wenn man ein solches erreicht sind schon alle früheren 
%%
%%%Angenommen es gibt $(q',r') \in L_1 \times L_2$ mit $q' > q$, $r' > r$.\\
%%Dann muss es $(a', b') > (a, b)$ geben, so dass $q'_{min} \leq a' \leq q'_{max}$
%%
%%\begin{lem}
%%Für zwei Empfangsereignisse $q, r \in L_i \cap R$ und $q_i < r_i$ gilt  $S_l(q)_{min} \leq S_l(r)_{min}$
%%\end{lem}
%%\begin{proof}
%%Aus der lokalen Ordnung folgt immer $ q \leq r$ und es lassen sich diese Fälle betrachten:
%%
%%\begin{enumcases}
%%\item $S_l(q), S_l(r) \in L_k$\\
%%Dann ist offenbar $S_l(q)_k = q_{k,max} \leq r_{k,max} = S_l(r)_k$, woraus folgt $S_l(q) \leq S_l(r)$
%%\item $S_l(q) \in L_k, S_l(r) \in L_l$ mit $l \neq k$\\
%%Oben wurde gezeigt, dass für jedes Sendeereignis $s$ gilt:\\
%%\[s_{j,min} = \begin{cases}
%%s_{i,max}& \text{eindeutiger Index für } i=j \\
%%r_{j} & \text{falls es }r\in L_j \text{ mit }S_l(r) = s \text{ gibt}\\
%%max(\{e_{j,min}\} \cup \{r_{j,min} |s  \in S_l(r)\})& \text{sonst} 
%%\end{cases}\]
%%Da wir hier nur, den Spezialfall betrachten, dass jedes Sendeereignis von jedem Log empfangen wurde
%%
%%\end{enumcases}
%%
%%Es gilt $q_{min} \leq r_{min} \leq S_l(r)_{min}$, also 
%%$S_l(r)_{min} \leq q_{max} \leq r_{max} \leq S_l(r)_{max}$
%%\end{proof}
%%
%%Anmerkung dies gilt nicht im allgemeinen Fall, wie dieses Gegenbeispiel zeigt:
%%\begin{verbatim}
%%3
%%c       a       B
%%0-0     1-1     2-2
%%0-0     0-0     0-0
%%0-2     0-2     0-2
%%A
%%1-1
%%0-0
%%0-2
%%C       C       C
%%0-0     0-2     0-2
%%0-0     0-0     0-0
%%0-0     1-1     2-2
%%
%%\end{verbatim}
%%
%%%entspricht die Sortierung der  $q_{max}$, $q_{min}$ innerhalb eines Logs $L_l$ der Sortierung der $q_l$, also ist Bedingung 2 für alle Empfangsereignisse innerhalb eines Logs erfüllt.\\
%%Seien $t, u \in S(R) \cap L_i$ zwei Sendeereignisse im Log $i$ mit $t_i < u_i$. Sei $j = 3-i$ das andere Log, $p, q \in R \cap L_j $ die zugeordneten Empfangsereignisse mit $t \in S(p), u \in S(q)$.\\
%%Nach der Zuordnung gilt $V'(t) = V'(p)$ und $V'(u) = V'(q)$, also folgt aus $V'(t)_i < V'(u)_i$, $V'(p)_i < V'(q)_i$, $V'(p) \leq V'(q), V'(p) \neq V'(q)$, $V'(t) \leq V'(u), V'(t) \neq V'(u)$. Die Anordnung der Senderereignisse in einem Log ist also korrekt.
%%Sei $q \in L_i \cap R$, $t \in L_i \cap S(R)$ mit $q_i < t_i$.\\
%%Ist $V'(q)_i > V'(r)_i$, so ist $V'(q)_j = V'(q)_{j,max}$ und $S'(q) = {S_l(q)}$	
%%Ist $V'(t)_j > V'(r)_i$, so gibt es ein  $V'(q)_j = V'(q)_{j,max}$ und $S'(q) = {S_l(q)}$	
%%Dann ist 
%%%t = S_l(
%%%$V'(q)_j = V(q)_{j,max}$ 
%%\upsilon\vartheta\gamma
%%%{(R_1, R_2max) für jedes R \in M_1} U {(R_1max, R_2) für jedes R \in M_2}
%%
%
%Damit kann man nun beweisen, dass, wenn man einem Empfangsereignis eine Vektoruhr und ein Sendeereignis zuweist, welche vom Algorithmus als möglicherweise passend gefunden wurden, existiert eine gültige Lösung mit diesen Zuordnungen.\\
%Zuerst wird dazu gezeigt, dass man nun jedem anderen Empfangsereignis ein Sendeereignis und eine Vektoruhr zuweisen lassen, die zu der ersten, willkürlichen Zuordnung ohne Widersprüche passt. Das heißt, alle Vektoruhren lassen sich global sortieren, jedes Empfangsereignis besitzt ein Sendeereignis und kein Sendeereignis wird mehreren Empfangsereignissen mit unterschiedlichen Vektoruhren zugewiesen.\\% e der es auch für jedes andere Empfangsereignis eine gültige Vektoruhr und ein Sendeereignis finden kann. Außerdem wird kein Sendeereignis Empfangsereignissen mit unterschiedlichen Vektoruhren zugewiesen.\\
%Dies formalisiert folgendes Lemma:
Das nächste Lemma stellt eine hinreichende Bedingung für die Existenz einer gültigen Lösung für eine Teilmenge aller Logs auf.\mybreak
Diese Bedingung ist dabei in zwei Teile geteilt, der erste Teil, ist der Spezialfall, dass von den beiden Logs nur ein Log tatsächlich Empfangsereignisse enthält, und es sich bei dem $n_L=2$-Fall in Wirklichkeit um einen $n_R=1$-Fall handelt. \mybreak
Der zweite Teil ist der allgemeinere Fall, dass in beiden Logs Empfangsereignisse existieren. 
%TODO:grafik (unnötig)??
Dann gibt es %wie man im Bild (noch nicht da) sieht, 
in jedem Log ein frühestes Empfangsereignis mit einem zugeordneten frühesten und spätesten Sendeereignis. Die Bedingung für die Existenz einer gültigen Lösung lautet nun einfach, dass bei einem diesen beiden Empfangsereignis eines der beiden erwähnte Sendeereignissen vor jedem Empfangsereignis im anderen Log passiert sein muss.
%Dies ist nötig, damit man 

\begin{lem} \label{lem:n_L=2,splittedlogs}
	Sei $p$ ein Empfangsereignis, $t \in S(r)$ ein ihm zugeordnetes Sendeereignis und $v$ eine Vektoruhr mit $p_{min} \leq v \leq p_{max}$ und $t_{min} \leq v \leq t_{max}$.\\
	Erfüllen $H_i= \{ e \in L_i | e_i > v_i\}$ und $K_i = H_i \cap R$ eine der folgenden Eigenschaften:
	\begin{enumerate}
		\item Es gibt ein $l$, so dass $K_m = \emptyset$ für $l \neq m$ ist.
		\item Es gibt ein $l$ und $r \in K_l$ mit $r_{max}\geq v$ und $r \leq e$ für alle $e\in K_l$, so dass für ein $s \in \{S_f(r), S_l(r)\} \subseteq L_m$ gilt $s \geq v$ und $s \leq e$ für alle $e \in K_m$.
	\end{enumerate}
	So existiert eine gültige Lösung $(V', f)$ für diese $H_i$ mit $V'(r) \geq v$ für alle  $r\in K_i$.
	
	%Wählt man eine Vektoruhr $V'(r)$ mit $r_{min} \leq V'(r) \leq r_{max}$ so, dass entweder $S'(r) = \{S_f(r)\}$ oder $S'(r) = \{S_l(r)\}$ gilt, so % $r_{min} \leq V'(r) \leq r_{max}$ (wobei $r_{min}, r_{max}$ vom Algorithmus bestimmt wurden) für ein Empfangsereignis $r$, die $r$ tatsächlich ein Sendeereignis zuweist, also $|S'(r)| = 1$, 
	%gibt es eine bijektive Sortierfunktion $q: \{1,2,\ldots, n_R\} \rightarrow R$ und weitere Vektoruhren $V'(r)$ mit $V'(q_i) \leq V'(q_j)$ für $i < j$, so dass gilt $q_{min} \leq V'(q) \leq q_{max}$, $|S'(q)| = 1$ für alle $q \in R$ und $S'(q) \neq S'(p)$ falls $V'(q) \neq V'(p)$ gilt.
	%globale Folge von Vektoruhren $q_1 \leq q_2 \leq \ldots \leq q_{n_r}$, so dass es ein $q_i = V'(r)$ gibt und für jedes $p \in R$ ein $q_j$ mit $q_{min} \leq q_j \leq q_{max}$ und zudem für jedes dieses $q$ ein $t \in S(p)$ mit $t_{min} \leq q_j \leq t_{max}$.
\end{lem}
\begin{proof}
	
	Sei $H = \bigcup_i H_i$ und $K = \bigcup_i K_i$
	
	\begin{enumcases}
		\item Die erste Bedingung ist erfüllt:
		
		\OBDA sei $p \in L_1$ und $t \in L_2$.
		
		Für $q \in K_1$ gilt $q \geq\WI p$ und mit Lemma \ref{lem:minMaxOrder} folgt $q_{2,max} > p_{2,max} \geq\SE S_l(p)_{2,min} = t_2 = v_2$, also ist $S_l(q) \in H_2$.\\
		Für $q \in K_2$ ist entsprechend $S_l(q)_1 =\KT q_{1,max} \geq\WI t_{1,max} \geq\SE p_{1,min} = p_1$, woraus $S_l(q)_1 > p_1 = v_1$ folgt, da $p$ kein Sendeereignis ist, also ist $S_l(q) \in H_1$.\\
		Für jedes $q \in K$ ist also $S_l(q) \in H$.
		
		Erfüllt $H$ die erste oben genannte Bedingung, so folgt mit dem Lemma \ref{lem:n_R=1,help} aus dem Fall $n_R = 1$ sofort, dass es eine gültige Lösung $(V',e)$ für $H$ gibt, mit $V'(q) = q_{max}$ für alle $q \in K$.
		
		
		\item Die zweite Bedingung ist erfüllt:\\
		Der Beweis erfolgt mittels Induktion über die Zahl der Empfangsereignisse in allen $K_i$:
		
		Induktionsanfang: $|K|  = 1$\\
		Offensichtlich ist $K_m  = \emptyset$ für $m \neq l$, da es nur ein einiges Empfangsereignis $r \in L_l$ gibt.\\
		Damit entspricht der Induktionsanfang der ersten Bedingung und ist durch sie bereits gezeigt.
		
		Induktionsschritt: $|K| = n \rightarrow |K|=n+1$\\
		Man kann \OBDA davon ausgehen, dass $K_i \neq \emptyset$ für alle $i$ ist (sonst ist alles bereits gezeigt), \OBDA $r\in L_1$.\\
		Sei $v' = (r_1, s_2)$, $H'_i = \{ e \in L_i | e_i > v'_i\}$ und $K'_i = H'_i \cap R$.\\
		Da $r \leq q$ für alle $q\in K_1$ und $s \leq q$ für alle $q \in K_2$ ist, gibt es offensichtlich nur ein Empfangsereignis in $H_i \setminus H'_i$, und somit erhält man eine gültige Lösung für $H_i \setminus H'_i$, wenn man die Vektoruhr von $r$ und $s$ auf $v'$ setzt.\\
		%Nach dem vorherigen Lemma gibt es eine Vektoruhr $v' \geq v$ mit $r'_{min} \leq v' \leq r'_{max}$ und $s'_{min} \leq v' \leq s'_{max}$ und $K'_i = \{e \in L_1 \cap R | e > v'_i\}$, so dass gilt \[K'_i = \begin{cases}
		%K_i \setminus \{r\} & i=l\\
		%K_i & \text{ sonst }
		%\end{cases}\]
		Man sieht, dass offensichtlich $|K'| < |K|$ ist, es scheint also logisch nun die Induktionsannahme anzuwenden.\\
		Ist ein $K'_i = \emptyset$, so ist offensichtlich die erste Bedingung dieses Lemmas erfüllt, ansonsten sieht man: 
		Da $s \in \{S_f(r), S_l(r)\}$ ist und $v'=(r_1,s_2)$ gilt, folgt mit dem Lemma \ref{lem:n2firstLastOkay}, dass es ein $l'$, ein $r' \in K'_{l'}$ mit $r'_{max} \geq v'$ und $r' \leq q$ für alle $q \in K'_{l'}$ und $s' \in  \{S_f(r'), S_l(r')\}$ mit $s' \neq s$, $s'_{max} \geq v'$ und $s' \leq q$ für alle $q \in K'_m$ mit $m\neq l'$ gibt.\\
		Damit erfüllen die $r, s, r', s', l'$ die zweite Bedingung dieses Lemmas und somit gibt es nach der Induktionsannahme eine gültige Lösung für $K'$ mit $V'(q) \geq v'$ für alle $q \in K'$.\\
		$v'$ ist offensichtlich die Vektoruhr die in einer gültigen Lösung für $r$ und $s$ diesen beiden Ereignissen zugeordnet ist, also gilt $V'(r) \leq V'(q)$ für alle $q \in K'$ und es gibt nach Lemma \ref{lem:solution_cut}  eine gültige Lösung für $H' \cup (H \setminus H') = H$. %$r \in X \cap R$ und $q \in K'$, also gibt es nach  Lemma \ref{lem:solution_cut} eine gültige Lösung für $X \cup K'$, da es eine gültige Lösung $(V'', e)$ für dieses beiden Mengen gibt.\\
		Außerdem ist $V'(q) \geq v$, da $V'(q) \geq V'(r) \geq v$ für alle $q\in K$.
		
	\end{enumcases}
	
	
	
	
	%%Sei $\epsilon$ wie im obigen Lemma, die minimale Distanz zwischen den Werten zweier Intervallvektoruhreinträgen.\\
	%Sei $\{s\} = S'(r)$ das durch die Wahl der Vektoruhr $V'(r)$ dem Ereignis $r$ zugewiesene Sendeereignis.\\
	%Im Spezialfall $n_l = 2$ lässt sich die Menge der Empfangsereignisse folgendermaßen aufteilen: (O.B.d.A sei $r \in L_1$)\\
	%\[L_1 = A_1 + \{r\} + B_1\]
	%\[L_2 = A_2 + \{s\} + B_2\]
	%da die Indizes $r_1$, bzw. $s_2$ innerhalb eines Logs eindeutig sind. Außerdem gilt dann $a_1 \leq r \leq b_1$ für alle $a_1 \in A_1, b_1 \in B_1$ und $a_2 \leq s \leq b_2$ für alle $a_2 \in A_2, b_2 \in B_2$. \\
	%Sei $v = V'(r)$, mit $v_1 = r_1$ und $v_2 = s_2$. Dann ist $K_i = \{r \in L_i \cap R | r_i > v_i \} = B_i$, da  diese Indizes eben eindeutig in $L_1$ sind.\\ %von $r \in B_i$ nach der Wahl von $\epsilon$ gerade gilt $r_i \geq v_i + \epsilon$\\
	%Es gilt auch $e_{max} \geq v$, für alle $e \in K_i$, da $v \leq r_{max} \leq b_1$ und $v \leq s_{max} \leq b_2$ gilt.
	%
	%Gibt es ein $K_i \neq \emptyset$, so gibt es nach dem obigen Lemma ein $r' \in 	R$, $s' \in S(r')$, $v' \geq v$, und $K'_i$ mit diesen Eigenschaften:\\
	%$s \neq s'$, $v' \geq v$, $r'_{min} \leq v' \leq r'_{max}$, $s'_{min} \leq v' \leq s'_{max}$, $s' \in \{S_f(r'),S_l(r')\}$\\
	%Für die $K'$ gilt dabei $\bigcup_i K'_i = \bigcup K_i \setminus \{r\}$ und $v' \leq e$ für alle $e \in K'$\\
	%Das heißt, dass man abermals das obige Lemma anwenden kann und dann induktiv für jedes $q_i \in \bigcup B_j$ eine Vektoruhr $V'(q_i)$ erhält, so dass gilt $V'(q_i) \leq V'(q_{i+1})$. \\
	%Außerdem erfüllt  dieses $q_i$ die Bedingungen $q_{i,min} \leq V'(q_i) \leq q_{i,max}$ und es gibt immer ein $t \in S(q_i)$, mit $t_{min} \leq V'(q_i) \leq t_{max}$, was zusammen mit der Eindeutigkeit von $t_i$ für $t \in L_i$ zu $|S'(q_i)| = 1$ führt.\\
	%Da zudem in jedem Schritt $s' \neq s$ gilt, ist $S'(q)\neq S'(p)$ falls $q\neq p$ ist.
	%
	%%Außerdem gilt $u_i = \max (u_{i-1}, S_l(q_i)_{min})$ mit $u_0  = v$.\\
	%%Angenommen es gilt $V'(q_i) \neq V'(q_j)$ für $i < j$.\\
	%%Dann ist $V'(q_j) = \max(\{V'(q_i)\} \cup \{S_l(q_k)_{min} | i \leq k \leq j\}\}$\\
	%%Gilt $P(q_i) \neq P(q_j)$ ist offensichtlich $S'(q_i) \neq S'(q_j)$.\\
	%%Gilt $P(q_i) = P(q_j)$, so gibt es ein $k$ mit $S'(q_i), S'(q_j) \subset L_k$.\\ % 
	%%Da der $k$-te Index im $k$-ten Log eindeutig ist und $S_l(q)_{min} \leq V'(q) \leq S_l(q)_{max}$ gilt, ist $V'(q_1)_k = S_l(q_1)_{k}$ und $V'(q_2)_k = S_l(q_2)_{k}$
	%%%Schreibe $S'(q_i) = s_i$ und $S'(q_j) = s_j$
	%%%Dann ist $s_{i_k} = q_{i_k}$ und $ s_{j_k} = q_{j_k}$
	%%
	%%
	%%\emph{Spezialfall $n_l = 2$}: Dann sind $q_i, q_j$ im selben Log $L_m$. \\
	%%Da $q_{i_m}$ eindeutig ist, ist $q_{i} \leq q_j$, also gilt $q_{i_{k,max}} < q_{j_{k,max}}$ nach einem obigen Lemma.\\
	%%Daraus folgt $V'(q_1)_k = S_l(q_1)_{k} = q_{i_{k,max}} < q_{j_{k,max}} = S_l(q_2)_{k} = V'(q_2)_k$, also $V'(q_1)_k \neq V'(q_2)_k$.\\
	%%Das heißt $S'(q_i) \neq S'(q_j)$, was zu zeigen war. 
	%%%Da $S_l(q_i)_{m,min} = q_{i_m} < q_{j_m} = S_l(q_j)_{m,min}$ gilt, ist $S_l(q_i) \neq S_l(q_j)$ und somit gilt nach $i < j$ und der Eindeutigkeit des $k$-ten Index im $k$-ten Log $\max(S_l(q_i)_k, S_l(q_j)_k) \neq S_l(q_i)_k$ und somit $S'(q_i) \neq S'(q_j)$ 
	%%(Es gilt auch für den Spezialfall $q_i = r$, da $s \leq S_l(r)$ sein muss)
	%%
	%
	%%Aus $V'(q_l) \leq V'(q_j)$ folgt $S_l(
	%
	%
	%Das heißt also, dass die Behauptungen dieses Lemmas für $q \in R$ mit $q \geq v$ bewiesen wurden.
	%
	%
	%Der Beweis für die andere Hälfte mit $q \leq v$ erfolgt analog.
\end{proof}

Dieses Lemma ist auch in seiner umgekehrten Form gültig, wenn man jeweils die Bedeutung von früher und später vertauscht. Der Beweis erfolgt analog.

Dieses Lemma (mit seinem analogen Zwilling) wird nun benutzt, um eine hinreichende Bedingung für eine mögliche Zuordnung aufzustellen.\\
Offensichtlich teilt im Fall $n_L = 2$ jede Zuordnung die Logs in eine spätere und eine frühere Hälfte, also lautet diese Bedingung nun einfach, dass beide Hälften nach der oben definierten, hinreichenden Bedingung eine gültige Lösung besitzen müssen:

\begin{lem}\label{n_L=2,solution}
	Sei $r$ ein Emfangsereignis, $s \in S(r)$ ein ihm zugeordnetes Sendeereignis und $v$ eine Vektoruhr mit $r_{min} \leq v \leq r_{max}$ und $s_{min} \leq v \leq s_{max}$.\\
	Sei $A_i = \{ e \in L_i | e_i < v_i\}$ und $B_i = \{ e \in L_i | e_i > v_i\}$.\\
	Erfüllen die $B_i $ eine der folgenden Eigenschaften:
	\begin{enumerate}
		\item Es gibt ein $l$, so dass $B_m \cap R = \emptyset$ für $l \neq m$ ist.
		\item Es gibt ein $l$ und $q \in B_l \cap R$ mit $q_{max}\geq v$ und $q \leq e$ für alle $e\in B_l$, so dass für ein $t \in \{S_f(q), S_l(q)\} \subseteq L_m$ gilt $t \geq v$ und $t \leq e$ für alle $e \in B_m$.
	\end{enumerate}
	Und erfüllen die $A_i $ gleichfalls eine der folgenden Eigenschaften:
	\begin{enumerate}
		\item Es gibt ein $l$, so dass $A_m \cap R = \emptyset$ für $l \neq m$ ist.
		\item Es gibt ein $l$ und $r \in A_l \cap R$ mit $r_{min} \leq v$ und $r \geq e$ für alle $e\in A_l$, so dass für ein $s \in \{S_f(r), S_l(r)\} \subseteq L_m$ gilt $s \leq v$ und $s \geq e$ für alle $e \in A_m$.
	\end{enumerate}
	
	So existiert eine gültige Lösung, die $r$ und $s$  einander zuordnet, also beiden die Vektoruhr $v$ zuweist.
	
	%Wählt man eine Vektoruhr $V'(r)$ mit $r_{min} \leq V'(r) \leq r_{max}$ so, dass entweder $S'(r) = \{S_f(r)\}$ oder $S'(r) = \{S_l(r)\}$ gilt, so % $r_{min} \leq V'(r) \leq r_{max}$ (wobei $r_{min}, r_{max}$ vom Algorithmus bestimmt wurden) für ein Empfangsereignis $r$, die $r$ tatsächlich ein Sendeereignis zuweist, also $|S'(r)| = 1$, 
	%gibt es eine bijektive Sortierfunktion $q: \{1,2,\ldots, n_R\} \rightarrow R$ und weitere Vektoruhren $V'(r)$ mit $V'(q_i) \leq V'(q_j)$ für $i < j$, so dass gilt $q_{min} \leq V'(q) \leq q_{max}$, $|S'(q)| = 1$ für alle $q \in R$ und $S'(q) \neq S'(p)$ falls $V'(q) \neq V'(p)$ gilt.
	%globale Folge von Vektoruhren $q_1 \leq q_2 \leq \ldots \leq q_{n_r}$, so dass es ein $q_i = V'(r)$ gibt und für jedes $p \in R$ ein $q_j$ mit $q_{min} \leq q_j \leq q_{max}$ und zudem für jedes dieses $q$ ein $t \in S(p)$ mit $t_{min} \leq q_j \leq t_{max}$.
\end{lem}
\begin{proof}
	\OBDA sei $r \in L_1$ und $s \in L_2$.
	
	Sei $A=\bigcup_i A_i$ und $B = \bigcup_i B_i$.
	
	Offensichtlich ist $L_i = \{e \in L_i | e_i < v_i\} + \{e \in L_i | e_i = v_i\} + \{e \in L_i | e_i > v_i\}$.\\
	Man kann die Logs also aufteilen in:
	\[L_1 = A_1 + \{r\} + B_1\]
	\[L_2 = A_2 + \{s\} + B_2\]
	Dann gibt es eine gültige Lösung für $\{r\} \cup \{s\}$ mit $V'(r) = V'(s) = v$.
	
	Nach dem zuvor gezeigten Lemma \ref{lem:n_L=2,splittedlogs} gibt es eine gültige Lösung für $B_i$ mit $V'(q) \geq v$ für alle $q \in B_i \cap R_i$ und auf Grund der Symmetrie von $S_f$ und $S_l$ muss es auch eine gültige Lösung für $A_i$ mit $V'(q) \leq v$ für alle $q \in A_i \cap R$ geben.
	
	Somit existiert nach Lemma \ref{lem:solution_cut} eine gemeinsame gültige Lösung $(V', e)$ für $L_i$ mit $V'(r) = v$.
\end{proof}


%\begin{lem}
%Ist $r_1, \ldots r_n \in R$ mit $V'(r_1) \leq \ldots \leq V'(r_n)$, $V'(r_i) = \max(V'(r_{i-1}), S_l(r_i)_{min})$ mit $V'(r_0)$ beliebig gewählt, $r_{i_{min}} \leq V'(r_i) \leq r_{i_{max}}$ und $S_l(r_i)_{min} \leq V'(r_i) \leq S_l(r_i)_{max}$ gegeben, so folgt aus $V'(q) \neq V'(r)$, dass $S'(q) \neq S'(r)$ gilt.
%\end{lem}
%\begin{proof}
%%Zu zeigen ist: es gibt keine $p,r \in R$ mit $P(p) = P(r)$, $V'(p)_k = V'(r)_k$ und $V'(p) \neq V'(r)$
%Zu zeigen ist: Für $p,r \in R$ mit $P(p) = P(r)$ und $V'(p)_k = V'(r)_k$ gilt immer $V'(p) = V'(r)$
%
%
%Fall 1: Sind $p, r$ im selben Log $L_m$. \\
%Angenommen die Behauptung gelte nicht, es gelte also $V'(p) \neq V'(r)$ und $V'(p)_k = V'(r)_k$.  O.B.d.A. Sei $V'(p) \leq V'(r)$\\
%Aus $P(p) = P(r)$ folgt, es gibt ein $k$ mit $S(p), S(r) \subseteq L_k$ \\
%Da $p_m$ eindeutig ist, ist $p \leq r$, also gilt $p_{k,max} < r_{k,max}$ nach einem obigen Lemma.\\
%Daraus folgt $V'(p)_k = S_l(p)_{k} = p_{k,max} < r_{k,max} = S_l(r)_{k} = V'(r)_k$, also $V'(p)_k \neq V'(r)_k$.
%%Das heißt $S'(p) \neq S'(q_j)$, was zu zeigen war. 
%%Da $S_l(q_i)_{m,min} = q_{i_m} < q_{j_m} = S_l(q_j)_{m,min}$ gilt, ist $S_l(q_i) \neq S_l(q_j)$ und somit gilt nach $i < j$ und der Eindeutigkeit des $k$-ten Index im $k$-ten Log $\max(S_l(q_i)_k, S_l(q_j)_k) \neq S_l(q_i)_k$ und somit $S'(q_i) \neq S'(q_j)$ 
%%(Es gilt auch für den Spezialfall $q_i = r$, da $s \leq S_l(r)$ sein muss)
%
%Fall 2: Sind $p, r$ in unterschiedlichen Logs. \\
%O.B.d.A sei $S(p), S(r) \subseteq L_1$ (also $k = 1$), $p\in L_2$ und $r \in L_3$\\
%Für $p,r \in R$ gilt $P(p) = P(r)$ und $V'(p)_1 = V'(r)_1$\\
%Daraus folgt mit $S_l(p)_{min} \leq V'(p) \leq S_l(p)_{max}$ und $S_l(p)_{1,min} = S_l(p)_{1,max}$, dass gilt $p_{1,max} = S_l(p)_1 = V'(p)_1 = V'(r)_1 = S_l(r)_1 = r_{1,max}$
%
%Induktionsannahme: Für  $q \in R$ mit $V'(p) \leq V'(q) \leq V'(r)$ gilt $S_l(q)_{min} \leq S_l(p)_{min}$ %Ist $V'(q_i) \neq V'(q_j)$, so ist $S'(q_i) \neq S'(q_j)$
%
%Da $V'(p)_1 = V'(r)_1$ ist, gilt offensichtlich für jedes $q$, dass $S_l(q)_{1,min} \leq  V'(p)_1$, also $q_{1,min} \leq S_l(q)_{1,min} \leq V'(p)_1 = S_l(p)_{1} = p_{1,max}$
%
%Induktionsanfang: $S(q) \in L_1$:\\
%Dann ist nach der lokalen Sortierung $S_l(q)_{1} \leq S_l(p)_1$, also $S_l(q) \leq S_l(p)$ und somit $S_l(q)_{min} \leq S_l(p)_{min}$
%
%Ist $S_l(q) \in L_2$, so ist $S(q)$\\
%Fall 1: $S_l(q)_2 < p_2 \Rightarrow S_l(q)_{min} \leq p_{min} \leq S_l(p)_{min}$ \\
%Fall 2: $S_l(q)_2 > p_2 \Rightarrow S_l(q)_{min} \geq p_{min} \leq S_l(p)_{min}$ \\
%
%Induktionsanfang: $q \in L_1 \cap R$:\\
% $q_{1} = q_{1,min} \leq S_l(p)_{1}$, woraus folgt $q_1 < S_l(p)_1$, da $q$ kein Sendeereignis ist.\\
%Also ist $q \leq S_l(p)$, also $q$
%
%
%Induktionsschritt $n'_l := n_l + 1$\\
%Angenommen es gibt $q_i, q_j$ mit $P(q_i) = P(q_j)$, $V'(q_i)_k = V'(q_j)_k$ und $V'(q_i) \neq V'(q_j)$\\
%Daraus folgt als erstes $S'(q_i) = S'(q_j)$, also $S_l(q_i) = S_l(q_j)$ und somit $q_{i_{k,max}} = q_{j_{k,max}}$\\
%Dann muss es ein $q_l$ mit $V'(q_i) \leq V'(q_l) \leq V'(q_j)$ und $S_l(q_l)_{v,min} > S_l(q_i)_{v,min} = S_l(q_j)_{v,min}$ geben für mindestens ein $v$.\\ %Aus der ersten Bedingung folgt $S_l(q_l)_{min} \leq S_l(q_l)_{min}$
%Fall 1: $S_l(q_l) \subseteq L_k$ und $q_{l_{k,max}} =  q_{i_{k,max}} =  q_{j_{k,max}}$\\
%Daraus folgt $S_l(q_l)= S_l(q_i)$, dieser Fall kann also nicht auftreten, da es dann kein $v$ gäbe\\ 
%Fall 2: $S_l(q_l) \subseteq L_k$ und $q_{l_{k,max}} \neq  q_{i_{k,max}} =  q_{j_{k,max}}$\\
%Aus der Existenz des $v$ folgt mit Wischen $S_l(q_l) \geq S_l(q_i), S_l(q_l) \neq S_l(q_i)$, also $S_l(q_l)_k > S_l(q_i)_k$ und somit $V'(q_j)_k \geq V'(q_l)_k > V'(q_i)_k$. Widerspruch\\
%Fall 3: $S_l(q_l) \nsubseteq L_k$ \\
%$S_l(q_l)$ ist 
%Aus $V'(q_i)_k = V'(q_j)_k$ folgt $S_l(q_l)_{k,min} \leq S_l(q_i)_k$
%\end{proof}
%
%Damit hat man nun Vektoruhren mit einer gültigen, globalen Reihenfolge für alle Empfangsereignisse gefunden, welche die anfänglichen  Zuordnung beibehält, dabei jedem Empfangsereignis ein Sendeereignis zuweist und keine Widersprüche aufweist.\\
%Daraus kann man einfach schlussfolgern, dass es auch eine Fortsetzung über alle Sendeereignisse gibt:
%

Es lohnt sich einen Spezialfall des obigen Lemmas zu betrachten, nämlich, dass die anfängliche Zuordnung entweder zum frühesten oder spätesten vom Algorithmus als möglich erklärten Sendeereignis erfolgt.
Dann sind die beiden Bedingungen nämlich automatisch erfüllt:

\begin{lem}
	Wählt man eine Vektoruhr $V'(r)$ mit $r_{min} \leq V'(r) \leq r_{max}$ so, dass gilt $S'(r) = \{S_f(r)\}$ oder $S'(r) = \{S_l(r)\}$, so gibt es eine gültige Lösung $(V', f)$ mit dieser Wahl von $V'(r)$.
\end{lem}
\begin{proof}
	\OBDA sei $r\in L_1$ und $s\in L_2$.
	
	Offensichtlich folgt aus $r_{min} \leq V'(r) \leq r_{max}$ und $s_{min} \leq V'(r) \leq s_{max}$, dass gilt $V'(r) = (r_1, s_2)$.
	
	Sei $B_i = \{r \in R_i  | r_{i} > v_i\} \neq \emptyset$.\\
	Gibt es ein $B_i = \emptyset$ ist die erste Bedingungen im Lemma \ref{n_L=2,solution} erfüllt.\\
	Ist $B_i \neq \emptyset$ für alle $i$, existiert nach dem Lemma \ref{lem:n2firstLastOkay} ein $l$, ein $r' \in K_l$ mit $r'_{max} \geq v$ und $r' \leq q$ für alle $q \in K_l$ und ein $s' \in \{S_f(r), S_l(r)\}$ mit $s' \neq s$, $s'_{max} \geq v$ und $s' \leq q$ für alle $q \in K_m$ für $m \neq l$, was die zweite Bedingung erfüllt.\\
	Also erfüllt $B_i$ immer mindestens eine der beiden Bedingungen.
	
	Analoges lässt sich auf Grund der Symmetrie für $A_i$ zeigen.
	
	Also existiert nach dem vorherigen Lemma \ref{n_L=2,solution} eine gültige Lösung mit diesem Wert von $V'(r)$.
	
	%	Dies folgt aus obigem Lemma und dem Lemma, dass eine gültige Reihenfolge der Empfangsereignisse mit $|S(r)|=1$ und $S(p) \neq S(q)$ für $p\neq q$ zu einer gültige Lösung fortgesetzt werden kann.
	%%Sei $V'(r)$ entsprechend gesetzt, o.B.d.A sei $r \in L_1$, $s \in L_2$\\
	%%Sei $V'(r)_2 := s_2$, $V'(s)_1 := r_1$\\
	%%Für jedes Empfangsereignis $q \in L_1$ sei $V'(q)_2 := \begin{cases}
	%%q_{2,min} & \text{für } q_1 < r_1 \\
	%%q_{2,max} & \text{für } q_1 > r_1
	%%\end{cases}$\\
	%%Für jedes Empfangsereignis $q \in L_2$ sei $V'(q)_1 := \begin{cases}
	%%q_{1,min} & \text{für } q_2 < s_2 \\
	%%q_{1,max} & \text{für } q_2 > s_2
	%%\end{cases}$\\
	%%Da $S_f(q)_{min} \leq q_{min} \leq s_f(q)_{max}$ und $S_l(q)_{min} \leq q_{max} \leq s_l(q)_{max}$ für alle q gilt, ist $|S(q)| \geq 1$ für die obige Zuordnung.\\
	%%Für jedes $s \in S(q)$ gilt ebenso $V'(q) \leq V'(s) \leq V'(q)$ und da mindestens ein Wert der (Intervall-)Vektoruhr eindeutig ist, ist $|S(q)| = 1$. (Bedingung 4)\\
	%%Setze $V'(s) := q$ für das $s \in S(q)$ für alle $q$. (Bedingung 5 und für $L \cap (R \cup S(R))$ auch Bedingung 3)\\
	%%%Da jedem Empfangsereignis ein Sendeereignis 
	%%Nach Lemma (s.o.) sind die $q_{max}$, $q_{min}$ innerhalb eines Logs eindeutig, also gibt es für ein $t \in S(R)$ genau ein $q \in R$ mit $t \in S(r)$. (die vorausgesetzte $r,s$ sind offensichtlich unterschiedlich im Vergleich zu den min/max) (Bedingung 6)\\
	%%%Offensichtlich existiert eine globale Anordnung $e_i: {1,..,n} \rightarrow R \cup S(R)$, die man dadurch erhalten kann, dass man die Vektoruhren nach ihrer ersten Komponente (und bei deren Gleichheit nach der zweiten Komponente) sortiert. (Bedingung 1)\\
	%%Nach Lemma (s.o.) gibt es eine globale Anordnung $e_i$ für das Maximum und Minimum aller Empfangsereignissen. Da offensichtlich $V(p)_min \leq V'(r) \leq q_max$ für alle $p,q \in R$ gilt, gibt es eine globale Anordnung aller Empfangsereignisse.\\
	%%Da es für jedes Sendeereignis $t \in S(R)$ ein $q \in R$ mit $V'(q) = V'(t)$ gibt, ist diese zur globalen Anordnung aller Sendeereignisse identisch. (Bedingung 1)\\
	%%Da $V'(a)_i$ für alle $a \in L'_i$ eindeutig ist, folgt daraus trivialerweise, dass auch Bedingung 2 erfüllt ist.
	%%
	%
	%
	%
\end{proof}

Damit hat man nun gezeigt, dass jede vom Algorithmus als möglich deklarierte minimale oder maximale Vektoruhr eines Empfangsereignisses tatsächlich im Spezialfall $n_L=2$ zu einer gültigen Lösung führt.
%Dasselbe gilt daher auch, wie zu Beginn gezeigt, für sämtliche Ereignisse, also auch die Sendeereignisse.

%Damit wurde eine gültige Lösung mit den geforderten Eigenschaften für $R \cup S(R)$ gefunden und aus dem Lemma (s.o) folgt, dass es eine gültige Lösung für ganz $L$ gibt.


%\section{Allgemeiner Fall}


%\chapter{Quellcode}
  
  
\chapter{Notation}
Hier werden die wichtigsten in dieser Arbeit verwendete Symbole in alphabetischer Reihenfolge aufgezählt:

\begin{longtable}{lll}
$\LTA, \LTB, \LTC$ && Trennsymbole bei der Reduktion von X3C auf uSRC\\
$\prec_l$ &$\prec_l \subseteq L_l \times L_l$& Eine für jedes Log lokale Ordnungsrelation\\
$\preceq_l$ & $\prec_l \vee =$ & Reflexive Version von $\prec_l$\\
$\prec$ &$\prec \subseteq S \times S$& GTO, Globale Ordnungsrelation über alle Sendeereignisse\\
$\square, \boxdot$ && Symbolisieren irrelevante Ereignisse\\
$A$ & $A:L\rightarrow S$ & GA, Für jedes Ereignis ein zugeordnetes Sendeereignis \\
$B$ & $B: L \rightarrow \packetTypSet$ & Basistyp eines Ereignisses bei der X3C->SRC Reduktion\\ 
$A,B,\ldots,X,Y$ && Sendeereignis; die Buchstabenart bestimmt den Typ\\% mit dem durch den Buchstaben gegebenen Typ\\
$a,b,\ldots,x,y$ && Empfangsereignisse; die Buchstabenart bestimmt den Typ\\% mit dem durch den Buchstaben gegebenen Typ\\
$\alpha, \beta, \gamma$ &$\alpha, \beta, \gamma \in M_i$& Alle Elemente in der X3C-Menge $M_i$\\
$C$ & $C:M \rightarrow \mathbb{N}$ & Zahl der ein bestimmtes Element enthaltenden X3C-Mengen\\
$D$ & $D: L \rightarrow \{\tilde{s}, \tilde{r}\}$ & Unterscheidet Sende- und  Empfangsereignisse\\
$E^m_{kl}$ &$E^m_{kl} \in L_k$& Spezielles Sendeereignis bei der X3C->SRC-Reduktion\\
%$\mathbf{E}^m_{kl}$ &$\{E^m_{kl}\}$  & Alle speziellen Sendeereignisse in einem Log\\
$e_{kl}$ &$E_{kl} \in L_l$& Spezielles Empfangsereignis bei der X3C->SRC-Reduktion\\
%$\mathbf{e}_{kl}$ &$\{e_{kl}\}$ & Alle speziellen Empfangsereignisse in einem Log\\
$e, f$ & & Beliebige Ereignisse\\
$e, f$ & $e,f: \mathbb{N} \rightarrow L$ & Bei der Heuristik eine Sortierfunktion\\
$i,j,k,l,m$ && Indizes\\
$I$ & & Bei der Heuristik Indexmenge der Ereignisse\\
$I$ &$I \subset \mathbb{N}$& Nummern der X3C-Mengen einer Überdeckung\\
$J$ &$J \subset \mathbb{N}$& Nummern der Mengen nicht in einer Überdeckung\\
$L$ &$L=\bigcup_i L_i$ & Sämtliche Ereignisse\\
$L_0$ && Spezielles Log mit Sendeereignissen (nur Komplexität)\\
$H_l, K_l, L_l$&&Log $l$, eine Menge von Ereignissen \\
$M$ & $M=\{1,\ldots,m_T\}$ & Die Elemente der bei X3C zu überdeckenden Menge\\
$M_i$ & $$ & Eine der bei X3C zur Auswahl stehenden Mengen\\
$m_T$ & & Anzahl der Elemente bei X3C\\
$N$ & $N: L \rightarrow \mathbb{N}$ & Für jedes Ereignis die Nummer des enthaltenden Logs\\
$n_L$ && Zahl der Logs (falls $L_0 \neq \emptyset$ ist, gibt es $n_L+1$ Logs)\\
$P$ & $P: L \rightarrow \packetTypSet$ & Der Pakettyp eines Ereignisses\\
$p, q, r$ && Empfangsereignisse\\
$\packetTypSet$ && Die Menge aller Pakettypen\\
$r,s,t$ && Sendeereignisse\\
$R$ && Die Menge aller Empfangsereignisse\\
$S$ & & Die Menge aller Sendeereignisse\\
$S(r)$ && Alle für $r$ gefundenen Sendeereignisse (nur Heuristik)\\
$S_f(r)$ & $ S_f(r) \in S(r)$&Frühestes Ereignis in $S(r)$\\
$S_l(r)$ & $ S_l(r) \in S(r)$&Spätestes Ereignis in $S(r)$\\
$T_i$ &$\{T_i\}\subseteq\{M_i\}$& Eine zur Lösung von X3C gehörende Menge\\
$V(e)$ & $V: L \rightarrow  I^{n_L} \times I^{n_L}$ & (Intervall-)vektoruhr für $e$ (nur Heuristik)\\
$V(e)_{min}$ & & Minimumspalte einer Intervallvektoruhr\\
$V(e)_{max}$ & &Maximumspalte einer Intervallvektoruhr\\
$V(e)_{i,m}$ && Eintrag einer Intervallvektoruhr\\
$X$ & $X > m_T$ & Ein zusätzlicher Typ bei der Reduktion von X3C\\
$x$ && Ein Ereignis mit Typ X bei X3C
\end{longtable}

Diese Liste ist nicht vollständig, es fehlen zum Beispiel alle gestrichenen Variablen wie $i'$, welche dieselbe   Grundbedeutung wie die ungestrichenen haben. In manchen Beweisen, vor allem bei denen bezüglich der  Heuristik, werden zudem kurzzeitig neue Bedeutungen eingeführt, diese sind aber jeweils aus dem Kontext ersichtlich.

